# Classçš„ç»§æ‰¿

- [Classçš„ç»§æ‰¿](#classçš„ç»§æ‰¿)
  - [1.ç®€ä»‹](#1ç®€ä»‹)
  - [2.Object.getPrototypeOf()](#2objectgetprototypeof)
  - [3.super keyword](#3super-keyword)
  - [4.ç±»çš„prototypeå±æ€§å’Œprotoå±æ€§](#4ç±»çš„prototypeå±æ€§å’Œprotoå±æ€§)

## 1.ç®€ä»‹

Class can be inherited through the <code style="color:#ea4335">external</code> keyword. It's clearer and covenienter than ES5 which inherits through modifying the prototype chain

```js
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // è°ƒç”¨çˆ¶ç±»çš„constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // è°ƒç”¨çˆ¶ç±»çš„toString()
  }
}
```

The subclass must call the <code style="color:#ea4335">super</code> method in the <code style="color:#ea4335">constructor</code> method , Oherwise, an error will be reported when creating an instance

This is because the subclass's own <code style="color:#ea4335">this</code> Object,it's shaping must be done through the constructor of the parent class first , obtain the instance property and method same as parent class, and then process it,add the instance own instance attributes and methods.

- The inheritance of ES5  is essentially to create instance Objects <code style="color:#ea4335">this</code> of the subclass first, And then add the methods of parent class to <code style="color:#ea4335">this</code>
- The inheritance of ES6  is essentially to add the properties and method of parent class to <code style="color:#ea4335">this</code>(so must call <code style="color:#ea4335">super</code> method first),and then call the constructor of subclass to modify <code style="color:#ea4335">this</code>

if subclass didn't define <code style="color:#ea4335">constructor</code>, this method will be added by default. In other words , no matter whether it is explicitly defined or not, any subclass has a constructor method.

```js
class ColorPoint extends Point {
}

// ç­‰åŒäº
class ColorPoint extends Point {
  constructor(...args) {
    super(...args);
  }
}
```

Another thing to note is that in the constructor of subclass, you can use the <code style="color:#ea4335">this</code> keyword only after calling <code style="color:#ea4335">super</code>,otherwise an error will be reported. This is because the constructor of the subclass instance is based on the parent class instance, only <code style="color:#ea4335">super</code> method can call the parent class instance.

```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // æ­£ç¡®
  }
}
```

Finally, the static methods of the parent class will also be inherited by the subclass.

```js
class A {
  static hello() {
    console.log('hello world');
  }
}

class B extends A {
}

B.hello()  // hello world
```

## 2.Object.getPrototypeOf()

<code style="color:#ea4335">Object.getPrototypeOf</code>method can get parent class from subclass.

```js
Object.getPrototypeOf(ColorPoint) === Point
// true
```

## 3.super keyword

The <code style="color:#ea4335">super</code> keyword can be used as a function or as an Object. In these two case, its usage if completely different.

The first case ,<code style="color:#ea4335">super</code> be used as a function. Representing the constructor of parent class.

```js
class A {}

class B extends A {
  constructor() {
    super();
  }
}
```

Notice

- Although <code style="color:#ea4335">super</code>
represent the constructor of parent Class A, it returns an instance of the subclass B. So <code style="color:#ea4335">super</code> is equivalent to <code style="color:#ea4335">A.prototype.constructor.call(this)</code>
- As a function, <code style="color:#ea4335">super()</code>can only be used in the constructor of the subclass, an error will be reported if it is used in other place.

```js
class A {
  constructor() {
    console.log(new.target.name);
  }
}
class B extends A {
  constructor() {
    super();
  }
}
new A() // A
new B() // B
```

The second case, super be used as Object.

- in common method, it points to the prototype object of the parent class
- in static method, it points to parent class

Common method:

```js
class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2
  }
}

let b = new B();
```

The above code,<code style="color:#ea4335">super.p()</code> in the subclass B,is to use super as an object.

<code style="color:#ea4335">super</code>in the ordinary method, pointing to <code style="color:#ea4335">A.prototype</code>, so <code style="color:#ea4335">super.p</code> is equivalent to<code style="color:#ea4335">A.prototype.p()</code>

Note here because <code style="color:#ea4335">super</code>point to prototype Obejct of parent class, so the methods or properties defined on the instance of the parent class can't call through <code style="color:#ea4335">super</code>

```js
class A {
  constructor() {
    this.p = 2;
  }
}

class B extends A {
  get m() {
    return super.p;
  }
}

let b = new B();
b.m // undefined
```

ES6 stipulates that when a method of parent class is called through <code style="color:#ea4335">super</code>in a common method of a subclass,<code style="color:#ea4335">this</code>inside the method points to the current instance of the subclass.

```js
class A {
  constructor() {
    this.x = 1;
  }
  print() {
    console.log(this.x);
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  m() {
    super.print();
  }
}

let b = new B();
b.m() // 2
```

ğŸ‘†The actual execution is <code style="color:#ea4335">super.print.call(this)</code>.
That is A.prototype.print.call(this)

Because <code style="color:#ea4335">this</code> points to subclass instance, so if assign a value to an attribute through <code style="color:#ea4335">super</code>, At this time<code style="color:#ea4335">super</code> is <code style="color:#ea4335">this</code>,the attribute will becaome the attribute of the subclass instance

```js
class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}

let b = new B();
```

when reading <code style="color:#ea4335">super.x</code>,it reads <code style="color:#ea4335">A.prototype.x</code>,so it return <code style="color:#ea4335">undefined</code>

Static method:

If super is used as an object and it is used in a static method, At this time <code style="color:#ea4335">super</code>will point to the parent class

```js
class Parent {
  static myMethod(msg) {
    console.log('static', msg);
  }

  myMethod(msg) {
    console.log('instance', msg);
  }
}

class Child extends Parent {
  static myMethod(msg) {
    super.myMethod(msg);
  }

  myMethod(msg) {
    super.myMethod(msg);
  }
}

Child.myMethod(1); // static 1

var child = new Child();
child.myMethod(2); // instance 2
```

in addtion, when calling the methods of the parent class by <code style="color:#ea4335">super</code> in the subclass static method,the <code style="color:#ea4335">this</code>inside the method points to the current subclass instead of instance of subclass

```js
class A {
  constructor() {
    this.x = 1;
  }
  static print() {
    console.log(this.x);
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  static m() {
    super.print();
  }
}

B.x = 3;
B.m() // 3
```

Notice,when using <code style="color:#ea4335">super</code>
. You must explicitly sepcify whether it is used as a function or as an object,othersise an error will be report.

```js
class A {}

class B extends A {
  constructor() {
    super();
    console.log(super); // æŠ¥é”™
  }
}
```

ğŸ‘†can't tell if it is used as a function or as an object. so the JavaScript engine will report an error when parsing the code.

Finally, because an object always inherit other obejct,so you can use <code style="color:#ea4335">super</code> keyword in any Object.

```js
var obj = {
  toString() {
    return "MyObject: " + super.toString();
  }
};

obj.toString(); // MyObject: [object Object]
```

## 4.ç±»çš„prototypeå±æ€§å’Œprotoå±æ€§

Among the ES5 implementations of most browsers, ervey Object has <code style="color:#ea4335">\_\_proto\_\_</code> attributes , it points to <code style="color:#ea4335">prototype</code> attributes of constructor function.

Class is syntactic sugar for the constructor, and has <code style="color:#ea4335">prototype</code> attributes and <code style="color:#ea4335">\_\_proto\_\_</code> attributes at the same time.

So there are two inheritance chains at the same time

- The <code style="color:#ea4335">\_\_proto\_\_</code> attributes of subclass represents the inheritance of the constructor and always point to parent class.
- the <code style="color:#ea4335">\_\_proto\_\_</code> attribute of the prototype attribute of the subclass,representing the inheritance of method, pointing to the <code style="color:#ea4335">prototype</code>attributes of parent class

```js
class A {
}

class B extends A {
}

B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true
```

The result is because the inheritance of the class is implemented according to the following pattern

```js
class A {
}

class B {
}

// B çš„å®ä¾‹ç»§æ‰¿ A çš„å®ä¾‹
Object.setPrototypeOf(B.prototype, A.prototype);

// B ç»§æ‰¿ A çš„é™æ€å±æ€§
Object.setPrototypeOf(B, A);

const b = new B();
```

The implementation of <code style="color:#ea4335">Object.setPrototypeOf</code>

Therefore, the above result is obtain

```js
Object.setPrototypeOf = function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}

Object.setPrototypeOf(B.prototype, A.prototype);
// ç­‰åŒäº
B.prototype.__proto__ = A.prototype;
//ç­‰åŒäº
B.prototype = Object.create(A.prototype);


Object.setPrototypeOf(B, A);
// ç­‰åŒäº
B.__proto__ = A;
```

There two inheritance chains can be understood like this

- As a Object, The prototype(<code style="color:#ea4335">\_\_proto\_\_</code> attributes) of the subclass(B) is the parent class(A)
- As a constructor function,The prototype Object(<code style="color:#ea4335">prototype</code> attributes)of the subclass(B) is an instance of the prototype Object(<code style="color:#ea4335">prototype</code> attribute )of the parent class

Below, two cases are discussed.

The first case is that the subclass inherits the <code style="color:#ea4335">Object</code> class

```js
class A extends Object {
}

A.__proto__ === Object // true
A.prototype.__proto__ === Object.prototype // true
```

In this cases,<code style="color:#ea4335">A</code> is actually a copy of the constructor <code style="color:#ea4335">Object</code>,the instance of  <code style="color:#ea4335">A</code> is actually an instance of <code style="color:#ea4335">Object</code>

$\color{#B620E0}{question:}$

the instance of A is an instance of Object?

Isn't the prototype of A is an instance of B?

In the second case, there is no inheritance

```js
class A {
}

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === Object.prototype // true
```

In this case, <code style="color:#ea4335">A</code>
as a base class(there is no inheritance), it just a common method so it inherit directly <code style="color:#ea4335">Function.prototype</code>
