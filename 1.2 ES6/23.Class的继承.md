# ClassÁöÑÁªßÊâø

- [ClassÁöÑÁªßÊâø](#classÁöÑÁªßÊâø)
  - [1.ÁÆÄ‰ªã](#1ÁÆÄ‰ªã)
  - [2.Object.getPrototypeOf()](#2objectgetprototypeof)
  - [3.super keyword](#3super-keyword)

## 1.ÁÆÄ‰ªã

Class can be inherited through the <code style="color:#ea4335">external</code> keyword. It's clearer and covenienter than ES5 which inherits through modifying the prototype chain

```js
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // Ë∞ÉÁî®Áà∂Á±ªÁöÑconstructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // Ë∞ÉÁî®Áà∂Á±ªÁöÑtoString()
  }
}
```

The subclass must call the <code style="color:#ea4335">super</code> method in the <code style="color:#ea4335">constructor</code> method , Oherwise, an error will be reported when creating an instance

This is because the subclass's own <code style="color:#ea4335">this</code> Object,it's shaping must be done through the constructor of the parent class first , obtain the instance property and method same as parent class, and then process it,add the instance own instance attributes and methods.

- The inheritance of ES5  is essentially to create instance Objects <code style="color:#ea4335">this</code> of the subclass first, And then add the methods of parent class to <code style="color:#ea4335">this</code>
- The inheritance of ES6  is essentially to add the properties and method of parent class to <code style="color:#ea4335">this</code>(so must call <code style="color:#ea4335">super</code> method first),and then call the constructor of subclass to modify <code style="color:#ea4335">this</code>

if subclass didn't define <code style="color:#ea4335">constructor</code>, this method will be added by default. In other words , no matter whether it is explicitly defined or not, any subclass has a constructor method.

```js
class ColorPoint extends Point {
}

// Á≠âÂêå‰∫é
class ColorPoint extends Point {
  constructor(...args) {
    super(...args);
  }
}
```

Another thing to note is that in the constructor of subclass, you can use the <code style="color:#ea4335">this</code> keyword only after calling <code style="color:#ea4335">super</code>,otherwise an error will be reported. This is because the constructor of the subclass instance is based on the parent class instance, only <code style="color:#ea4335">super</code> method can call the parent class instance.

```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // Ê≠£Á°Æ
  }
}
```

Finally, the static methods of the parent class will also be inherited by the subclass.

```js
class A {
  static hello() {
    console.log('hello world');
  }
}

class B extends A {
}

B.hello()  // hello world
```

## 2.Object.getPrototypeOf()

<code style="color:#ea4335">Object.getPrototypeOf</code>method can get parent class from subclass.

```js
Object.getPrototypeOf(ColorPoint) === Point
// true
```

## 3.super keyword

The <code style="color:#ea4335">super</code> keyword can be used as a function or as an Object. In these two case, its usage if completely different.

The first case ,<code style="color:#ea4335">super</code> be used as a function. Representing the constructor of parent class.

```js
class A {}

class B extends A {
  constructor() {
    super();
  }
}
```

Notice

- Although <code style="color:#ea4335">super</code>
represent the constructor of parent Class A, it returns an instance of the subclass B. So <code style="color:#ea4335">super</code> is equivalent to <code style="color:#ea4335">A.prototype.constructor.call(this)</code>
- As a function, <code style="color:#ea4335">super()</code>can only be used in the constructor of the subclass, an error will be reported if it is used in ohter place.

```js
class A {
  constructor() {
    console.log(new.target.name);
  }
}
class B extends A {
  constructor() {
    super();
  }
}
new A() // A
new B() // B
```

The second case, super be used as Object.

- in common method, it points to the prototype object of the parent class
- in static method, it points to parent class

Common method:

```js
class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2
  }
}

let b = new B();
```

The above code,<code style="color:#ea4335">super.p()</code> in the subclass B,is to use super as an object.

<code style="color:#ea4335">super</code>in the ordinary method, pointing to <code style="color:#ea4335">A.prototype</code>, so <code style="color:#ea4335">super.p</code> is equivalent to<code style="color:#ea4335">A.prototype.p()</code>

Note here because <code style="color:#ea4335">super</code>point to prototype Obejct of parent class, so the methods or properties defined on the instance of the parent class can't call through <code style="color:#ea4335">super</code>

```js
class A {
  constructor() {
    this.p = 2;
  }
}

class B extends A {
  get m() {
    return super.p;
  }
}

let b = new B();
b.m // undefined
```

ES6 stipulates that when a method of parent class is called through <code style="color:#ea4335">super</code>in a common method of a subclass,<code style="color:#ea4335">this</code>inside the method points to the current instance of the subclass.

```js
class A {
  constructor() {
    this.x = 1;
  }
  print() {
    console.log(this.x);
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  m() {
    super.print();
  }
}

let b = new B();
b.m() // 2
```

üëÜThe actual execution is <code style="color:#ea4335">super.print.call(this)</code>.
That is A.prototype.print.call(this)

Because <code style="color:#ea4335">this</code> points to subclass instance, so if assign a value to an attribute through <code style="color:#ea4335">super</code>, At this time<code style="color:#ea4335">super</code> is <code style="color:#ea4335">this</code>,the attribute will becaome the attribute of the subclass instance

```js
class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}

let b = new B();
```

when reading <code style="color:#ea4335">super.x</code>,it reads <code style="color:#ea4335">A.prototype.x</code>,so it return <code style="color:#ea4335">undefined</code>

Static method:

If super is used as an object and it is used in a static method, At this time <code style="color:#ea4335">super</code>will point to the parent class

```js
class Parent {
  static myMethod(msg) {
    console.log('static', msg);
  }

  myMethod(msg) {
    console.log('instance', msg);
  }
}

class Child extends Parent {
  static myMethod(msg) {
    super.myMethod(msg);
  }

  myMethod(msg) {
    super.myMethod(msg);
  }
}

Child.myMethod(1); // static 1

var child = new Child();
child.myMethod(2); // instance 2
```

in addtion, when calling the methods of the parent class by <code style="color:#ea4335">super</code> in the subclass static method,the <code style="color:#ea4335">this</code>inside the method points to the current subclass instead of instance of subclass

```js
class A {
  constructor() {
    this.x = 1;
  }
  static print() {
    console.log(this.x);
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
  }
  static m() {
    super.print();
  }
}

B.x = 3;
B.m() // 3
```

Notice,when using <code style="color:#ea4335">super</code>
. You must explicitly sepcify whether it is used as a function or as an object,othersise an error will be report.

```js
class A {}

class B extends A {
  constructor() {
    super();
    console.log(super); // Êä•Èîô
  }
}
```

üëÜcan't tell if it is used as a function or as an object. so the JavaScript engine will report an error when parsing the code.

Finally, because an object always inherit other obejct,so you can use <code style="color:#ea4335">super</code> keyword in any Object.

```js
var obj = {
  toString() {
    return "MyObject: " + super.toString();
  }
};

obj.toString(); // MyObject: [object Object]
```
