# let 和 const 命令

- [let 和 const 命令](#let-和-const-命令)
  - [1.let命令](#1let命令)
    - [1.1 基本用法](#11-基本用法)
    - [1.2 不存在变量提升](#12-不存在变量提升)
    - [1.3 暂时性死区](#13-暂时性死区)
    - [1.4 不允许重复声明](#14-不允许重复声明)
  - [2. 块级作用域](#2-块级作用域)
    - [2.2 ES6 的块级作用域](#22-es6-的块级作用域)
    - [2.3 块级作用域与函数声明](#23-块级作用域与函数声明)
  - [3.const 命令](#3const-命令)
    - [3.1 基本用法](#31-基本用法)
    - [3.2 本质](#32-本质)
    - [3.3 ES6 声明变量的六种方法](#33-es6-声明变量的六种方法)
  - [4. 顶层对象的属性](#4-顶层对象的属性)
  - [5. globalThis 对象](#5-globalthis-对象)

## 1.let命令

### 1.1 基本用法

```js
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
```

### 1.2 不存在变量提升

```js
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```

### 1.3 暂时性死区

暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就**已经存在了，但是不可获取**，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

temporal dead zone

```js
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

### 1.4 不允许重复声明

```js
function func(arg) {
  let arg;
}
func() // 报错

function func(arg) {
  {
    let arg;
  }
}
func() // 不报错
```

## 2. 块级作用域

### 2.2 ES6 的块级作用域

```js
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```

### 2.3 块级作用域与函数声明

- 考虑到环境导致的行为差异太大，**应该避免在块级作用域内声明函数**。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

```js
// 块级作用域内部的函数声明语句，建议不要使用
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 块级作用域内部，优先使用函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```

- ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。
- 函数声明也是如此

```js
// 第一种写法，报错
if (true) let x = 1;

// 第二种写法，不报错
if (true) {
  let x = 1;
}

// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错
'use strict';
if (true)
  function f() {}
```

## 3.const 命令

### 3.1 基本用法

```js
const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
```

### 3.2 本质

- `const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。

```js
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

- 冻结对象

```js
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```

⭐⭐⭐⭐

彻底冻结

### 3.3 ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：`var`命令和`function`命令。ES6 除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令

## 4. 顶层对象的属性

```js
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```

## 5. globalThis 对象

```js
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```

![20230113200355](56)

1. 多次dodo念
2. 不能接受v的一定会有的日常谎言
3. 没想到买❀来道歉
