# 二进制位运算符

- [二进制位运算符](#二进制位运算符)
  - [1.概述](#1概述)
  - [2.Table Of Bitwise operators](#2table-of-bitwise-operators)
    - [二进制否转换流程](#二进制否转换流程)
    - [异或运算符XOR](#异或运算符xor)
  - [6. 左移运算符](#6-左移运算符)
  - [7.右移运算符](#7右移运算符)
  - [8.头部补0的右移运算符](#8头部补0的右移运算符)
  - [9.开关作用](#9开关作用)

## 1.概述

二进制位运算符用于直接对二进制位进行计算,共有7个

这些位运算符直接处理每一个比特位,所以是非常底层的运算.

- 好处是速度极快
- 缺点是很不直观,许多场合不能使用它们，否则会使代码难以理解和查错。

$\color{#ea4335}{Tips:}$

- 位运算符只对整数起作用,如果一个操作数不是整数,会自动转成整数后再执行
- 虽然JavaScript内部数值都是以64位浮点数的形式储存,但是做位运算的时候,是以$\color{#ea4335}{32位带符号的整数}$进行运算的,并且返回值也是一个32位带符号的整数

利用👆这个特性,可以写出一个函数,将一个值转为32位整数

```js
function toInt32(x) {
    return x | 0;
}
console.log(toInt32(1.001)) //1
console.log(toInt32(1.999)) //1
console.log(toInt32(1))     //1
console.log(toInt32(-1))    //-1


//对于大于或等于2的32次方的整数，大于32位的数位都会被舍去。
console.log(toInt32(Math.pow(2, 32) + 1))   //1
console.log(toInt32(Math.pow(2, 32) - 1))   //-1
```

所以这种取整方法不适用超过32位整数最大值$\color{#ea4335}{2147483647}$的数

## 2.Table Of Bitwise operators

![20210907120443](https://raw.githubusercontent.com/Logible/Image/main/note_image/20210907120443.png)

```js
0 : 00 
3 : 11

var num1 = 0 | 3;
var num2 = 0 & 3;
var num3 = ~3;
var num4 = 0 ^ 3;

console.log("num1",num1) //3    二进制或|
console.log("num2",num2) //0    二进制与&
console.log("num3",num3) //-4   二进制否~  
console.log("num4",num4) //3    异或^
```

### 二进制否转换流程

   1. JavaScript 内部将所有的操作数都转为32位的二进制整数再进行运算。
   2. $\color{#ea4335}{3}$的32整数形式是$\color{#ea4335}{00000000000000000000000000000011}$,二进制否运算以后得到$\color{#ea4335}{11111111111111111111111111111100}$,由于第一位(符号位)是1,所以这个数是一个负数
   3. JavaScript内部采用补码形式表示负数,即需要将这个数-1,再取一次反,然后加上符号,才能得到这个负数对应的10进制值,这个数减去1等于$\color{#ea4335}{11111111111111111111111111111011}$
   4. 再取反得到$\color{#ea4335}{00000000000000000000000000000100}$,再加上符号就是$\color{#ea4335}{-4}$

以上过程可简单记忆成: 一个数与自身的取反值相加等于-1

二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果。

```js
var num1 = ~~2.9
var num2 = ~~47.11
var num3 = ~~-3

console.log(num1)   //2
console.log(num2)   //47
console.log(num3)   //-3
```

使用二进制否运算取整，是所有取整方法中$\color{#ea4335}{最快}$的一种。

对字符串进行二进制否运算,JavaScript引擎会先调用$\color{#ea4335}{Number}$函数,将字符串转成数值

```js
console.log(0xcafebabe)     //3405691582
console.log(~0xcafebabe)    //889275713
```

$\color{#B620E0}{存疑:不是相加等于-1?}$

对于其他类型的值,二进制否运算符也是先用$\color{#ea4335}{Number}$转为数值,再进行处理

```js
// 相当于 ~Number([])
~[] // -1

// 相当于 ~Number(NaN)
~NaN // -1

// 相当于 ~Number(null)
~null // -1
```

$\color{#B620E0}{存疑:为什么~NaN可以等于-1?}$

### 异或运算符XOR

<https://stackoverflow.com/questions/249423/how-does-xor-variable-swapping-work>

"异或运算"有一个特殊运用,连续对两个数$\color{#ea4335}{a}$和$\color{#ea4335}{b}}$进行三次异或运算,$\color{#ea4335}{a ^= b, b ^= a, a ^= b;}$,可以呼唤它们的值,这意味着,使用"异或运算"可以在不引入临时变量的前提下互换两个变量的值

```js
var a = 10;
var b = 99;

a ^= b, b ^= a, a ^= b;

a // 99
b // 10
```

这是互换两个变量的值的最快方法

## 6. 左移运算符

左移运算符($\color{#ea4335}{<<}$)表示将一个数的二进制向左移动指定的位数,尾部补$\color{#ea4335}{0}$,即乘以$\color{#ea4335}{2}$的指定次方

上面代码中，-4左移一位得到-8，是因为-4的二进制形式是$\color{#ea4335}{11111111111111111111111111111100}$，左移一位后得到$\color{#ea4335}{11111111111111111111111111111000}$，该数转为十进制（减去1后取反，再加上负号）即为-8。

如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。

```js
13.5 << 0
// 13

-13.5 << 0
// -13
```

存疑:$\color{#B620E0}{-4的二进制形式????????}$

## 7.右移运算符

右移运算符($\color{#ea4335}{>>}$)表示将一个数的二进制值向右移动指定的位数

- 如果是整数,头部全部补0
- 如果是负数,头部全部补1

右移运算符($\color{#ea4335}{>>}$)基本上相当于除以$\color{#ea4335}{2}$的指定次方(最高位符号位参与移动)

## 8.头部补0的右移运算符

头部补0的右移运算符($\color{#ea4335}{>>>}$)与右移运算符($\color{#ea4335}{>>}$)只有一个差别:

  一个数的二进制形式向右移动时,头部一律补0,而不考虑符号位.所以,该运算总是得到正值

这个运算实际上是将一个值转为32位无符号整数

查看一个负整数在计算机内部的储存形式,最快的方法就是使用这个运算符

```js
-1 >>> 0 // 4294967295
```

## 9.开关作用

$\color{#fbbc05}{待研究_开关作用}$
