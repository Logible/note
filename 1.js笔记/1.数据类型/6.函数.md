# 函数

## 1.概述

### 1.1 函数的声明

1. function命令

    $\color{#ea4435}{function}$命令声明的代码区块,就是一个函数$\color{#ea4435}{function}$命令后面是函数名,函数名是一对圆括号,里面是传入函数的参数. 函数体放在大括号的里面

    ```JavaScript
    function print(s) {
    console.log(s);
    }
    ```

2. 函数表达式

    声明函数还可使用变量赋值的写法

    ```JavaScript
    var print = function(s) {
    console.log(s);
    };
    ```

    采用函数表达式声明函数时,$\color{#ea4335}{function}}$命令后面不带有函数名

    如果加上函数名,该函数名只在$\color{#ea4335}{函数体内部}$有效

    ```JavaScript
    var print = function x(){
    console.log(typeof x);
    };
    
    x()
    // ReferenceError: x is not defined
    
    print()
    // function
    ```

    此写法的用处有两个

    - 在函数体内部调用本身(但调用所声明的变量作用也一致)
    - 方便出错
      - 除错工具显示函数调用栈时,将显示函数名,而不再显示这里是一个匿名函数
      - $\color{#B620E0}{此处存疑:如何显示函数调用栈}$

3. Function构造函数

    第三种声明函数的方式是Function构造函数

    ```JavaScript
    var add = new Function(
    'x',
    'y',
    'return x + y'
    );

    // 等同于
    function add(x, y) {
    return x + y;
    }
    ```

    除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。

    总的来说,此种声明函数的方式非常不直观,几乎无人使用

### 1.2函数的重复声明

如果同一个函数被多次声明,后面的声明就会覆盖前面的声明

```JavaScript
f() // 2

function f() {
    console.log(1);
}
f() // 2

function f() {
    console.log(2);
}
f() // 2
```

### 1.3 圆括号运算符,return语句和递归

### 1.4 第一等公民

JavaScript语言将函数看作一种值,与其它类型地位平等

属于原始类型中的广义的对象中的函数

```JavaScript
function add(x, y) {
  return x + y;
}

// 将函数赋值给一个变量
var operator = add;

// 将函数作为参数和返回值
function a(op){
  return op;
}
a(add)(1, 1)
// 2
```

### 1.5 函数名的提升

JavaScript将函数名视同变量名,所以采用$\color{#ea4335}{function}$命名声明函数时,$\color{#ea4335}{整个函数}$会像变量声明一样,被提升到代码头部

```JavaScript
f();

function f() {
    console.log("shit")
}
```

但若采用赋值语句定义函数,JavaScript就会报错

```JavaScript
f();

var f = function() {
    console.log("shit")
}
//Uncaught TypeError: f is not a function
```

上面代码等同下面的形式

```JavaScript
var f;
f();
f = function () {};
```

👆调用$\color{#ea4335}{f}$的时候,$\color{#ea4335}{f}$只是被声明了,还没有被赋值,等于undefined,所以报错

注意:由于存在函数提升,采用$\color{#ea4335}{function}$命令和$\color{#ea4335}{var}$赋值语句声明同一个函数,最后会采用$\color{#ea4335}{var}$赋值语句的定义

```JavaScript
var f = function () {
    console.log('1');
}

function f() {
    console.log('2');
}

f()//1

//相当于
var f;
f = function () {};

var f = function () {
    console.log('1');
}

f()//1
```

## 2.函数的属性和方法

### 2.1 name属性

函数的$\color{#ea4335}{name}$属性返回函数的名字

如果通过变量赋值定义的函数,那么$\color{#ea4335}{name}$属性返回变量名

但上面这种情况只有在变量是一个匿名函数时才如此,如果变量的值是一个具名函数,那么$\color{#ea4335}{name}$属性返回$\color{#ea4335}{function}$关键字之后的那个函数名

```JavaScript
var f2 = function () {};
f2.name // "f2"

var f3 = function myName() {};
f3.name // 'myName'
```

### 2.2 length属性

函数的$\color{#ea4335}{length}$属性返回函数预期传入的参数个数,即函数定义之中的参数个数

```JavaScript
function f(a, b) {}
f.length // 2
```

$\color{#ea4335}{length}$属性提供一种机制,判断定义时和调用时参数的差异,以便实现面向对象编程的overload

### 2.3 toString()

函数的$\color{#ea4335}{toString}$方法返回一个字符串,内容是函数的源码(包括注释)

对于原生的函数,$\color{#ea4335}{toString}$方法返回了$\color{#ea4335}{function(){[native code]}}$

```JavaScript
function f() {
  a();
  b();
  c();
}

f.toString()
// function f() {
//  a();
//  b();
//  c();
// }

Math.sqrt.toString()
//"function sqrt() { [native code] }"
```

$\color{#fbbc05}{曲线救国:}$

利用这一点,可以变相实现多行字符串

```JavaScript
var multiline = function (fn) {
  var arr = fn.toString().split('\n');
  return arr.slice(1, arr.length - 1).join('\n');
};

function f() {/*
  这是一个
  多行注释
*/}

multiline(f);
// " 这是一个
//   多行注释"
```

函数f内部有一个多行注释，toString()方法拿到f的源码后，去掉首尾两行，就得到了一个多行字符串。

## 3.函数作用域

### 3.1 定义

作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：

- 一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；
- 另一种是函数作用域

对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。

### 3.2 函数内部的变量提升

var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。

### 3.3 函数本身的作用域

函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。

## 4.参数

### 4.1 概述

函数运行的时候,有时候需要提供外部数据,不同的外部数据会得到不同的结果，这种外部数据就叫参数。

### 4.2 参数的省略

函数参数不是必须的,JavaScript允许省略参数

```JavaScript
function f(a, b) {
  return a;
}

f(1, 2, 3) // 1
f(1) // 1
f() // undefined

f.length // 2
```

上述代码函数$\color{#fbbc05}{f}$定义了两个参数,但是运行时无论提供多少个参数(或不提供参数). 省略的参数的值就变为$\color{#fbbc05}{undefined}$

如果要省略靠前的参数，只有显式传入undefined

```JavaScript
function f(a, b) {
  return a;
}

f( , 1) // SyntaxError: Unexpected token ,(…)
f(undefined, 1) // undefined
```

### 4.3 传递方式

- 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。
- 如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）

$\color{#fbbc05}{Tips:}$

如果函数内部修改的不是对象的某个属性,而是替换掉整个参数,这时不会影响到原始值

```JavaScript
var obj = [1, 2, 3];

function f(o) {
  o = [2, 3, 4];
}
f(obj);

obj // [1, 2, 3]
```

这是因为,形式参数(o)的值实际是参数$\color{#fbbc05}{obj}$的地址,重新对$\color{#fbbc05}{o}$赋值导致$\color{#fbbc05}{o}$指向另一个地址,保存在原地址上的值便不受影响

### 4.4 同名参数

如果有同名的参数,则取最后出现的那个值

```JavaScript
function f(a, a) {
  console.log(a);
}

f(1, 2) // 2
```

## 4.5 arguments对象

1. 定义

    由于JavaScript允许函数有不定数目的参数,所以需要一种机制,可以在函数体内部读取所有参数,这就是$\color{#fbbc05}{arguments}$

    $\color{#fbbc05}{arguments}$对象包含了函数运行时的所有参数,$\color{#fbbc05}{arguments[0]}$就是第一个参数,$\color{#fbbc05}{arguments[1]}$就是第二个参数,依次类推

    这个对象只有在函数体内部才能使用

    ```JavaScript
    var f = function (one) {
    console.log(arguments[0]);
    console.log(arguments[1]);
    console.log(arguments[2]);
    }

    f(1, 2, 3)
    // 1
    // 2
    // 3
    ```

    正常模式下，arguments对象可以在运行时修改。

    ```javaScript
    var f = function(a, b) {
    arguments[0] = 3;
    arguments[1] = 2;
    return a + b;
    }

    f(1, 1) // 5
    ```

    严格模式下,$\color{#fbbc05}{arguments}$对象与函数不具有联动关系

    ```JavaScript
    var f = function (a, b) {
        'use strict'; // 开启严格模式
        arguments[0] = 3;
        arguments[1] = 2;
        return a + b;
    }

    console.log("20210903:",f(1, 1))//2
    ```

    通过$\color{#fbbc05}{arguments}$对象的$\color{#fbbc05}{length}$属性,可以判断函数调用时到底带几个参数

    ```JavaScript
    function f() {
        return arguments.length;
    }


    console.log("20210903:", f(1, 2 , 3))//3
    console.log("20210903:", f(1))//1
    console.log("20210903:", f())//0
    ```

2. 与数组的关系

    $\color{#fbbc05}{arguments}$实际上是一个对象,数组专有的方法(比如$\color{#fbbc05}{slice}$和$\color{#fbbc05}{forEach}$,不能在$\color{#fbbc05}{argument}$对象上直接使用,如果要让arguments对象使用数组方法,真正的解决方法是将$\color{#fbbc05}{arguments}$转为真正的数组

    ```JavaScript
    var args = Array.prototype.slice.call(arguments);

    // 或者
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
    args.push(arguments[i]);
    }
    ```

    $\color{#B620E0}{存疑:call函数的使用}$

3. callee属性

$\color{#ea4335}{arguments}$对象带有一个$\color{#ea4335}{callee}$属性,返回它所对应的原函数

```JavaScript
var count = 1
var f = function () {
    while(count<10){
        count++;
        console.log("shit",count)
        arguments.callee()
    }
}

f() // true
```

可以通过$\color{#ea4335}{arguments.callee}$达到调用自身函数的目的. 这个属性在严格模式是禁用的,因此$\color{#ea4335}{不建议使用}$
