# 进程管理

- [进程管理](#进程管理)
  - [1. 进程与线程](#1-进程与线程)
    - [1.1 为什么进程与线程可以让计算机同时执行多个任务](#11-为什么进程与线程可以让计算机同时执行多个任务)
    - [为什么多线程程序中一个线程崩溃，整个程序就崩溃了；多进程程序一个进程崩溃，不会影响其他进程](#为什么多线程程序中一个线程崩溃整个程序就崩溃了多进程程序一个进程崩溃不会影响其他进程)
  - [2. 简述进程和程序的区别](#2-简述进程和程序的区别)
  - [3.进程通信方式⭐](#3进程通信方式)
  - [5.进程的调度算法](#5进程的调度算法)
    - [5.1 系统吞吐量](#51-系统吞吐量)
    - [5.2 饥饿](#52-饥饿)
    - [5.3 抢占式](#53-抢占式)
  - [6.进程同步和互斥](#6进程同步和互斥)
    - [6.1 信号量 信号 条件变量](#61-信号量-信号-条件变量)
    - [6.2 二元信号量和互斥锁](#62-二元信号量和互斥锁)
    - [6.3 什么是原子操作, 计数信号量](#63-什么是原子操作-计数信号量)
  - [7. 死锁](#7-死锁)
  - [8. 银行家算法](#8-银行家算法)
    - [安全序列、不安全状态、死锁的联系](#安全序列不安全状态死锁的联系)
  - [9. 死锁定理](#9-死锁定理)
  - [10.为何用户级线程执行系统调用指令时将导致其所属进程被中断；而内核级线程只导致该线程被中断](#10为何用户级线程执行系统调用指令时将导致其所属进程被中断而内核级线程只导致该线程被中断)

## 1. 进程与线程

进程和线程是操作系统中的两个核心概念，它们都代表着计算机中正在执行的代码。它们的主要区别在于

- 进程是💚**一个执行中的程序的实例**，它包括了程序代码、数据和进程控制块
- **线程是进程内的一条执行路径**，它共享进程的代码、数据和资源。

### 1.1 为什么进程与线程可以让计算机同时执行多个任务

进程和线程都是操作系统中用于实现多任务的机制。

- 在单核处理器系统中，进程和线程实现多任务的原理是**时间片轮转**。操作系统分配给每个进程或线程一个时间片，每个进程或线程只能在分配的时间片内执行任务。当时间片用完时，操作系统会挂起该进程或线程，切换到另一个进程或线程继续执行。由于时间片非常短，因此对于用户来说，多个任务似乎是同时在运行的。
- 在多核处理器系统中，进程和线程可以在不同的CPU核心上并行执行，从而实现真正的并行计算。

### 为什么多线程程序中一个线程崩溃，整个程序就崩溃了；多进程程序一个进程崩溃，不会影响其他进程

- 在多线程程序中，所有线程共享同一个地址空间和资源，因此当一个线程崩溃时，可能会导致**共享的数据结构或资源损坏或者出现其他问题**，从而导致整个程序崩溃。此外，由于多线程程序中存在**多个线程共享同一个堆栈**，当一个线程崩溃时，可能会破坏整个堆栈，导致程序崩溃。
- 相比之下，在多进程程序中，每个进程都有自己**独立的地址空间和资源**，因此当一个进程崩溃时，只会影响该进程本身，不会影响其他进程。此外，每个进程都有自己独立的堆栈，因此一个进程的崩溃不会影响其他进程的堆栈。

## 2. 简述进程和程序的区别

- 程序是**一组指令和数据的有序集合**，是指已经编写好的可执行文件或代码。程序可以被多个进程共享，当进程需要执行某个程序时，会将程序加载到内存中，并创建相应的进程来运行程序。
- 进程是**一个正在执行的程序的实例**，它是系统资源分配的基本单位。进程由程序段、数据段和进程控制块（PCB）组成，进程控制块包含了进程的各种信息，如进程状态、程序计数器、寄存器等。一个程序可以对应多个进程，每个进程都拥有独立的内存空间、CPU时间片和其他系统资源，它们之间相互独立，互不干扰。

## 3.进程通信方式⭐

- 进程通信是指在多道程序环境下，不同进程之间进行**数据交换和共享资源**的一种机制，用于实现协作完成任务

- 共享内存
  - ![20230318113926](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230318113926.png)
- 管道
  - ![20230318114206](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230318114206.png)
  - 无名管道（半双工，只允许有亲缘关系的进程间，不存在磁盘结点，自存在内存，用完即毁）
  - 命名管道（半双工，存在磁盘结点）
- 消息队列
  - ![20230318114411](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230318114411.png)
- 套接字
- 信号

对下列进程通信方式进行解释并举例

- 共享内存
- 无名管道（半双工，只允许有亲缘关系的进程间，不存在磁盘结点，自存在内存，用完即毁）
- 命名管道（半双工，存在磁盘结点）
- 消息队列
- 套接字
- 信号

## 5.进程的调度算法

- 先来先服务调度算法（First-Come, First-Served Scheduling，FCFS）：按照进程**到达的先后顺序**进行调度，先到达的进程先执行，直到执行完毕或者被阻塞。
  - 非抢占式，开销小，无饥饿，但是对短进程不利。
- 最短作业优先调度算法（Shortest Job First Scheduling，SJF）：按照**进程的执行时间来进行排序**，执行时间短的进程先执行。
  - 非抢占式，开销大，会饥饿，但是对长进程不利。
- 优先级调度算法（Priority Scheduling）：为**每个进程赋予一个优先级**，优先级高的进程先执行。长时间没有被调度的进程可以提高优先级，避免饥饿问题。
- 时间片轮转调度算法（Round Robin Scheduling，RR）：按照**到达的先后顺序**排列，每个进程被**分配一个时间片**，当时间片用完后，该进程被放回队列的末尾，等待下一次调度。
  - 抢占式，开销小，无饥饿。
- 最高响应比调度算法（Highest Response Ratio Next Scheduling，HRRN）：根据等待时间和服务时间的比值来选择下一个进程，**等待时间越长、服务时间越短**的进程优先级越高。
  - 非抢占式，开销大，无饥饿。
- 多级反馈队列调度算法（Multilevel Feedback Queue Scheduling）：将进程按照**不同的优先级划分到不同的队列中**，每个队列有**不同的时间片大小**。进程在一个队列中运行一段时间后，如果还没有执行完毕，就会被移到下一个队列中。优先级递减，时间片递增
  - 会饥饿，但是对 IO 型进程有利。

### 5.1 系统吞吐量

- 系统吞吐量（Throughput）是指在**一段时间内**，系统能够处理的**任务数量或数据量**。通常以每秒钟处理的任务数或数据量为单位来衡量。

### 5.2 饥饿

- 是指一个进程由于得不到调度而**一直**处于**等待**状态，**无法执行**的情况

### 5.3 抢占式

- 在调度算法中，抢占式指当一个进程正在执行时，如果有更高优先级的进程进入就绪队列，那么系统会暂停正在执行的进程，**切换到更高优先级的进程去执行**。这种方式能够更加及时地响应紧急任务，提高系统的效率，但也增加了调度的开销和复杂度。
- 相对应的，非抢占式调度算法**不会在执行进程中间强制切换**，而是等待当前进程执行完毕后再进行调度。

## 6.进程同步和互斥

阐述什么是进程同步和互斥, 并解释下列概念

- 互斥量
- 信号量
- 事件  
  - 事件：是一种可以被多个进程等待的对象，当某个进程发生特定事件时，它可以通过事件通知其他进程进行同步。常见的事件有信号和条件变量。
  - 可以进行更加详细的解释吗
- 临界区

同步机制的 4 个准则

- 空闲让进
- 忙着等待
- 有限等待
- 让权等待

---

- 进程互斥
  - 多个进程同时访问💚**某一共享资源**时，必须采用某种方法来确保**同时只有一个**进程访问该资源，以避免发生冲突和数据不一致的情况。
- 进程同步
  - 多个进程之间需要💚**协调执行**，使得它们的**执行顺序、执行方式和执行结果**符合预期。

- 互斥量：采用加锁的方式来控制对共享资源的访问。
  - 只有获取到💚**锁的进程才能访问共享资源**，其他进程必须等待锁的释放。
  - 常用的互斥量有二元信号量和互斥锁。
- 信号量：是一种💚**记录某一资源使用状态**的数据结构，通过原子操作来实现对资源的控制，避免**多个进程同时访问共享资源**。
  - 常用的信号量包括**二元信号量和计数信号量**
- 事件：是💚**一种可以被多个进程等待的对象**，当某个进程发生特定事件时，它可以通过事件**通知其他进程进行同步**。常见的事件有**信号和条件变量**。
- 临界区：指的是一段代码，当进程执行该代码时，必须**互斥访问共享资源**，以保证数据的一致性和正确性。

- 同步机制的四个准则包括：

1. 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程**立即进入临界区**。
2. 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程**必须等待**。
3. 有限等待：对请求访问的进程，应保证能在**有限时间内**进入临界区。
4. 让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程**忙等待**。

举一个例子来形容这四个原则：当我们去餐厅吃饭时，餐厅里的座位就相当于临界区，我们每一个人相当于访问临界区的代码，当餐厅有空桌时，我们可以进入，也就是空闲让进。当餐厅没有空桌时，我们必须等待，也就是忙则等待。当没有空桌的时候服务员会给我们一个号码，让我们在一边等着，而不是时刻去问服务员有没有空桌，这就是让权等待。每次发号码的时候服务员都会估计一下排队时间，确保每一个排队的人都能在有限的时间内吃到饭（假设24小时营业），这个也就是有限等待。

### 6.1 信号量 信号 条件变量

- 信号量（Semaphore）是一种**进程间同步机制**，用于控制对共享资源的访问。它是一个计数器，表示可用的资源数量，进程可以通过特定的操作对其进行加/减，从而实现对共享资源的访问控制。
- 信号
  - 是一种异步通知机制，用于进程间通信。当一个进程需要通知另一个进程发生了某个事件时，它可以**向另一个进程发送一个信号**。接收信号的进程可以选择忽略信号，或者注册一个信号处理函数来处理信号。
- 条件变量（Condition Variable）
  - 是一种线程同步机制，用于在线程之间实现某些事件发生的通知和等待。它通常与互斥锁（Mutex）一起使用，以避免线程竞争并保持线程安全。
  - 条件变量可以让💚**一个或多个线程等待另一个线程的操作**，等待的线程**可以被唤醒以执行某个特定的操作**

### 6.2 二元信号量和互斥锁

- 二元信号量是一种**特殊的信号量**，只能取两个值：**0 和 1**。
  - 在实现进程同步时，二元信号量通常用于表示某个共享资源是否被占用
    - 即当信号量的值为 **0 时表示资源被占用**
    - 当值为 **1 时表示资源空闲**。

- 互斥锁也是用于实现进程同步的一种机制，其主要作用是确保只有一个进程能够进入临界区访问共享资源。
  - 当一个进程**获取到互斥锁**时，**其他进程将被阻塞**
  - 只有当该进程**释放锁**后，其他进程才能竞争获取锁进入临界区。

### 6.3 什么是原子操作, 计数信号量

- 原子操作是一种在多线程/进程并发执行时，保证操作**不会被中断或者干扰的操作方式**。
  - 原子操作可以在单个指令周期内完成，因此不会被其他线程/进程打断。原子操作通常是由硬件提供支持的，可以用于保证并发执行的正确性。

- 计数信号量是一种用于进程间通信和同步的机制。它是一个**整数变量**，可以被多个进程同时访问和修改。
  - 计数信号量的主要操作包括 wait 和 signal 操作。
    - 当进程需要访问临界区时，它会执行 **wait 操作来检查信号量的值是否大于 0**，如果是，进程就可以进入临界区，否则就必须等待。
    - 进程离开临界区时，会执行 **signal 操作来增加信号量的值**，以允许其他等待访问临界区的进程进入。

## 7. 死锁

多个进程因为资源争抢而发生了循环等待，造成了死锁。

将下列内容进行系统阐述, 最好举生活中的例子

- 死锁发生的主要原因：
  - 计算机系统资源不足
  - 进程推进顺序不当

- 死锁发生的必要条件：
  - 互斥访问
  - 不剥夺
  - 请求和保持
  - 循环等待

---

- 死锁是指两个或多个进程因为**互相持有对方所需的资源而无法继续执行**的情况，从而导致系统进入一种僵局状态，这种状态下进程无法前进或后退，只能等待其他进程释放资源。

- **死锁发生的主要原因**
  - **计算机系统资源不足**
    - 对系统资源的竞争。各进程对**不可剥夺的资源**（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的。
  - 如果进程在**竞争资源时的执行顺序不当**，也容易引起死锁。例如，
    - 两个进程同时需要获取 A 和 B 两个资源，如果它们的竞争顺序不一致，那么就可能会发生死锁。假设进程 P1 先请求 A 资源，进程 P2 先请求 B 资源，然后 P1 请求 B 资源，P2 请求 A 资源，如果它们同时持有自己的第一个资源，就会发生死锁。

- **死锁发生的必要条件**
  - 互斥访问
    - 当进程使用一个资源时，其他进程不能访问该资源。
  - 不剥夺
    - 当一个进程持有一个资源时，其他进程不能夺取该资源，只有该进程自己释放该资源，其他进程才能获得该资源。
  - 请求和保持
    - 当一个进程持有一个资源并请求其他资源时，该进程将会**一直等待直到获得所需的所有资源**。这就是请求和保持。如果多个进程都持有自己所需的一些资源并请求其他进程持有的资源，就可能会发生死锁。
  - 循环等待（Circular Wait）
    - 是指进程间因为相互**等待对方释放资源而形成一个环路**，即进程集合 {P0, P1, P2, ..., Pn} 中的 P0 等待 P1 占用的资源，P1 等待 P2 占用的资源，……，Pn-1 等待 Pn 占用的资源，Pn 又等待 P0 占用的资源。

## 8. 银行家算法

### 安全序列、不安全状态、死锁的联系

![20230318210621](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230318210621.png)

## 9. 死锁定理

![死锁定理](https://img2020.cnblogs.com/blog/1774310/202108/1774310-20210805230745422-14628352.png)

死锁定理:资源有向图可以完全简化，也就是所有的边都可以消除，那么就不存在死锁

## 10.为何用户级线程执行系统调用指令时将导致其所属进程被中断；而内核级线程只导致该线程被中断

- 用户级线程是由用户空间的线程库来管理的，而内核级线程是由操作系统内核来管理的。
- 当用户级线程执行系统调用时，它需要**向内核发出系统调用请求**，此时内核会将该线程阻塞，并在内核空间中执行相应的操作，这就导致了该线程所属的整个进程被中断。**因为内核会以进程为单位进行调度(进程是资源的分配和调度单位)**，当一个线程被阻塞时，整个进程就会被阻塞。
- 而内核级线程是由**操作系统内核来管理的，内核可以独立地管理每个线程的状态和调度**。当一个内核级线程执行系统调用时，内核只会将该线程阻塞，而不会影响到整个进程的其他线程，因为内核可以独立地调度每个线程。所以内核级线程执行系统调用时只会导致该线程被中断，而不会影响整个进程。
