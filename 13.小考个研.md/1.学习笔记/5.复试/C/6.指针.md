# 指针

- [指针](#指针)
  - [6.2 指针变量的定义与引用](#62-指针变量的定义与引用)
    - [6.2.1 指针变量的定义](#621-指针变量的定义)
    - [6.2.2指针变量的引用](#622指针变量的引用)
  - [6.3指针运算符与指针表达式](#63指针运算符与指针表达式)
    - [6.3.1 与指针运算相关的运算符与表达式](#631-与指针运算相关的运算符与表达式)
    - [6.3.2 指针变量作函数的参数](#632-指针变量作函数的参数)
  - [6.4.1 指针与一维数组](#641-指针与一维数组)
  - [6.4.2 指针与二维数组](#642-指针与二维数组)
    - [1.二维数组的地址类型](#1二维数组的地址类型)
    - [2.通过二维数组的行指针和列指针访问数组元素](#2通过二维数组的行指针和列指针访问数组元素)
    - [6.4.3 数组指针作函数的参数](#643-数组指针作函数的参数)
    - [6.4.4 指针与字符数组](#644-指针与字符数组)
  - [6.5 指针数组](#65-指针数组)
  - [6.6 指针的地址分配](#66-指针的地址分配)
  - [6.7 指向指针的指针](#67-指向指针的指针)
  - [6.8 指向函数的指针变量(定义时用双括号)](#68-指向函数的指针变量定义时用双括号)
  - [6.9 main函数的参数](#69-main函数的参数)
  - [本章小结](#本章小结)
  - [习题](#习题)
    - [选择](#选择)
    - [填空题](#填空题)
    - [结果题](#结果题)
    - [补空题](#补空题)

## 6.2 指针变量的定义与引用

### 6.2.1 指针变量的定义

```c
int * pl;
float * p2;
char * p3;
```

- 指针的基本含义
  - 就是数据在**内存中的地址**
    - 地址本身是一个**无符号整数**
    - 但在定义中却使用了3种基本数据类型的声明，表明它们分别存储**不同类型变量的地址**
- 变量名直接引用数值，而指针间接引用数值
  - 指针引用数值称为**间接引用**。

- 星号
  - 其含义是指定相应的变量名为指针类型
    - 这个星号隶属于变量名
    - 而不是类型名

### 6.2.2指针变量的引用

- 引用指针变量，C语言提供了对变量的一种**间接访问形式**。对指针变量的引用形式为：```*p```
  - 变量其含义是取出指针变量所指向内存单元中的值

```c
int a = 1;
int *p = &a;
cout<<"p: "<<p<<endl;   //p: 0x6ffe04
cout<<"*p: "<<*p<<endl; //*p: 1
```

- NULL的指针不指向任何数据，也称为空指针(null pointer)。符号常量NULL在头文件<stdio.h>中定义，表示数值0
  - 把一个指针初始化为NULL和0是等价的。

```c
double *p2 = 0; /*p2指针变量不指向任何浮点*/
int *p3 = NULL; /*p3指针变量不指向任何整型数*/
```

- Tips:
  - 尽可能使用**初始化操作来初始化指针变量**，以防止其指向一个未知的或未被初始化的内存空间

## 6.3指针运算符与指针表达式

### 6.3.1 与指针运算相关的运算符与表达式

- ```&```运算符：取址运算符
  - 例如，&m即是变量m的地址
- ```*```运算符：间接访问运算符
  - 例如，*p表示p所指向的变量的值

### 6.3.2 指针变量作函数的参数

- 在swap函数中的p1和p2具有了pa和pb的值
  - 当然也就指向了指针变量pa和pb所指向的内存变量
- 在函数体中，利用p1和p2指针变量的间接访问方式
  - 对其在内存存储的数据进行了交换

```c
void swap(int *p1,int *p2) {
    int t = *p1;
    *p1 = *p2;
    *p2 = t;
}

//交换p1,p2, 而p1,p2只是pa,pb副本, 故无变化
void swap2(int *p1,int *p2) {
    int *t;
    t = p1;
    p1 = p2;
    p2 = t;
}
```

## 6.4.1 指针与一维数组

- 数组a是a[n]的首地址, 是用一个变量存储的吗?
  - 在C语言中，数组名本身并不是一个变量，因为它**代表的是一个固定大小的内存块，而且它的值是一个常量**，不能被修改。也就是说，我们不能直接修改数组名a的值，以指向其他内存地址。

```c
int a[10];
int *p = a;
//p指向了一维数组，则
```

1. **p+i与a+i**表示数组元素a[i]的地址，即&a[i];
2. 间接访问*(p+i)和*(a+i)就表示为数组的各元素即等效于a[i]。
3. 指向数组的指针变量也可用数组的下标形式表示为p[i]
   1. 其效果相当于*(p+i)

```c
int a[10];
int *p = a;
for(int i = 0 ; i < 10 ; i++){
    scanf("%d",p++)//p为指针
}
p = a;
for(int i = 0 ; i < 10 ; i++){
    cout<<*p++;
}
```

## 6.4.2 指针与二维数组

### 1.二维数组的地址类型

```c
&a[i][j] == a[i] + j == *(a+i)+j
a[i][j] == *(a[i] + j) == *(*(a+i)+j)
```

### 2.通过二维数组的行指针和列指针访问数组元素

- 行指针的定义指针的定义形式如下：

数组的数据类型 *指针变量名[m];

```c
float a[N][M]= {{65,67,79,60},{80,87,90,81},{90,99,100,98}};
float(*p)[M];//行指针的定义
p = a;
int k = 1;
//此处书本存在错误
while(k>=1&&k<=3){
    cin>>k;
    k--;
    for(int i = 0; i < M; i++)
        cout<<*(*(p+k)+i)<<" ";
}
```

- 列指针指向所指向的数据类型为**二维数组的元素类型**
  - 利用指针变量访问二维数组，可以把二维数组看作展开的一维数组进行访问。

```c
int a[N][M];
int  *p = *a;// or a[0], &a[0][0]
for(int i = 0 ; i < N ; i++)
    for(int j = 0 ; j < M ; j++)
        scanf("%d",p++);
p = a[0];
for(int i = 0 ; i < N ; i++)
    for(int j = 0 ; j < M ; j++)
        cout<<*p++;
```

### 6.4.3 数组指针作函数的参数

```c
float a[M][N];
float (*ptr)[N];//N表示每行有多少个元素
ptr = a;
...
if(score[i] > ave)
    tprint(ptr+i)

void tprint(float (*pt)[N]){
    for(...)
        printf("%lf",*(*pt+j))
}
// pt=&a[i], *pt=a[i],
// *pt+j=&a[i][j], *(*pt+j) = a[i][j]
```

### 6.4.4 指针与字符数组

- 字符串是字符数组的一种特殊形式，存储时以'\0'结束
  - 所以，存储字符串的**字符数组**其长度应比**字符串多1**

```c
char str[3], *p = str;
scanf("%s",p);
printf("%s",*p); //输入字符大于3, 无法正确输出
```

- **字符数组**和**字符(串)指针**都能够实现对字符串的操作，但它们是有区别的。

1. 存储上的区别：
   1. 字符数组由若干元素组成，每个元素存储一个字符。
   2. 字符指针存储的是地址(字符数组的首地址),不是将整个字符串存储到字符指针变量中。

2. 赋值上的区别：
   1. 对字符数组只能对各个元素赋值，不能将一个常量字符串赋值给字符数组(字符数组初始化例外)
   2. 可以将一个常量字符串赋值给字符指针，但含义仅仅是将常量串首地址赋值给字符指针。例如，

    ```c
    //非法的赋值：
    char str[100];
    str = "I am a student.";

    //合法的赋值：
    char *pstr; pstr = "I am a student.";
    cout<<pstr<<endl; //I am a student.
    cout<<*pstr;      //I
    ```

3. 定义上的区别：
   1. 定义数组后，编译系统分配具体的内存单元(一片连续内存空间),各个单元有确切的地址。
   2. 定义一个指针变量，编译系统只分配一个2字节或更多字节存储单元，以存储地址值。也就是说字符指针变量可以指向一个字符型数据(字符变量或字符数组),但是在对它赋以具体地址前，它的值是随机的(不知道它指向的是什么)。所以**字符指针必须初始化才能使用**。例如：

    ```C
    //合法的定义：
    char s[10]; gets(s);
    //非法的定义：
    char *ps; get(ps); /*指针没有一个确切的指向*/
    ```

4. 运算上的区别：指针变量的值允许改变(++、--、赋值等),而字符数组的数组名是常量地址，不允许改变，如s++,就是错误的。

    ```c
    char str[]="log", *p = str;
    cout<<str++;//[Error] lvalue required as increment operand
    ```

## 6.5 指针数组

- 由于运算符[ ]的优先级比运算符\*高，所以先是数组形式str[4],然后才是与"*"的结合，

  ```c
  char *str[4];
  ```

- 而行指针 说明指针变量ptr只能指向一个长度为4的数组，如：

  ```c
  int a[3][4], b[3][3];
  int(*ptr)[4];
  ptr = a[0]; //合法
  ptr = b[0]; //非法，数组b的行指针是一个长度为3的一维数组
  ```

## 6.6 指针的地址分配

```C
char * p1;
p1 = (char *)malloc(30);
free(p1);
```

- 动态为指针变量分配长度为30字节的存储空间
- malloc()函数的返回值是一个**void类型**的指针，所以在调用时需要将返回值的类型强制转换成所需要的类型

## 6.7 指向指针的指针

```c
int i;
char c[][30]= {"CProgram","Data Structure",
                "Operating System","DataBase System"
              };
  
char *cp[] = {c[0],c[1],c[2],c[3]};/*指针数组*/
char ** cpp;      /*指向字符指针的指针变量*/
cpp = cp;         /*将指针数组的首地址传递给指向字符指针的指针变量 等同于cpp=&c[0]*/

for(i = 0; i < 4; i++)
  printf("%s\n",*cpp++);
  
cout<<"-------"<<endl;

for(i=0; i<4; i++) {
  cpp = &cp[i];
  printf("%s\n",*cpp);
}
```

## 6.8 指向函数的指针变量(定义时用双括号)

1. 函数的指针也称为函数的**入口地址**(函数的首地址)
2. C语言规定函数的首地址就是**函数名**，所以函数名就是函数的指针
3. 指向函数的指针变量就是**保存函数入口地址**(函数指针)的变量
   1. 称这种变量为**指向函数的指针变量**，简称函数的指针变量

```c
//int表示被指向的函数的类型，即被指向的函数的返回值的类型
int(*P)(parasType...);
int(*P)(int,int) = max;
//调用
(*p)(x,y);
```

- example

```c
/*函数参数为一个函数指针*/
int process(int x,int y,int(*f)(int,int)) {
  return (*f)(x,y);
}

int max(int a,int b){
  cout<<a<<b<<"shit";
}

int main() {
  int a = 1;
  int b = 2;
  process(a,b,max);
}
```

## 6.9 main函数的参数

![20230331125719](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230331125719.png)

- 当一个用C编写的程序被装入内存准备执行时，main的两个参数被自动给定初值：
  - argc的值是启动命令行中的**命令行参数的个数**；
  - 指针argv指向一个**字符指针数组**
    - 这个数组里共有argc+1个字符指针
      - 其中的前argc个指针分别指向表示各命令行参数的字符串
      - 最后是一个空指针，表示数组结束。

```c
int main(int argc,char *argv[]){
  int i;
  for(i = 0;i < argc; i++){
    printf("Args[%d]:%s\n",i,argv[i]);
  }
  return 0;
}
```

## 本章小结

![20230314144151](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230314144151.png)

## 习题

### 选择

⭐⭐

- 16![20230314154056](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230314154056.png)
  - 💚当只有程序文件名时，argc的值为1。
  - 形参只能从命令行得到
- 07字符串赋值![20230314152802](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230314152802.png)
  - 💚B非字符串

⭐

- 06![20230314152617](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230314152617.png)
- 09![20230314152921](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230314152921.png)
  - 可能超过127
- 10![20230314153233](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230314153233.png)
  - 指针存的是地址
- 12![20230314153406](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230314153406.png)
  - 常量不能进行自增/减
- 14![20230314153754](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230314153754.png)
  - 指针变量+连续存储区域, 才可以自增

### 填空题

⭐

- 01![20230315122550](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230315122550.png)
  - 💚变量地址和常量
- 02![20230315122631](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230315122631.png)
  - 💚地址常量

### 结果题

⭐

- 04错误![20230315142821](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230315142821.png)
- 04![20230315143620](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230315143620.png)

### 补空题

⭐⭐

- 01整数字符串转换为一个整数![20230315151827](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230315151827.png)
  - 字符转数字
  - 在C语言中，数字字符（'0' ~ '9'）的ASCII码值是连续的，也就是说，'0'的ASCII码值比'1'小1，'1'的ASCII码值比'2'小1，以此类推。因此，当我们将一个数字字符减去'0'时，实际上是将该字符的ASCII码值减去'0'的ASCII码值，从而得到该数字的值。
  - 例如，字符'3'的ASCII码值为51，而字符'0'的ASCII码值为48。当我们执行'3' - '0'时，实际上是将字符'3'的ASCII码值51减去字符'0'的ASCII码值48，得到数字3的值
- 03![20230315152416](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230315152416.png)
  - 💚是N%10
  - 💚转为数字字符要加'0'

⭐

- 02![20230315152024](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230315152024.png)
  - 从当前位置找
  - 字符串的下一个位置
  - 只能是k+1吧
- 04![20230315152402](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230315152402.png)
  - i++传的还是i
