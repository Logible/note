# 第7章预编译命令

- [第7章预编译命令](#第7章预编译命令)
  - [7.1 概述](#71-概述)
    - [7.1.1宏定义](#711宏定义)
    - [7.1.2 无参宏定义](#712-无参宏定义)
    - [7.1.3 带参宏定义](#713-带参宏定义)
  - [文件包含include](#文件包含include)
  - [习题](#习题)
  - [判断题](#判断题)

## 7.1 概述

- 预处理
  - 在进行编译前，对源程序预先**添加和替换**一些信息，以便编译程序能够正常工作

### 7.1.1宏定义

- C语言源程序中允许用一个**标识符**来表示一个**字符串**，称为“宏”(Macro)

### 7.1.2 无参宏定义

- 无参宏的宏名后不带参数。其定义的一般形式为：

```c
#define 宏名 宏定义串
```

- 在C中，以“#”开头的**均为**预处理命令。
  - “define”为宏定义命令
  - 宏名为标识符
  - 宏定义部分可以是常数、表达式、格式串等。

```c
#define M (y*y+3*y)
//...
s=3*M+4*M+5*M;
//宏展开后该语句变为：s=3*(y*y+3*y)+4*(y*y+3*y)+5*(y*y+3*y);
```

- example

```c
#define LONG_STRING "this is a very long\
string that is used as an example"

#define Print printf
#define Format "%-10s%8d%8.2f\n"

int main() {
  int a = 1308001, c = 1308002;
  float b = 621, d = 612;
  Print(Format,"Wangyi",a,b);
  Print(Format,"Liwei",c,d);
  return 0;
}
//Wangyi     1308001  621.00
//Liwei      1308002  612.00
```

### 7.1.3 带参宏定义

- C语言允许宏带有参数。对带参数的宏，在调用中，不仅要宏展开，还要代换参数。带参宏定义的一般形式为：

```c
#define 宏名(参数表) 宏定义串
```

```c
#define M(y) y*y+3*y /*宏定义*/

k=M(5);
//在宏调用时，用实参5去代替形参y,经预处理宏展开后的语句为：
/*等同于下列语句*/
k = 5*5+3*5
```

- 当定义串中带有括号时，替换时这些括号**原样出现在替换结果中**，即宏定义串中的括号不是运算符，**仅表示括号符号**

```c
#define SQ1(y) (y)*(y)
#define SQ3(y) ((y)*(y))

//a = 3
sq=160/SQ1(a+1); //160
sq=160/SQ3(a+1); //10
```

- 使用类函数宏代换实函数的一个主要优点是**提高了代码的速度**，因为**消除了调用开销**。然而，如果类函数宏的尺寸非常大，则由此带来的损失却是因复制代码而**增加了程序的规模**

- 复制代码而增加规模
  - 在使用类函数宏代替实函数时，**类函数宏代码会在每个调用处直接复制到程序中**，而不是像实函数一样在内存中只有一个副本。因此，如果类函数宏的代码很大，那么在程序中每次使用它时都会复制一遍宏代码，这会增加程序的尺寸。这意味着，使用大型类函数宏代替实函数可能会导致编译后的程序尺寸变大，甚至可能会降低程序的性能，因为增加的代码量可能会使得缓存失效或者增加分支预测的难度。
    - 复制一遍的宏代码不是存储在内存中的吗, 那是存储在那里
      - 程序区实际上也是存储在计算机的内存中，不同于数据区和堆栈区的是，程序区是存储**计算机程序代码**的区域。
      - 会被编译器替换为**宏展开后的代码，这些代码会被存储在程序的指令段**中，**并在程序运行时直接执行**。这意味着，宏定义函数的代码量越大，生成的目标代码也会越大，因为每个宏展开后的代码都会出现在程序中的多个位置。

- 这意味着宏代码并不会像实函数一样在内存中只有一个副本，而是在每个调用处都有一个副本
- 调用处指的是代码中使用宏的地方

## 文件包含include

- 文件包含是预处理的一个重要功能，它可以把多个源文件连接成一个源文件进行编译，结果将生成一个目标文件。

```c
#include "stdio.h"
#include <stdio.h>
```

- 使用尖括号
  - 表示在包含**文件目录**中去查找(包含目录是由用户在设置环境时设置的),而不在源文件目录去查找。
- 使用双引号
  - 表示首先在**当前的源文件目录**中查找，若未找到才到包含目录中去查找。用户编程时可根据自己文件所在的目录来选择某一种命令形式。
- 一般地，系统库文件使用尖括号；若要包含用户**自定义的文件，则使用双引号**。

## 习题

⭐

- 01![20230316202932](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316202932.png)
- 02![20230316204053](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316204053.png)
  - 参数没有数据类型
- 06![20230316204220](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316204220.png)
  - 宏定义本质是字符串
- 07![20230316204429](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316204429.png)
  - 拼接
- 09![20230316204830](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316204830.png)
  - 嵌套拼接
- 11![20230316205013](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316205013.png)
  - %运算符要求两边都是整数

## 判断题

⭐

- 04![20230316205713](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316205713.png)
- 03![20230316205542](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316205542.png)
  - 编译系统能对这些**函数调用**进行检查
  - 程序员自己也可编写
- 08![20230316210204](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316210204.png)
  - 两种包含命令皆可包括路径
- 06![20230316210027](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316210027.png)
  - 并不占用编译时间
  - 若是预编译
- 10![20230316210255](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230316210255.png)
  - 可生成不同版本
    - 使用 #include <文件名> 的形式可能会比 #include "文件名" 的形式更快，因为编译器可以直接在系统库路径中查找头文件，而不需要在当前目录中查找。
