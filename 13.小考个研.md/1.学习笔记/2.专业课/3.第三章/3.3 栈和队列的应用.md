# 3.3 栈和队列的应用

- [3.3 栈和队列的应用](#33-栈和队列的应用)
  - [3.3.1 栈在括号匹配中的应用](#331-栈在括号匹配中的应用)
  - [3.3.2 栈在表达式求值中的应用](#332-栈在表达式求值中的应用)
    - [3.3.2.1 后缀表达式的计算(手算)](#3321-后缀表达式的计算手算)
    - [3.3.2.2 后缀表达式的计算(机算) - 操作数入栈](#3322-后缀表达式的计算机算---操作数入栈)
    - [3.3.2.3 中缀转后缀/前缀(手算)](#3323-中缀转后缀前缀手算)
    - [3.3.2.4 中缀转后缀(机算*)- 运算符入栈](#3324-中缀转后缀机算--运算符入栈)
    - [中缀表达式的计算(机算)- 操作数和运算符都入栈](#中缀表达式的计算机算--操作数和运算符都入栈)
  - [3.3.3 栈在递归中的应用](#333-栈在递归中的应用)
  - [3.3.4 队列在层次遍历中的应用](#334-队列在层次遍历中的应用)
  - [3.3.5 队列在计算机系统中的应用](#335-队列在计算机系统中的应用)
  - [3.3.6 题](#336-题)

## 3.3.1 栈在括号匹配中的应用

![栈在括号匹配中的应用](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221022213438.png)

1. 算法的思想如下：
   1. 初始设置一个空栈，顺序读入括号。
   2. 若是左括号
      1. 则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性降了一级。
   3. 若是右括号，则
      1. 或者使置于栈顶的最急迫期待得以消解
      2. 或者是不合法的情况(括号序列不匹配，退出程序)
   4. 算法结束时，**栈为空**，否则括号序列不匹配。

## 3.3.2 栈在表达式求值中的应用

1. 前缀表达式
   1. 运算符在两个操作数前面

2. 中缀表达式
   1. 运算符在两个操作数中间

3. 后缀表达式
   1. 运算符在两个操作数后面

### 3.3.2.1 后缀表达式的计算(手算)

- 例子![20221022215549](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221022215549.png)

1. 后缀表达式的计算
   1. 从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数

注意:两个操作数的左右顺序

### 3.3.2.2 后缀表达式的计算(机算) - 操作数入栈

- 例子(机算)![例子(机算)](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221022220929.png)
- 例子2 答案5![20221022222249](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221022222249.png)
- 前缀表达式的计算(与后缀计算类似,但先出栈的是左操作数)![20221022223018](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221022223018.png)

1. 通过后缀表示式**计算表达式值**的过程:
   1. 顺序扫描表达式的每一项，然后根据它的类型做如下相应操作
      1. 若该项是操作数，则将其压入栈中;
      2. 若该项是操作符< op >,则连续从栈中退出两个操作数Y和X, 形成运算指令X< op >Y, 将计算结果重新压入栈中。
         1. Tips: 先出栈的是右操作数
   2. 当表达式的所有项都扫描并处理完后，栈顶存放的就是最后的计算结果

- 使用后缀表达式和前缀表达式的计算值的一些区别
  - 后缀表达式退出两个操作数Y和X, 形成运算指令X< op >Y
  - 前缀表达式退出两个操作数Y和X, 形成运算指令Y< op >X

### 3.3.2.3 中缀转后缀/前缀(手算)

- 中缀转后缀例子![20221022215448](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221022215448.png)

- 中缀转后缀的手算方法:

1. 确定中缀表达式中各个运算符的**运算顺序**
2. 选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组成一个**新的操作数**;
3. 如果还有运算符没被处理，就继续2

4. Tip:
   1. 运算顺序不唯一，因此对应的后缀表达式也不唯一
   2. "左优先"原则:只要左边的运算符能先计算，就**优先算左边**的, 可保证运算顺序唯一

- 中缀转前缀的手算方法(非重点):

- ![例子](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221022222855.png)

1. 确定中缀表达式中各个运算符的**运算顺序**
2. 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组成一个**新的操作数**;
3. 如果还有运算符没被处理，就继续2

4. Tip:
   1. 运算顺序不唯一，因此对应的后缀表达式也不唯一
   2. "右优先"原则:只要左边的运算符能先计算，就**优先算右边**的, 可保证运算顺序唯一

### 3.3.2.4 中缀转后缀(机算*)- 运算符入栈

初始化一个栈, 用于保存**暂时还不能确定顺序的运算符**;

从左向右开始扫描中缀表达式;

1. 遇到数字时，加入后缀表达式;
2. 遇到运算符时:
   1. 若为'(', 入栈;
   2. 若为')', 则依次把栈中的运算符加入后缀表达式，直到出现'(', 从栈中删除'(';
3. 若为除括号外的其他运算符
   1. 从栈顶开始依次弹出比当前处理的运算符**优先级高和优先级相等**的运算符，并加入后缀表达式, 直到一个**比它优先级低**的或遇到了**一个左括号**为止。
   2. 之后再把当前运算符**入栈**

Example:

1. A+B*(C-D)-E/F
   1. ABCD-*+EF/-

### 中缀表达式的计算(机算)- 操作数和运算符都入栈

![20221023214218](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221023214218.png)

1. 初始化两个栈: 操作数栈和运算符栈
   1. 若扫描到操作数，压入操作数栈
   2. 若扫描到运算符或界限符，则按照"中缀转后缀"相同的逻辑压入运算符栈
      1. 期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈

## 3.3.3 栈在递归中的应用

1. 递归定义
   1. 在一个函数、过程或数据结构的定义中又应用了它自身
   2. 需满足的两个条件
      1. 递归表达式(递归体)
      2. 边界条件(递归出口)
   3. 精髓
      1. 在于能否将原始问题转换为**属性相同但规模较小**的问题
   4. 例子: 斐波那契数列
      1. ![20221023215432](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221023215432.png)

   ```c
   int Fib(int n)
   {
      if (n == 0) //边界条件
         return 0;
      else if (n = 1)
         return 1; //边界条件
      else
         return Fib(n - 1) + Fib(n - 2); //递归表达式
   }
   ```

2. 递归工作栈
   1. ![20221023215045](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221023215045.png)
   2. 在函数调用的过程中，系统为以下三个方面等开辟了"函数调用栈"来进行数据存储
      1. 每一层的返回点
      2. 传入实参
      3. 局部变量
   3. 函数调用栈可称为"递归工作栈"
      1. 每**进入**一层递归，就将递归调用**所需信息压入栈顶**
      2. 每**退出**一层递归，就从栈顶**弹出相应信息**

## 3.3.4 队列在层次遍历中的应用

层次遍历二叉树的过程的简单描述如下

1. 根结点入队;
2. 若队空（所有结点都已处理完毕），则结束遍历, 否则重复3操作。
3. 队列中第一个结点出队，并访问之。若其有左孩子,则将左孩子入队；若其有右孩子，则将右孩子入队，返回2。

## 3.3.5 队列在计算机系统中的应用

1. 解决**主机与外部设备**之间速度不匹配的问题
   1. 解决的方法是设置一个打印数据缓冲区
      1. 主机把要打印输出的数据依次写入这个缓冲区,写满后就暂停输出，转去做其他的事情。
      2. 打印机就从缓冲区中按照先进先出的原则依次取出数据并打印
      3. 打印完后再向主机发岀请求
2. 解决由多用户引起的**资源竞争**问题
   1. 操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把CPU分配给队首请求的用户使用

## 3.3.6 题

⭐⭐⭐

- 05两层![20221023230205](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221023230205.png)
- 08 前序和深度要借用到?![20221023230314](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221023230314.png)
  - 前序遍历非递归算法需要用到栈
- 11')'无需进栈![20221023230526](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221023230526.png)
