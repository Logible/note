# 线性表

1. 了解线性表的概念：定义，特点，线性表抽象数据类型定义
2. 掌握线性表的顺序表示与实现
3. 掌握线性表的链接表示与实现
4. 掌握线性表的应用

## 2.1 线性表的定义和基本操作*

![20220713165836](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220713165836.png)

线性表是一种逻辑结构

1. 定义
   1. 线性表是具有**相同数据类型**的n(n >= 0)个数据元素的**有限序列**, 其中n为表长, 当n = 0时线性表是一个空表;

2. 特点
   1. 表中元素的**个数**有限
   2. 表中元素具有**逻辑上的顺序性**, 表中元素有其先后次序
   3. 表中元素都是**数据元素**, 每个元素都是单个元素
   4. 表中元素的**数据类型都相同**, 这意味着每个元素占有相同大小的存储空间
   5. 表中元素具有**抽象性**, 即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容

3. 基本操作(非)
    1. InitList(&L)∶初始化表。构造一个空的线性表。
    2. Length(L)∶求表长。返回线性表L的长度，即L中数据元素的个数。
    3. LocateElem(L, e);按值查找操作。在表L中查找具有给定关键字值的元素。
    4. GetElem(L, i):按位查找操作。获取表L中第i个位置的元素的值。
    5. ListInsert(&L, i ,e):插入操作。在表L中的第i个位置上插入指定元素e。
    6. ListDelete(&L, i ,&e): 移除操作。删除表 工中第i个位置的元素，并用e 返回删除元素的值
    7. PrintList(L): 输出操作。按前后顺序输出线性表L的所有元素值。
    8. Empty(L): 判空操作。若L为空表，则返回true，否则返回 false。
    9. DestroyList(&L): 销毁操作。销毁线性表，并释放线性表L所占用的内存空间

## 2.2 线性表的顺序表示

### 2.2.1 顺序表的定义

1. 定义
   1. 线性表的顺序存储又称**顺序表**。它是用一组**地址连续的存储单元**依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻

2. 表示方式
   1. 通常使用数组来描述线性表的顺序存储结构

3. 动态分配语句
   1. C
      1. L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
   2. C++
      1. L data=new ElemType[initSize];

   - 静态分配

   ```C
   #define MaxSize 10
   type struct{
       Elemtype data[MaxSize];//顺序表的元素
       int length;//顺序表的当前长度
   }SqList; //顺序表的类型定义

   void InitList(Sqlist &L){
       L.length = 0; //顺序表初始长度赋0
   }

   int main(){
       SqList L;
       InitList(L);
       return 0;
   }
   ```

   - 动态分配

   ```C
   #define InitSize 100 //默认最大长度
   typedef struct{
       Elemtype *data;//指示动态分配数组的指针
       int MaxSize //顺序表的最大容量
       int length; //顺序表的当前个数
   }SeqList    //动态分配顺序表的类型定义

   void InitList(Sqlist &L){
       L.data=(ElemType *)malloc(sizeof(ElemType)*InitSize);
       L.length = 0;
       L.Maxsize = InitSize;
   }

   void IncreaseSize(SeqList &L, int len){
       int *p = L.data;
       L.data=(ElemType *)malloc(sizeof(ElemType)*L.MaxSize+len);
       for(int i = 0; i < L.length; i++){
           L.data[i] = p[i]//将数组复制到新区域
       }
       L.MaxSize = L.Maxsize+len;//顺序表最大长度增加len
       free(p);//释放原来的内存空间
   }

   int main(){
       SeqList L; //声明一个顺序表
       InitList(L);
       //...插入元素
       IncreaseSize(L,5);
       return 0;
   }
   ```

4. 特点
   1. 最主要的特点是随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素

### 2.2.2 顺序表上基本操作的实现

1. 插入操作

    ```c
    bool ListInsert(Sqlist &L, int i, ElemType e){
        if(i<1 || i>L.length+1) //判断i范围是否有效
            return false;
        if(L.length >= MaxSize) //当前存储空间已满,不能插入
            return false;
        for(int j = L.length; j>=i ;j--)//将第i个元素及之后的元素后移
            L.data[j] = L.data[j-1];
        L.data[i-1] = e;    //在位置i放入e
        L.length++;         //线性表长度+1
        return true;
    }
    ```

    时间复杂度:![20220714163344](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220714163344.png)

2. 删除操作

    ```c
    bool ListDelete(Sqlist &L, int i, ElemType &e){
        if(i<1 || i>L.length) //判断i范围是否有效
            return false;
        e = L.data[i-1];    //记录删除元素e
        for(int j = i; j < length ;j++)//将第i个元素后的元素前移
            L.data[j-1] = L.data[j];
        L.length--;         //线性表长度-1
        return true;
    }
    ```

    时间复杂度:![20220714165116](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220714165116.png)

3. 按值查找操作

```c
int LocateElem(Sqlist L, Elemtype e)[
    int i;
    for(i = 0; i < L.length; i++)
        if(L.data[i] == e)
            return i+1;
    return 0;
]
```

时间复杂度:![20220714165348](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220714165348.png)
