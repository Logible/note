# 2.2 çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º

- [2.2 çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º](#22-çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º)
  - [2.2.1 é¡ºåºè¡¨çš„å®šä¹‰](#221-é¡ºåºè¡¨çš„å®šä¹‰)
  - [2.2.2 é¡ºåºè¡¨ä¸ŠåŸºæœ¬æ“ä½œçš„å®ç°](#222-é¡ºåºè¡¨ä¸ŠåŸºæœ¬æ“ä½œçš„å®ç°)
  - [é¢˜ç›®](#é¢˜ç›®)
    - [é€‰æ‹©é¢˜](#é€‰æ‹©é¢˜)
    - [å¤§é¢˜](#å¤§é¢˜)
  - [çœŸé¢˜](#çœŸé¢˜)

## 2.2.1 é¡ºåºè¡¨çš„å®šä¹‰

1. å®šä¹‰
   1. çº¿æ€§è¡¨çš„é¡ºåºå­˜å‚¨åˆç§°**é¡ºåºè¡¨**ã€‚å®ƒæ˜¯ç”¨ä¸€ç»„**åœ°å€è¿ç»­çš„å­˜å‚¨å•å…ƒ**ä¾æ¬¡å­˜å‚¨çº¿æ€§è¡¨ä¸­çš„æ•°æ®å…ƒç´ ï¼Œä»è€Œä½¿å¾—é€»è¾‘ä¸Šç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ åœ¨ç‰©ç†ä½ç½®ä¸Šä¹Ÿç›¸é‚»
   2. ç‰¹ç‚¹: é€»è¾‘é¡ºåºä¸å…¶ç‰©ç†é¡ºåºç›¸åŒ

2. è¡¨ç¤ºæ–¹å¼
   1. é€šå¸¸ä½¿ç”¨æ•°ç»„æ¥æè¿°çº¿æ€§è¡¨çš„é¡ºåºå­˜å‚¨ç»“æ„

3. åŠ¨æ€åˆ†é…è¯­å¥
   1. C
      1. L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
   2. C++
      1. L.data=new ElemType[initSize];

   - é™æ€åˆ†é…

   ```C
    #define MaxSize 10
    typedef struct
    {
        Elemtype data[MaxSize]; //é¡ºåºè¡¨çš„å…ƒç´ 
        int length;             //é¡ºåºè¡¨çš„å½“å‰é•¿åº¦
    } SqList;                   //é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰
   ```

   - åŠ¨æ€åˆ†é…
     - åŠ¨æ€åˆ†é…å¹¶ä¸æ˜¯é“¾å¼å­˜å‚¨ã€å®ƒåŒæ ·å±äºé¡ºåºå­˜å‚¨ç»“æ„ï¼Œç‰©ç†ç»“æ„æ²¡æœ‰å˜åŒ–ï¼Œä¾ç„¶æ˜¯éšæœºå­˜å–æ–¹å¼ï¼Œåªæ˜¯åˆ†é…çš„ç©ºé—´å¤§å°å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€å†³å®šã€‚

   ```C
    #define InitSize 100 //é»˜è®¤æœ€å¤§é•¿åº¦
    typedef struct
    {
        Elemtype *data; //æŒ‡ç¤ºåŠ¨æ€åˆ†é…æ•°ç»„çš„æŒ‡é’ˆ
        int MaxSize;    //é¡ºåºè¡¨çš„æœ€å¤§å®¹é‡
        int length;     //é¡ºåºè¡¨çš„å½“å‰ä¸ªæ•°
    } SeqList;          //åŠ¨æ€åˆ†é…é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰
   ```

4. ç‰¹ç‚¹
   1. æœ€ä¸»è¦çš„ç‰¹ç‚¹æ˜¯éšæœºè®¿é—®ï¼Œå³é€šè¿‡é¦–åœ°å€å’Œå…ƒç´ åºå·å¯åœ¨æ—¶é—´$O(1)$å†…æ‰¾åˆ°æŒ‡å®šçš„å…ƒç´ 
   2. é¡ºåºè¡¨çš„å­˜å‚¨å¯†åº¦é«˜ï¼Œæ¯ä¸ªç»“ç‚¹**åªå­˜å‚¨æ•°æ®å…ƒç´ **
   3. é¡ºåºè¡¨é€»è¾‘ä¸Šç›¸é‚»çš„å…ƒç´ ç‰©ç†ä¸Šä¹Ÿç›¸é‚»ï¼Œæ‰€ä»¥æ’å…¥å’Œåˆ é™¤æ“ä½œéœ€è¦ç§»åŠ¨**å¤§é‡å…ƒç´ **

## 2.2.2 é¡ºåºè¡¨ä¸ŠåŸºæœ¬æ“ä½œçš„å®ç°

1. æ’å…¥æ“ä½œ
   1. åœ¨é¡ºåºè¡¨$L$çš„ç¬¬$i(1<=i<=L.length+1)$ä¸ªä½ç½®æ’å…¥æ–°å…ƒç´ $e$

    ```c
   bool ListInsert(Sqlist &L, int i, ElemType e)
   {
      if (i < 1 || i > L.length + 1) //åˆ¤æ–­ièŒƒå›´æ˜¯å¦æœ‰æ•ˆ
         return false;
      if (L.length >= MaxSize) //å½“å‰å­˜å‚¨ç©ºé—´å·²æ»¡,ä¸èƒ½æ’å…¥
         return false;
      for (int j = L.length; j >= i; j--) //å°†ç¬¬iä¸ªå…ƒç´ åŠä¹‹åçš„å…ƒç´ åç§»
         L.data[j] = L.data[j - 1];
      L.data[i - 1] = e; //åœ¨ä½ç½®iæ”¾å…¥e
      L.length++;ğŸ’š        //çº¿æ€§è¡¨é•¿åº¦+1
      return true;
   }
    ```

    æ—¶é—´å¤æ‚åº¦:![20220714163344](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220714163344.png)

2. åˆ é™¤æ“ä½œ
   1. åˆ é™¤é¡ºåºè¡¨Lä¸­ç¬¬$i(1<=i<=L.length)$ä¸ªä½ç½®çš„å…ƒç´ ï¼Œç”¨å¼•ç”¨å˜é‡$e$è¿”å›

    ```c
   bool ListDelete(Sqlist &L, int i, ElemType &e)
   {
      if (i < 1 || i > L.length) //åˆ¤æ–­ièŒƒå›´æ˜¯å¦æœ‰æ•ˆ
         return false;
      e = L.data[i - 1];               //è®°å½•åˆ é™¤å…ƒç´ e
      for (int j = i; j < length; j++) //å°†ç¬¬iä¸ªå…ƒç´ åçš„å…ƒç´ å‰ç§»
         L.data[j - 1] = L.data[j];
      L.length--; //çº¿æ€§è¡¨é•¿åº¦-1
      return true;
   }
    ```

    æ—¶é—´å¤æ‚åº¦:![20220714165116](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220714165116.png)

3. æŒ‰å€¼æŸ¥æ‰¾æ“ä½œ

    ```c
   int LocateElem(Sqlist L, Elemtype e)
   {
      int i;
      for (i = 0; i < L.length; i++)
         if (L.data[i] == e)
            return i + 1;
      return 0;
   }
    ```

    æ—¶é—´å¤æ‚åº¦:![20220714165348](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220714165348.png)

## é¢˜ç›®

### é€‰æ‹©é¢˜

1. éšæœºå­˜å‚¨æ¦‚å¿µ
   1. æ ¹æ®èµ·å§‹åœ°å€åŠ ä¸Šå…ƒç´ çš„åºå·ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ°è®¿é—®ä»»æ„ä¸€ä¸ªå…ƒç´ 

- 01é¡ºåºè¡¨æ–¹ä¾¿åœ°è¿ç”¨äºå„ç§é€»è¾‘ç»“æ„çš„å­˜å‚¨è¡¨ç¤º![20221016230231](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221016230231.png)
- 02å­˜å–æ–¹å¼æ˜¯æŒ‡è¯»å†™æ–¹å¼![20221016222445](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221016222445.png)
- 11ç”³è¯·ç©ºé—´![20221016222639](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221016222639.png)

### å¤§é¢˜

- 1. Sqlist &L
    1. [L.length-1];

â­

- (3)å¯¹é•¿åº¦ä¸ºnçš„é¡ºåºè¡¨L, ç¼–å†™ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€ç©ºé—´å¤æ‚åº¦ä¸ºO(1)çš„ç®—æ³•ï¼Œè¯¥ç®—æ³•åˆ é™¤çº¿æ€§è¡¨ä¸­æ‰€æœ‰å€¼ä¸ºxçš„æ•°æ®å…ƒç´ 
  - ğŸ’šthinking1:
    - åŒæŒ‡é’ˆ, ç”¨kè®°å½•ä¸ç¬¦åˆåˆ é™¤å…ƒç´ çš„ä¸ªæ•°
  - ğŸ’šthinking2:
    - åŒæŒ‡é’ˆ, ç”¨kè®°å½•ç¬¦åˆåˆ é™¤å…ƒç´ çš„ä¸ªæ•°
      - å½“é‡åˆ°ä¸ç¬¦åˆåˆ é™¤å…ƒç´ , å‰ç§»è¯¥å…ƒç´ 

```c
void del_x_1(Sqlist &L, Elemtype x)
{
    //æœ¬ç®—æ³•å®ç°åˆ é™¤é¡ºåºè¡¨Lä¸­æ‰€æœ‰å€¼ä¸ºxçš„æ•°æ®å…ƒç´ 
    int k = 0, i; //è®°å½•å€¼ä¸ç­‰äºxçš„å…ƒç´ ä¸ªæ•°
    for (i = 0; i < L.length; i++)
        if (L.data[i] != x)
        {
            L.data[k] = L.data[i];
            k++; //ä¸ç­‰äºxçš„å…ƒç´ å¢1
        }
    ğŸ’šL.length = k; //é¡ºåºè¡¨Lçš„é•¿åº¦ç­‰äºk
}

void del_x_2(Sqlist &L, Elemtype x)
{
    int k = 0, i = 0; // kè®°å½•å€¼ç­‰äºxçš„å…ƒç´ ä¸ªæ•°
    while (i < L.length)
    {
        if (L.data[i] == x)
            k++;
        else
            L.data[i - k] = L.data[i]; //å½“å‰å…ƒç´ å‰ç§»kä¸ªä½ç½®
        i++;
    }
    L.length = L.length - k; //é¡ºåºè¡¨Lçš„é•¿åº¦é€’å‡
}
```

- (4)ä»**æœ‰åºé¡ºåºè¡¨**ä¸­åˆ é™¤å…¶å€¼åœ¨ç»™å®šå€¼sä¸rä¹‹é—´(è¦æ±‚s < t)çš„æ‰€æœ‰å…ƒç´ ï¼Œè‹¥sæˆ–tä¸åˆç†æˆ–é¡ºåºè¡¨ä¸ºç©ºï¼Œåˆ™æ˜¾ç¤ºå‡ºé”™ä¿¡æ¯å¹¶é€€å‡ºè¿è¡Œ

```c
bool Del_s_t2(SqList &L, ElemType s, ElemType t)
{
    //åˆ é™¤æœ‰åºé¡ºåºè¡¨Lä¸­å€¼åœ¨ç»™å®šå€¼sä¸tä¹‹é—´çš„æ‰€æœ‰å…ƒç´ 
    int i, j;
    if (s >= t || L.length == 0)
        return false;
    
    for (i = 0; i < L.lengths && L.data[i] < s; i++); //å¯»æ‰¾å€¼å¤§äºç­‰äº s çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    if (i >= L.length)ğŸ’š
        return false; //æ‰€æœ‰å…ƒç´ å€¼å‡å°äºs,è¿”å›
    
    for (j = i; j < L.lengths && L.data[j] <= t; j++)//å¯»æ‰¾å€¼å¤§äº t çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    
    for (; j < L.length; i++, j++)
        L.data[i] = L.data[j]; //å‰ç§»ï¼Œå¡«è¡¥è¢«åˆ å…ƒç´ ä½ç½®
    L.length = i;ğŸ’š
    return true;
}
```

- (5)ä»é¡ºåºè¡¨ä¸­åˆ é™¤å…¶å€¼åœ¨ç»™å®šå€¼sä¸tä¹‹é—´(åŒ…å«så’Œt,è¦æ±‚s < t)çš„æ‰€æœ‰å…ƒç´ ï¼Œè‹¥sæˆ–tä¸åˆç†æˆ–é¡ºåºè¡¨ä¸ºç©ºï¼Œåˆ™æ˜¾ç¤ºå‡ºé”™ä¿¡æ¯å¹¶é€€å‡ºè¿è¡Œ

```c
bool delete_s_t(Sqlist &L, ElemType s, ElemType t)
{
   //kä¸ºç¬¦åˆåˆ é™¤æ¡ä»¶çš„å…ƒç´ ä¸ªæ•°
    int i, k = 0;
    if (L.length == 0 || s >= t)
        return false;
    for (i = 0; i < L.length; i++)
    {
        if (L.data[i] >= s && L.data[i] <= t)
            k++;
        else
            L.data[i - k] = L.data[i]; //å½“å‰å…ƒç´ å‰ç§»kä¸ªä½ç½®
    }
    L.length -= k;
    return true;
}
```

- (6)ä»**æœ‰åº**é¡ºåºè¡¨ä¸­**åˆ é™¤æ‰€æœ‰å…¶å€¼é‡å¤**çš„å…ƒç´ ï¼Œä½¿è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„å€¼å‡ä¸åŒ(ğŸ’šæ— åºåˆ™é‡‡ç”¨æ•£åˆ—è¡¨)
  - ğŸ’šç±»ä¼¼äºåˆ é™¤å€¼ä¸ºxçš„ç¬¬ä¸€ç§ç®—æ³•
    - åŒæŒ‡é’ˆ, æ‰¾åˆ°ä¸ç¬¦åˆåˆ é™¤æ¡ä»¶çš„å…ƒç´ , å†å°†å…¶å‰ç§»

```c
bool Delete_Same(SeqList &L)
{
   if (L.length == 0)
       return false;
   int i, j; // iå­˜å‚¨ç¬¬ä¸€ä¸ªä¸ç›¸åŒçš„å…ƒç´ ï¼Œjä¸ºå·¥ä½œæŒ‡é’ˆ
   for (i = 0, j = 1 ; j < L.length ; j++)
       if (L.data[i] != L.data[j])  //æŸ¥æ‰¾ä¸‹ä¸€ä¸ªä¸ä¸Šä¸ªå…ƒç´ å€¼ä¸åŒçš„å…ƒç´ 
           L.data[++i] = L.data[j]; //æ‰¾åˆ°åï¼Œå°†å…ƒç´ å‰ç§»
   L.length = i + 1;
   return true;
}
```

- â­(7)ç»å…¸åˆå¹¶é¡ºåºè¡¨ç®—æ³•

```c
bool Merge(SeqList A, SeqList B, SeqList &C)
{
    //å°†æœ‰åºé¡ºåºè¡¨Aä¸Båˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„æœ‰åºé¡ºåºè¡¨C
    //å¤§äºé¡ºåºè¡¨çš„æœ€å¤§é•¿åº¦
    if (A.length + B.length > C.maxSize)
        return false;
    int i = 0, j = 0, k = 0; //å¾ªç¯ï¼Œä¸¤ä¸¤æ¯”è¾ƒï¼Œå°è€…å­˜å…¥ç»“æœè¡¨
    while (i < A.length && j < B.length)
    {
        if (A.data[i] <= B.data[j])
            C.data[k++] = A.data[i++];
        else
            C.data[k++] = B.data[j++];
    }
    //è¿˜å‰©ä¸€ä¸ªæ²¡æœ‰æ¯”è¾ƒå®Œçš„é¡ºåºè¡¨
    while (i < A.length)
        C.data[k++] = A.data[i++];
    while (j < B.length)
        C.data[k++] = B.data[j++];
    C.length = k;
    return true;
}
```

- (8)å·²çŸ¥åœ¨ä¸€ç»´æ•°ç»„A[m+n]ä¸­ä¾æ¬¡å­˜æ”¾ä¸¤ä¸ªçº¿æ€§è¡¨(a1, a2, a3,â€¦, am)å’Œ(b1, b2, b3,â€¦, bn). ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå°†æ•°ç»„ä¸­ä¸¤ä¸ªé¡ºåºè¡¨çš„ä½ç½®äº’æ¢ï¼Œå³å°†(b1, b2, b3,â€¦, bn)æ”¾åœ¨(a1, a2, a3,â€¦, am)çš„å‰é¢ã€‚

```c
typedef int DataType;
void Reverse(DataType A[], int left, int right, int arraySize)
{ //é€†è½¬(aleft aleft+1, aleft+2 ...aright)ä¸º(aright, aright-1 â€¢â€¢â€¢, aleft)
    if (left >= right || right >= arraySize)
        return;
    int mid = (left + right) / 2;
    for (int i = 0; i < mid - left; i++)
    {
        DataType temp = A[left + i];
        A[left + i] = A[right - i];
        A[right - i] = temp;
    }
}
void Exchange(DataType A[], int m, int n, int arraySize)
{
    /*æ•°ç»„A[m+n]ä¸­ï¼Œä»0åˆ°m-1å­˜æ”¾é¡ºåºè¡¨(al, a2, a3z â€¢â€¢â€¢, am),ä»måˆ°m+n-1å­˜æ”¾é¡ºåºè¡¨
(bl,b2,b3 â€”,bn),ç®—æ³•å°†è¿™ä¸¤ä¸ªè¡¨çš„ä½ç½®äº’æ¢*/
    Reverse(A, 0, m + n - 1, arraySize);
    Reverse(A, 0, n - 1, arraySize);
    Reverse(A, n, m + n - 1, arraySize);
}
```

- (9)ç†Ÿæ‚‰æŠ˜åŠæŸ¥æ‰¾: çº¿æ€§è¡¨(a1, a2, a3,â€¦,an)ä¸­çš„å…ƒç´ é€’å¢æœ‰åºä¸”æŒ‰é¡ºåºå­˜å‚¨äºè®¡ç®—æœºå†…ã€‚è¦æ±‚è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå®Œæˆç”¨æœ€å°‘æ—¶é—´åœ¨è¡¨ä¸­æŸ¥æ‰¾æ•°å€¼ä¸ºxçš„å…ƒç´ ï¼Œè‹¥æ‰¾åˆ°ï¼Œåˆ™å°†å…¶ä¸åç»§å…ƒç´ ä½ç½®ç›¸äº¤æ¢ï¼Œè‹¥æ‰¾ä¸åˆ°ï¼Œåˆ™å°†å…¶æ’å…¥è¡¨ä¸­å¹¶ä½¿è¡¨ä¸­å…ƒç´ ä»é€’å¢æœ‰åºã€‚

```c
void SearchExchangelnsert(ElemType A[], ElemType x)
{
    int low = 0, high = n - 1, mid; // lowå’ŒhighæŒ‡å‘é¡ºåºè¡¨ä¸‹ç•Œå’Œä¸Šç•Œçš„ä¸‹æ ‡
    while (low <= high)
    {
        mid = (low + high) / 2; //æ‰¾ä¸­é—´ä½ç½®
        if (A[mid] == x)
            break; //æ‰¾åˆ° x,é€€å‡º while å¾ªç¯
        else if (A[mid] < x)
            low = mid + 1; //åˆ°ä¸­ç‚¹ mid çš„å³åŠéƒ¨å»æŸ»
        else
            high = mid - 1; //åˆ°ä¸­ç‚¹midçš„å·¦åŠéƒ¨å»æŸ¥
    }
    //ä¸‹é¢ä¸¤ä¸ªifè¯­å¥åªä¼šæ‰§è¡Œä¸€ä¸ª

    if (A[mid] == x && mid != n - 1)//midä¸æ˜¯æœ€åä¸€ä¸ªå…ƒç´ 
    { 
        t = A[mid];
        A[mid] = A[mid + 1];
        A[mid + 1] = t;
    }
    if (low > high)
    {
        //æŸ¥æ‰¾å¤±è´¥ï¼Œæ’å…¥æ•°æ®å…ƒç´ x
        for (int i = n - 1; i > high; i--)
            A[i + 1] = A[i]; //åç§»å…ƒç´ 
        A[i + 1] = x;        //æ’å…¥ x
    }                        //ç»“æŸæ’å…¥
}
```

## çœŸé¢˜

â­â­â­

- 2010çœŸé¢˜![20221029102250](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221029102250.png)

1. è§£æ³•1
   1. ç®—æ³•æ€æƒ³
      1. åˆ›å»ºå¤§å°ä¸ºPçš„è¾…åŠ©æ•°ç»„S, å…ˆå°†å‰pä¸ªå…ƒç´ å­˜åœ¨æ•°ç»„Sä¸­, ç¬¬pä¸ªå…ƒç´ ä¹‹åçš„å…ƒç´ å·¦ç§», å†å°†æ•°ç»„Sçš„ä¸ªå…ƒç´ æ”¾åˆ°è¡¨å°¾

        ```c
        void leftMove(Sqlist &L, int p)
        {
            int *S = new ElemType[p];ğŸ’š
            for (i = 0; i < p; i++)
            {
                S[i] = L.R[i];
                L.R[i] = L.R[i + p];
            }
            for (i = p; i < L.length; i++)
            {
                L.R[i] = S[j++];
            }
            return true;
        }
        ```

   2. å¤æ‚åº¦
      1. ç©ºé—´å¤æ‚åº¦
         1. æ‰€ç”¨è¾…åŠ©æ•°ç»„å¤§å°ä¸ºP, ç©ºé—´å¤æ‚åº¦ä¸ºO(P)
      2. æ—¶é—´å¤æ‚åº¦
         1. ç§»åŠ¨pä¹‹åå…ƒç´ å’Œç§»åŠ¨pä¹‹å‰å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦åˆ†ä¸ºæ˜¯O(p)å’ŒO(n-p), æ•…æ‰€è®¾è®¡çš„ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸ºO(n);

2. è§£æ³•2(ä¼˜è´¨è§£æ³•)
   1. å°†é—®é¢˜è§†ä¸ºå°†æ•°ç»„abè½¬æ¢ä¸ºba(aä»£è¡¨æ•°ç»„çš„å‰pä¸ªå…ƒç´ ï¼Œbä»£è¡¨æ•°ç»„ä¸­ä½™ä¸‹çš„n-pä¸ªå…ƒç´ )ï¼Œå…ˆå°†aé€†ç½®æˆ$a^{-1}b$,å†å°†bé€†ç½®å¾—åˆ°$a^{-1}b^{-1}$, æœ€åå°†æ•´ä¸ª$a^{-1}b^{-1}$é€†ç½®å¾—åˆ°$(a^{-1}b^{-1})^{-1}=ba$

```c
void Reverse(int R[], int left, int right)
{
   int mid = (left + right / 2);
   for (int i = 0; i <= mid - left; i++)
   {
      int temp = R[left + i];
      R[left + i] = R[right - i];
      R[right - i] = temp;
   }
}

void Converse(int R[], int n; int p)
{
   Reverse(R, 0, n - 1);
   Reverse(R, p, n - 1);
   Reverse(R, 0, n - 1);
}
```

![20221029212948](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221029212948.png)

- 2011çœŸé¢˜![20221029221239](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221029221239.png)

1. ç®—æ³•æ€æƒ³:
   1. æŒ‰é¡ºåºè®¿é—®ABä¸­è¾ƒå°å…ƒç´ 
   2. å½“è®¿é—®æŒ‡é’ˆè¾¾åˆ°L/2æ—¶,è¿”å›Aæˆ–Bä¸­å…ƒç´ 

2. ä»£ç 

```c
int midNumber(int A[], int B[], int L){
   for (i = 0; j = 0, l = 0;;)
   {
      if (A[i] > B[j]){
         i++;
         tag = 0;
      }
      else{
         j++;
         tag = 1;
      }
      l++;

      if (l == L){
         if (tag == 0)
            return A[i];
         if (tag == 1)
            return B[j];
      }
   }
}
```

- æ—¶é—´å¤æ‚åº¦: å¯¹ABä¾æ¬¡æ¯”è¾ƒ, ä¸ºO(n)
- ç©ºé—´å¤æ‚åº¦: O(1)

- 2013çœŸé¢˜![20221029224031](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221029224031.png)
  - ğŸ’šç©ºé—´æ¢æ—¶é—´
  - ğŸ’š$0<a_i<n$

1. æ„å»ºä¸€ä¸ªå¤§å°ä¸ºnçš„æ•°ç»„ï¼Œç”¨äºå¯¹æ¯ä¸ªæ•´æ•°çš„è®¡æ•°ï¼Œéå†ä¸€éåºåˆ—ç„¶åå†éå†1æ¬¡è¿™ä¸ªæ•°ç»„æ‰¾æœ€å¤§å€¼
   1. è‹¥æœ€å¤§å€¼ > n/2; è¾“å‡ºä¸»å…ƒç´ 
   2. è‹¥æœ€å¤§å€¼ < n/2; è¾“å‡º-1
2. æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦o(n)æ‰£1åˆ†

```c
nt mainElement(int A[], int n)
{
   int *S = new int[n];
   memset(S,0,sizeof(int)*n);
   for (i = 0; i < n; i++)
      S[A[i]]++;
   int max = S[0];
   int main = 0;
   for (i = 1; i < n; i++)
      if (max < S[i])
      {
         max = S[i];
         main = i;
      }
   if (max > n / 2)
      return main;
   else
      return -1;
}
```

- 2018çœŸé¢˜![2018çœŸé¢˜](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221031095637.png)

1. ç®—æ³•æ€æƒ³:
   1. åˆ†é…ä¸€ä¸ªç”¨äºæ ‡è®°çš„æ•°ç»„B[n],ç”¨æ¥è®°å½•Aä¸­æ˜¯å¦å²€ç°äº† ğŸ’š**1ã€œn**ä¸­çš„æ­£æ•´æ•°
   2. B[0]å¯¹åº”æ­£æ•´æ•°1, B[n-1]å¯¹åº”æ­£æ•´æ•°n,åˆå§‹åŒ–Bä¸­å…¨éƒ¨ä¸º0
   3. ç”±äºAä¸­å«æœ‰nä¸ªæ•´æ•°ï¼Œå› æ­¤å¯èƒ½è¿”å›çš„å€¼æ˜¯1ã€œn+1
      1. å½“Aä¸­nä¸ªæ•°æ°å¥½ä¸º1ã€œnæ—¶è¿”å›n+1
      2. å½“æ•°ç»„Aä¸­å‡ºç°äº†å°äºç­‰äº0æˆ–å¤§äºnçš„å€¼æ—¶ï¼Œä¼šå¯¼è‡´1ã€œnä¸­å‡ºç°ç©ºä½™ä½ç½®ï¼Œè¿”å›ç»“æœå¿…ç„¶åœ¨1ã€œnä¸­;

2. æ—¶ç©º
   1. æ—¶é—´: O(n)
   2. ç©ºé—´: O(n)

```c
int findMissMin(int A[], int n)
{
   int i, *B; //æ ‡è®°æ•°ç»„
   B = new int[n];
   memset(B, 0, sizeof(int) * n); //èµ‹åˆå€¼0
   for (i = 0; i < n; i++)
      if (A[i] > 0 && A[i] <= n)
         B[A[i] - 1] = 1;
   for (i = 0; i < n; i++)
      if (B[i] == 0)
         break;
   return i + 1;
}
```

â­â­â­â­

- 2020çœŸé¢˜![20221030230123](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221030230123.png)
  - ![20221030230146](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221030230146.png)

```c
#define INT_MAX 0x7fffffff

int abs_(int a)
{
   if (a < 0)
      return -a;
   else
      return a;
}

bool xls_min(int a, int b, int c)
{
   if (a <= b && a <= c)
      return true;
   else
      return false;
}

int findMinofTrip(int A[], int n, int B[], int m, int C[], int p)
{
   int i = 0, j = 0, k = 0, D_min = INT_MAX, D;
   while (i < n && j < m && k < p && D_min > 0)
   {
      D = abs_(A[i] - B[i]) + abs_(B[j] - C[k]) + abs_(C[k] - A[i]); //è®¡ç®—D
      if (D < D_min)
         D_min = D;

      if (xls_min(A[i], B[j], C[k]))
         i++;
      else if (xls_min(B[j], A[i], C[k]))
         j++;
      else
         k++;
   }
   return D_min;
}
```
