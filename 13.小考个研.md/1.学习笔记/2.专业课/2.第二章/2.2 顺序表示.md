# 2.2 线性表的顺序表示

- [2.2 线性表的顺序表示](#22-线性表的顺序表示)
  - [2.2.1 顺序表的定义](#221-顺序表的定义)
  - [2.2.2 顺序表上基本操作的实现](#222-顺序表上基本操作的实现)
  - [题目](#题目)
    - [选择题](#选择题)
    - [大题](#大题)
  - [真题](#真题)

## 2.2.1 顺序表的定义

1. 定义
   1. 线性表的顺序存储又称**顺序表**。它是用一组**地址连续的存储单元**依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻
   2. 特点: 逻辑顺序与其物理顺序相同

2. 表示方式
   1. 通常使用数组来描述线性表的顺序存储结构

3. 动态分配语句
   1. C
      1. L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
   2. C++
      1. L.data=new ElemType[initSize];

   - 静态分配

   ```C
    #define MaxSize 10
    typedef struct
    {
        Elemtype data[MaxSize]; //顺序表的元素
        int length;             //顺序表的当前长度
    } SqList;                   //顺序表的类型定义
   ```

   - 动态分配
     - 动态分配并不是链式存储、它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。

   ```C
    #define InitSize 100 //默认最大长度
    typedef struct
    {
        Elemtype *data; //指示动态分配数组的指针
        int MaxSize;    //顺序表的最大容量
        int length;     //顺序表的当前个数
    } SeqList;          //动态分配顺序表的类型定义
   ```

4. 特点
   1. 最主要的特点是随机访问，即通过首地址和元素序号可在时间$O(1)$内找到指定的元素
   2. 顺序表的存储密度高，每个结点**只存储数据元素**
   3. 顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动**大量元素**

## 2.2.2 顺序表上基本操作的实现

1. 插入操作
   1. 在顺序表$L$的第$i(1<=i<=L.length+1)$个位置插入新元素$e$

    ```c
   bool ListInsert(Sqlist &L, int i, ElemType e)
   {
      if (i < 1 || i > L.length + 1) //判断i范围是否有效
         return false;
      if (L.length >= MaxSize) //当前存储空间已满,不能插入
         return false;
      for (int j = L.length; j >= i; j--) //将第i个元素及之后的元素后移
         L.data[j] = L.data[j - 1];
      L.data[i - 1] = e; //在位置i放入e
      L.length++;        //线性表长度+1
      return true;
   }
    ```

    时间复杂度:![20220714163344](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220714163344.png)

2. 删除操作
   1. 删除顺序表L中第$i(1<=i<=L.length)$个位置的元素，用引用变量$e$返回

    ```c
   bool ListDelete(Sqlist &L, int i, ElemType &e)
   {
      if (i < 1 || i > L.length) //判断i范围是否有效
         return false;
      e = L.data[i - 1];               //记录删除元素e
      for (int j = i; j < length; j++) //将第i个元素后的元素前移
         L.data[j - 1] = L.data[j];
      L.length--; //线性表长度-1
      return true;
   }
    ```

    时间复杂度:![20220714165116](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220714165116.png)

3. 按值查找操作

    ```c
   int LocateElem(Sqlist L, Elemtype e)
   {
      int i;
      for (i = 0; i < L.length; i++)
         if (L.data[i] == e)
            return i + 1;
      return 0;
   }
    ```

    时间复杂度:![20220714165348](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220714165348.png)

## 题目

### 选择题

1. 随机存储概念
   1. 根据起始地址加上元素的序号，可以很方便地访问任意一个元素

- 01顺序表方便地运用于各种逻辑结构的存储表示![20221016230231](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221016230231.png)
- 02存取方式是指读写方式![20221016222445](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221016222445.png)
- 11申请空间![20221016222639](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221016222639.png)

### 大题

⭐⭐

(6)i j 作工作指针法

789

⭐

(3) 方法2

(4) 巧妙用ij

(5)写法效率不够高

- 1. Sqlist &L
    1. [L.length-1];

- (3)对长度为n的顺序表L, 编写一个时间复杂度为O(n)、空间复杂度为0(1)的算法，该算法删除线性表中所有值为x的数据元素

```c
void del_x_1(Sqlist &L, Elemtype x)
{
    //本算法实现删除顺序表L中所有值为x的数据元素
    int k = 0, i; //记录值不等于x的元素个数
    for (i = 0; i < L.length; i++)
        if (L.data[i] != x)
        {
            L.data[k] = L.data[i];
            k++; //不等于x的元素增1
        }
    L.length = k; //顺序表L的长度等于k
}

void del_x_2(Sqlist &L, Elemtype x)
{
    int k = 0, i = 0; // k记录值等于x的元素个数
    while (i < L.length)
    {
        if (L.data[i] == x)
            k++;
        else
            L.data[i - k] = L.data[i]; //当前元素前移k个位置
        i++;
    }
    L.length = L.length - k; //顺序表L的长度递减
}
```

- (4)从有序顺序表中删除其值在给定值s与r之间(要求s < t)的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行

```c
bool Del_s_t2(SqList &L, ElemType s, ElemType t)
{
    //删除有序顺序表L中值在给定值s与t之间的所有元素
    int i, j;
    if (s >= t || L.length == 0)
        return false;
    for (i = 0; i < L.lengths & L.data[i] < s; i++); //寻找值大于等于 s 的第一个元素
    if (i >= L.length)
        return false; //所有元素值均小于s,返回
    for (j = i; j < L.lengths & L.data[j] <= t; j++)//寻找值大于 t 的第一个元素
    for (; j < L.length; i++, j++)
        L.data[i] = L.data[j]; //前移，填补被删元素位置
    L.length = i;
    return true;
}
```

- (5)从顺序表中删除其值在给定值s与t之间(包含s和t,要求s < t)的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行

```c
bool delete_s_t(Sqlist &L, ElemType s, ElemType t)
{
    int i, k = 0;
    if (L.length == 0 || s >= t)
        return false;
    for (i = 0; i < L.length; i++)
    {
        if (L.data[i] >= s && L.data[i] <= t)
            k++;
        else
            L.data[i - k] = L.data[i]; //当前元素前移k个位置
    }
    L.length -= k;
    return true;
}
```

- (6)从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同

```c
bool Delete_Same(SeqList &L)
{
    if (L.length == 0)
        return false;
    int i, j; // i存储第一个不相同的元素，j为工作指针
    for (i = 0, j = 1 : j < L.length : j++)
        if (L.data[i] != L.data[j])  //查找下一个与上个元素值不同的元素
            L.data[++i] = L.data[j]; //找到后，将元素前移
    L.length = i + 1;
    return true;
}
```

- ⭐(7)经典合并顺序表算法

```javascript
bool Merge(SeqList A, SeqList B, SeqList &C)
{
    //将有序顺序表A与B合并为一个新的有序顺序表C
    //大于顺序表的最大长度
    if (A.length + B.length > C.maxSize)
        return false;
    int i = 0, j = 0, k = 0; //循环，两两比较，小者存入结果表
    while (i < A.length && j < B.length)
    {
        if (A.data[i] <= B.data[j])
            C.data[k++] = A.data[i++];
        else
            C.data[k++] = B.data[j++];
    }
    //还剩一个没有比较完的顺序表
    while (i < A.length)
        C.data[k++] = A.data[i++];
    while (j < B.length)
        C.data[k++] = B.data[j++];
    C.length = k;
    return true;
}
```

- (8)已知在一维数组A[m+n]中依次存放两个线性表(a1, a2, a3,…, am)和(b1, b2, b3,…, bn). 编写一个函数，将数组中两个顺序表的位置互换，即将(b1, b2, b3,…, bn)放在(a1, a2, a3,…, am)的前面。

```c
typedef int DataType;
void Reverse(DataType A[], int left, int right, int arraySize)
{ //逆转(aleft aleft+1, aleft+2 ...aright)为(aright, aright-1 •••, aleft)
    if (left >= right || right >= arraySize)
        return;
    int mid = (left + right) / 2;
    for (int i = 0; i < mid - left; i ++)
    {
        DataType temp = A[left + i];
        A[left + i] = A[right - i];
        A[right - i] = temp;
    }
}
void Exchange(DataType A[], int m, int n, int arraySize)
{
    /*数组A[m+n]中，从0到m-1存放顺序表(al, a2, a3z •••, am),从m到m+n-1存放顺序表
(bl,b2,b3 —,bn),算法将这两个表的位置互换*/
    Reverse(A, 0, m + n - 1, arraySize);
    Reverse(A, 0, n - 1, arraySize);
    Reverse(A, n, m + n - 1, arraySize);
}
```

- (9)熟悉折半查找: 线性表(a1, a2, a3,…,an)中的元素递增有序且按顺序存储于计算机内。要求设计一个算法，完成用最少时间在表中查找数值为x的元素，若找到，则将其与后继元素位置相交换，若找不到，则将其插入表中并使表中元素仍递增有序。

```c
void SearchExchangelnsert(ElemType A[], ElemType x)
{
    int low = 0, high = n - 1, mid; // low和high指向顺序表下界和上界的下标
    while (low <= high)
    {
        mid = (low + high) / 2; //找中间位置
        if (A[mid] == x)
            break; //找到 x,退出 while 循环
        else if (A[mid] < x)
            low = mid + 1; //到中点 mid 的右半部去査
        else
            high = mid - 1; //到中点mid的左半部去查
    }
    //下面两个if语句只会执行一个
    if (A[mid] == x && mid != n - 1)
    { //若最后一个元素与x相等，则不存在与其后继交换的操作
        t = A[mid];
        A[mid] = A[mid + 1];
        A[mid + 1] = t;
    }
    if (low > high)
    {
        //查找失败，插入数据元素x
        for (int i = n - 1; i > high; i--)
            A[i + 1] = A[i]; //后移元素
        A[i + 1] = x;        //插入 x
    }                        //结束插入
}
```

- 08![20221029211857](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221029211857.png)

## 真题

- 2010真题![20221029102250](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221029102250.png)

1. 解法1
   1. 算法思想
      1. 创建大小为P的辅助数组S, 先将前p个元素存在数组S中, 第p个元素之后的元素左移, 再将数组S的个元素放到表尾

        ```c
        void leftMove(Sqlist &L, int p)
        {
            int S[p];
            for (i = 0; i < p; i++)
            {
                S[i] = L.R[i];
                L.R[i] = L.R[i + p];
            }
            for (i = p; i < L.length; i++)
            {
                L.R[i] = S[j++];
            }
            return true;
        }
        ```

   2. 复杂度
      1. 空间复杂度
         1. 所用辅助数组大小为P, 空间复杂度为O(P)
      2. 时间复杂度
         1. 移动p之后元素和移动p之前元素的时间复杂度分为是O(p)和O(n-p), 故所设计的算法时间复杂度为O(n);

2. 解法2(优质解法)
   1. 将问题视为将数组ab转换为ba(a代表数组的前p个元素，b代表数组中余下的n-p个元素)，先将a逆置成$a^{-1}b$,再将b逆置得到$a^{-1}b^{-1}$, 最后将整个$a^{-1}b^{-1}$逆置得到$(a^{-1}b^{-1})^{-1}=ba$

```c
void Reverse(int R[], int left, int right)
{
   int mid = (left + right / 2);
   for (int i = 0; i <= mid - left; i++)
   {
      int temp = R[left + i];
      R[left + i] = R[right - i];
      R[right - i] = temp;
   }
}

void Converse(int R[], int n; int p)
{
   Reverse(R, 0, p - 1);
   Reverse(R, p, p - 1);
   Reverse(R, 0, p - 1);
}
```

![20221029212948](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221029212948.png)

- 2011真题![20221029221239](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221029221239.png)

1. 算法思想:
   1. 按顺序访问AB中较小元素
   2. 当访问指针达到L/2时,返回A或B中元素

2. 代码

```c
int midNumber(int A[], int B[], int L)
{
   for (i = 0; j = 0, l = 0;;)
   {
      if (A[i] > B[j])
      {
         i++;
         tag = 0;
      }
      else
      {
         j++;
         tag = 1;
      }
      l++;
      if (l == L)
      {
         if (tag == 0)
            return A[i];
         if (tag == 1)
            return B[j];
      }
   }
}
```

- 时间复杂度: 对AB依次比较, 为O(n)
- 空间复杂度: O(1)

- 2013真题![20221029224031](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221029224031.png)

1. 构建一个大小为n的数组，用于对每个整数的计数，遍历一遍序列然后再遍历1次这个数组找最大值
   1. 若最大值 > n/2; 输出主元素
   2. 若最大值 < n/2; 输出-1
2. 时间复杂度O(n)，空间复杂度o(n)扣1分

```c
nt mainElement(int A[], int n)
{
   int S[n] = {0};
   for (i = 0; i < n; i++)
      S[A[i]]++;
   int max = S[0];
   int main = 0;
   for (i = 1; i < n; i++)
      if (max < S[i])
      {
         max = S[i];
         main = i;
      }
   if (max > n / 2)
      return main;
   else
      return -1;
}
```

- 2018真题![2018真题](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221031095637.png)

1. 算法思想:
   1. 分配一个用于标记的数组B[n],用来记录A中是否岀现了 1〜n中的正整数
   2. B[0]对应正整数1, B[n-1]对应正整数n,初始化B中全部为0
   3. 由于A中含有n个整数，因此可能返回的值是1〜n+1
      1. 当A中n个数恰好为1〜n时返回n+1
      2. 当数组A中出现了小于等于0或大于n的值时，会导致1〜n中出现空余位置，返回结果必然在1〜n中;

2. 时空
   1. 时间: O(n)
   2. 空间: O(n)

```c
int findMissMin(int A[], int n)
{
   int i, *B; //标记数组
   B = (int *)malloc(sizeof(int) * n);
   menset(B, 0, sizeof(int) * n); //赋初值0
   for (i = 0; i < n; i++)
      if (A[i] > 0 && A[i] <= n)
         B[A[i] - 1] = 1;
   for (i = 0; i < n; i++)
      if (B[i] == 0)
         break;
   return i + 1;
}
```

- 2020真题![20221030230123](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221030230123.png)
  - ![20221030230146](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221030230146.png)

```c
#define INT_MAX 0x7fffffff

int abs_(int a)
{
   if (a < 0)
      return -a;
   else
      return a;
}

bool xls_min(int a, int b, int c)
{
   if (a <= b && a <= c)
      return true;
   else
      return false;
}

int findMinofTrip(int A[], int n, int B[], int m, int C[], int p)
{
   int i = 0, j = 0, k = 0, D_min = INT_MAX, D;
   while (i < n && j < m && k < p && D_min > 0)
   {
      D = abs_(A[i] - B[i]) + abs_(B[j] - C[k]) + abs_(C[k] - A[i]); //计算D
      if (D < D_min)
         D_min = D;

      if (xls_min(A[i], B[j], C[k]))
         i++;
      else if (xls_min(B[j], A[i], C[k]))
         j++;
      else
         k++;
   }
   return D_min;
}
```
