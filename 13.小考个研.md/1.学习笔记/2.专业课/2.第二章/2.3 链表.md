# 2.3.1 链表

- [2.3.1 链表](#231-链表)
  - [2.3.1 单链表的定义](#231-单链表的定义)
  - [2.3.2 单链表上基本操作的实现](#232-单链表上基本操作的实现)
    - [1. 采用头插法建立单链表](#1-采用头插法建立单链表)
    - [2. 采用尾插法建立单链表](#2-采用尾插法建立单链表)
    - [3. 按位序插入 ListInsert(LinkList \&L, int i, ElemType e)](#3-按位序插入-listinsertlinklist-l-int-i-elemtype-e)
    - [4. 后插操作 bool InsertNextNode(LNode \*p, ElemType e)](#4-后插操作-bool-insertnextnodelnode-p-elemtype-e)
    - [5. 前插操作 bool InsertpriorNode(LNode \*p, ElemType e)](#5-前插操作-bool-insertpriornodelnode-p-elemtype-e)
    - [6. 删除结点操作 bool ListDelete(LinkList \&L, int i, ElemType \&e)](#6-删除结点操作-bool-listdeletelinklist-l-int-i-elemtype-e)
    - [7. 按位查找 LNode \*GetElem(LinkList L, int i)](#7-按位查找-lnode-getelemlinklist-l-int-i)
    - [8. 按值查找 LNode \*LocateElem(LinkList L, ElemType e)](#8-按值查找-lnode-locateelemlinklist-l-elemtype-e)
    - [9. 求表的长度 int length(LinkList L)](#9-求表的长度-int-lengthlinklist-l)
  - [2.3.3 双链表](#233-双链表)
  - [2.3.4 循环链表](#234-循环链表)
    - [1. 循环单链表](#1-循环单链表)
    - [2. 循环双链表⭐⭐](#2-循环双链表)
  - [2.3.5 静态链表](#235-静态链表)
  - [2.3.6 顺序表和链表的比较](#236-顺序表和链表的比较)
    - [1. 区别](#1-区别)
    - [2. 如何选取](#2-如何选取)
  - [习题](#习题)
    - [选择题](#选择题)
  - [真题](#真题)

## 2.3.1 单链表的定义

1. 定义
   1. 线性表的**链式存储**又称**单链表**，它是指通过一组任意的存储单元来存储线性中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针

2. 结点结构
   1. data
   2. next

3. 节点描述

    ```c
    typedef struct LNode{   //定义单链表节点类型
        ElemType data;      //数据域
        struct LNode *next; //指针域
    }LNode, *LinkList;

    //等同于

    struct LNode{           //定义单链表节点类型
        ElemType data;      //数据域
        struct LNode *next; //指针域
    };
    typedef struct LNode LNode;
    typedef struct LNode *LinkList;

    //强调这是一个单链表 使用LinkList
    //强调这是一个节点 使用LNode *

    ```

4. 存储结构
   1. 单链表是**非随机存取**的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，**依次查找**;

5. 头节点
   1. ![20221031222017](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221031222017.png)
   2. 为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等信息

6. 引入头节点优点
   1. 由于第一个数据结点的位置被存放在**头结点的指针域**中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。
   2. 无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空), 因此空表和非空表的处理也就得到了统一。

7. 初始化单链表

    ```c
    typedef struct LNode{   //定义单链表节点类型
        ELemType data;      //数据域
        struct LNode *next; //指针域
    }LNode, *LinkList;

    //不带头节点单链表
    bool InitList(LinkList &L){
        L = NULL;   //防止脏数据
        return true;
    }

    //带头节点单链表
    bool InitList(LinkList &L){
        L = (LNode *) malloc(sizeof(LNode)); //分配一个头节点
        if(L == NULL)   //内存不足 分配失败
            return false;
        L->next = NULL; //头节点之后暂时还没有节点
        return true;
    }
    

    void main(){
        LinkList L; //声明一个指向单链表的指针
        InitList(L);
        //...
    }
    ```

## 2.3.2 单链表上基本操作的实现

### 1. 采用头插法建立单链表

- 该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到**当前链表的表头**，即头结点之后

![20221017220834](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221017220834.png)

```c
LinkList List_HeadInsert(LinkList L) //逆向建立单链表
{
    LNode *s;
    int x;
    L = (LinkList)malloc(sizeof(LNode));  //创建头结点
    L->next = NULL;                      //初始空链表
    scanf("%d", x);                      //输入结点的值
    while (x !=9999)                     //输入9999 表示结束
    {
        s = (LNode *)malloc(sizeof(LNode)); //创建新结点
        s->data = x;
        s->next = L->next;
        L->next = s; //将新结点插入中，L为头指针

        s->next = L;
        L=s; 
        //若无头节点,则需将新节点地址复制给头指针L
        
        scanf("%d", &x);
    }
    return L;
}
```

### 2. 采用尾插法建立单链表

- 头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。 若希望**两者次序一致**，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r,使其始终指向当前链表的尾结点

![20221017221350](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221017221350.png)

```c
LinkList List_TailInsert(LinkList &L)
{                                       //建立单链表
   int x;                               //元素类型为整型
   L = (LinkList)malloc(sizeof(LNode)); //建立头结点
   LNode *s, *r = L;                    //为表尾指针
   scanf("%d", &x);
   while (x != 9999) // 输入结点的值
   {                 //输入9999表示结束
      s = (LNode *)malloc(sizeof(LNode));
      s->data = x;
      r->next = s;
      r = s; // r 指向新的表尾结点
      scanf("%d", &x);
   }
   r->next = NULL; //尾结点指针置空
   return L;
}
```

### 3. 按位序插入 ListInsert(LinkList &L, int i, ElemType e)

- 带头节点

```c
bool ListInsert(LinkList &L, int i,ElemType e){
    if(i < 1)
        return false;
    LNode *p = GetElem(L,i-1);
    return InsertNextNode(p,e);
}
```

- 不带头节点

```c
bool ListInsert(LinkList &L, int i,ElemType e){
    if(i < 1)
        return false;

    //新加代码
    if(i==1){
        LNode *s = (LNode *)malloc(sizeof(LNode));
        s->data = e;
        s->next = L;
        L = s;  //头指针指向头结点
        return true;
    }

    LNode *p = GetElem(L,i-1);
    return InsertNextNode(p,e);
}
```

### 4. 后插操作 bool InsertNextNode(LNode *p, ElemType e)

- 在p结点后插入元素e

![20221017230838](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221017230838.png)

```c
bool InsertNextNode(L Node *p, ElemType e){
    if(p==NULL)
        return false;
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if(s==NULL) //内存分配失败
        return false;
    s->data = e;
    
    //关键代码
    s->next = p->next;
    p->next = s;    //将结点s连接p之后

    return true;    //插入成功
}
```

时间复杂度为$O(1)$

### 5. 前插操作 bool InsertpriorNode(LNode *p, ElemType e)

- 在p结点之前插入元素e
  1. 设待插入结点为$*s$, 将$*s$插入到$*p$的前面。我们仍然将$*s$插入到$*p$的后面，然后将p->data与s->data交换，这样既满足了逻辑关系，又能使得时间复杂度为$O(1)$。

```c
bool InsertpriorNode(LNode *p, ElemType e){
    if(p==NULL)
        return false;
    LNode *s = (LNode *)malloc(sizeo(LNode));
    if(s==NULL){
        return false;
    }
    s->next = p->next;  //将新结点s 连到 p之后
    p->next = s;
    s->data = p->data;  
    p->data = e;    //将p中的元素覆盖为e
    return true;
}
```

### 6. 删除结点操作 bool ListDelete(LinkList &L, int i, ElemType &e)

- 删除结点操作是将单链表的第i个结点删除
  1. 先检查删除位置的合法性
  2. 后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除

    ```c
    bool ListDelete(LinkList &L, int i, ElemType &e){
        if(i<1)
            return false;
        p = GetElem(L,i-1); //查找删除位置结点的前驱结点
        
        if(p->next == NULL)
            return false;
        
        //Key Code
        LNode* q = p->next;       //令q指向被删除结点
        e = q->data;              //返回删除元素的值
        p->next = q->next;        //将*q结点从链中断开
        free(q);      

        return true;    //删除成功
    }
    ```

扩展:

1. 要删除某个给定结点$*p$，通常的做法是先从链表的头结点开始顺序找到其前驱结点，然后执行删除操作，算法的时间复杂度为$O(n)$。

2. 其实删除结点$*p$的操作可用删除$*p$的后继结点操作来实现，实质就是将其后继结点的值赋予其自身, 然后删除后继结点, 也能使得时间复杂度为$O(1)$。

### 7. 按位查找 LNode *GetElem(LinkList L, int i)

- 在单链表中从第一个结点出发
  1. 顺指针next域逐个往下搜索，直到找到第i个结点为止
  2. 否则返回最后一个结点指针域null。

注: L所指就是头节点

```c
LNode *GetElem(LinkList L, int i)
{
    //计数，初始为1 
    int j = 1;
    LNode *p = L->next; //第1个结点指针赋给p
    if (i == 0)
        return L; //若i等于0，则返回头结点
    if (i < 1)
        return NULL; //若i无效，则返回NULL
    while (p && j < i)
    { //从第1个结点开始找，查找第i个结点
        p = p->next;
        j++;
    }
    return p; //返回第i个结点的指针，若i大于表长，则返回NULL
}
```

按序号查找操作的时间复杂度为O(n);

### 8. 按值查找 LNode *LocateElem(LinkList L, ElemType e)

- 从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值
  1. 若某结点数据域的值等于给定值$e$,则返回该结点的指针；
  2. 若整个单链表中没有这样的结点，则返回$NULL$

```c
LNode *LocateElem(LinkList L, ElemType e)
{
    LNode *p = L->next;
    while (p != NULL && p->data != e) //第1个结点开始查找data域为e的结点
        p = p->next;
    //找到后返回该结点指针，否则返回NULL
    return p;
}
```

按值查找操作的时间复杂度为$O(n)$。

### 9. 求表的长度 int length(LinkList L)

```c
int length(LinkList L)
{
    int len = 0;
    LNode *p = L;
    while(p->next !=NULL){
        p = p->next;
        len++;
    }    
    return len;
}
```

$O(n)$

## 2.3.3 双链表

![20221018214604](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221018214604.png)

1. 与单链表的联系
   1. 在单链表的结点中增加了一个指向其前驱的prior指针

2. 定义

    ```c
    typedef struct DNode
    {                               //定义双链表结点类型
        ElemType data;              //数据域
        struct DNode *prior, *next; //前驱和后继指针
    } DNode, *DLinkList;
    ```

3. 好处
   1. 单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点(插入、删除操作时)，只能从头开始遍历，访问后继结点的时间复杂度为O(1)，访问前驱结点的时间复杂度为O(n)。
   2. 双链表可以很**方便地找到其前驱结点**，因此，插入、删除操作的时间复杂度仅为O(1)

4. 插入实现
   1. ![20221018214943](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221018214943.png)
   2. s先指后再连前

    ```c
    //keycode
    bool InsertNextNode(DNode *p, Dnode *s)
    {
        s->next = p->next;
        p->next->prior = s;
        s->prior = p;
        p->next = s;
    }

    //whole code
    bool InsertNextNode(DNode *p, Dnode *s)
    {
        if(p==NULL || s==NULL)
            return false;
        s->next = p->next;
        if(p->next!=NULL)
            p->next->prior = s;
        s->prior = p;
        p->next = s;

        return true;
    }
    ```

5. 删除实现
   1. ![20221018215957](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221018215957.png)

```c
//key code
bool deleteNextNode(DNode *p){
    DNode * q = p->next;

    p->next = q->next;
    q->next->prior = p;
    free(q);
}

//whole code
bool deleteNextNode(DNode *p){
    if(p == NULL)
        return false;
    DNode *q = p->next;
    if(q == NULL)
        return false;
    p->next = q->next;
    if(q->next != NULL)
        q->next->prior = p;
    free(q);
    return true;
}
```

## 2.3.4 循环链表

### 1. 循环单链表

![20221018220916](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221018220916.png)

1. 定义
   1. 表中最后一个结点的指针不是NULL,而改为指向头结点,从而整个链表形成一个环

2. 区别于单链表
   1. 循环单链表的判空条件不是头结点的指针是否为空，而是它**是否等于头指针**
   2. 是因为循环单链表是一个"环"，因此在任何一个位置上的插入和删除操作都是等价的，**无须判断是否是表尾**

3. 尾指针
   1. 定义
      1. 有时对单链表常做的操作是在表头和表尾进行的，此时对循环单链表不设头指针而仅设尾指针
   2. 作用
      1. 若设的是尾指针r, r->next即为头指针，对表头与表尾进行操作都只需要$O(1)$的时间复杂度。

### 2. 循环双链表⭐⭐

![20221018220926](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221018220926.png)

1. 定义
   1. 除循环单链表定义外, 头结点的prior指针还要指向表尾结点

2. 判空
   1. 某结点*p为尾结点时, p->next==L;
   2. 当循环双链表为空表时，其头结点的**prior域和next域都等于L**。

## 2.3.5 静态链表

![20221018221059](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221018221059.png)

1. 定义
   1. 静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next

2. 区别于普通链表
   1. 指针是结点的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间

3. 描述

    ```c
    define MaxSize 50 //静态链表最大长度
    typedef struct //静态链表结构类型的定义
    {
        ElemType data; //存储数据元素
        int next;      //下一个元素的数组下标
    } SLinkList[MaxSize];
    ```

## 2.3.6 顺序表和链表的比较

### 1. 区别

1. 存取(读写)方式
   1. 顺序表可以顺序存取，也可以随机存取
   2. 链表只能从表头顺序存取元素。例如在第i个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问i次。

2. 逻辑结构与物理结构
   1. 采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。
   2. 而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过**指针链接**来表示的。

3. 查找、插入和删除操作
   1. 查找
      1. 对于按值查找，顺序表无序时，两者的时间复杂度均为$O(n)$;顺序表有序时，可采用折半查找，此时的时间复杂度为$O(log_2n)$;
      2. 对于按序号查找，顺序表支持随机访问，时间复杂度仅为$O(1)$,而链表的平均时间复杂度为$O(n)$。
   2. 顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。

4. 空间分配
   1. 由于链表的每个结点都带有指针域，故而存储密度不够大。
   2. 顺序存储在静态存储分配情形下，一旦**存储空间装满就不能扩充**，若再加入新元素，则会出现内存溢出，因此需要**预先分配足够大的存储空间**。
      1. 预先分配过大，可能会导致顺序表后部大量闲置;
      2. 预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。
   3. 链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作**灵活、高效**

### 2. 如何选取

1. 基于存储的考虑
   1. 难以估计线性表的长度或存储规模时，不宜采用顺序表;
   2. 链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。

2. 基于运算的考虑
   1. 访问
      1. 在顺序表中按序号访问的时间复杂度为$O(1)$
      2. 而链表中按序号访问的时间复杂度为$O(n)$
      3. 因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。
   2. 插入删除
      1. 在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的;
      2. 在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。

3. 基于环境的考虑
   1. 顺序表容易实现，任何高级语言中都有数组类型;链表的操作是基于指针的，相对来讲，前者实现较为简单，这也是用户考虑的一个因素。

4. 总结
   1. 总之，两种存储结构各有长短，选择哪一种由实际问题的主要因素决定。通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宜选择链式存储

## 习题

⭐=⭐

//要表示一个单链表时, 只需声明一个头指针L, 指向单链表的第一个结点
?why it is not *LinkList

```c
typedef struct LNode{   //定义单链表节点类型
    ELemType data;      //数据域
    struct LNode *next; //指针域
}LNode, *LinkList;

typedef int *pointer;
pointer b;

typedef struct LNode{} *LinkList;
ListList L;

```

### 选择题

⭐

- 04队列使用带尾指针的循环链表原因![20221018224110](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221018224110.png)
  - 💚带尾指针的循环链表, 插入删除的时间复杂度都为$O(1)$
- 01链表用于表示各种逻辑结构的原因![20221018223659](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221018223659.png)
  - 💚顺序存储结构既能随机存取又能顺序存取
- 05查找并删除元素,链表时间复杂度低![20221018224304](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221018224304.png)
- 07建表加排序![20221019224955](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221019224955.png)
  - 💚排序和折半查找
- 12删除最后一个元素2![20221019225556](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221019225556.png)
  - 💚线性表定义

- 08删除最后一个元素时间复杂度![20221019225307](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221019225307.png)
- 18删除插入结点3![20221019225839](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221019225839.png)
- 19各种链表![20221019230328](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221019230328.png)
- 22静态链表的特点![20221019230604](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221019230604.png)
- 23 1个或0个![20221020215546](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221020215546.png)
- 25顺序![20221019231017](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221019231017.png)
- 26特殊情况处理![20221019231155](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221019231155.png)

## 真题

⭐⭐⭐

- 2015![20221103213057](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221103213057.png)
  - 💚空间换时间经典题

![20221103213035](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221103213035.png)

```c
void func(Linklist &L, int n)
{
   LNode * p = L, r;
   
   int *a = new int[n], m;
   memset(a,0,sizeof(int)*n)

   while (p->link != NULL)
   {
      m = p.link.data > 0 ? p.link.data : -p.link.data;
      if (a[m] == 0)
      {            //判断该结点data是否已出现过
         a[m] = 1; //首次出现
         p = p.link;
      }
      else💚💚//重复出现
      {
         r = p->link;
         p = r->link;
         free(r);
      }
   }
   free(p);
}
```

⭐

- 2009![20221101215848](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221101215848.png)

1. 算法思想
   1. 定义两个指针变量p和q初始时均指向头结点的下一个结点(链表的第一个结点)，p指针沿链表移动;
      1. 当p指针移动到第k个结点时，q指针开始与p指针同步移动;
      2. 当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点

```c

typedef int ElemType;

typedef struct LNode
{
   Elemtype data;
   struct LNode *link;

} LNode, *Linklist;

int Search_k(Linklist list, int k)
{
   LNode *p = list->link, *q = list->link; //指针pq指示第一个结点
   int count = 0;
   while (p != NULL)💚
   {
      if (count < k)
         count++;
      else
         q = q->link;
      p = p->link;
   }
   if (count < k)
      return 0;
   else
   {
      cout << q->data;
      return 1;
   }
}
```

- 2012![20221101222913](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221101222913.png)

![20221101223554](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221101223554.png)

```c
LNode *find_first_commom(Linklist str1, Linklist str2)
{
   int len1 = Length(str1);
   int len2 = Length(str2);
   LinkNode *p = str1.next, *q = str2.next;
   for (p = str; len1 > len2; len1--) // 使q指向的链表与p指向的链表等长
      p = p.next;
   for (p = str; len2 > len1; len2--)
      q = q.next;
   while (p->next != null && p->next != q->next)
   {
      p = p->next;
      q = q->next;
   }
   return p->next; //返回共同后缀起始点
}
```

时间复杂度:$O(max(len1,len2))$;

算法时间复杂度是$O(m)$, 空间$O(n)$

- 2019![20221102223407](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221102223407.png)

1. 算法思想
   1. 先找出链表的中间结点，为此设置两个指针p和q,指针p每次走一步，指针q每次走两步，当指针q到达链尾时，指针p正好在链表的中间结点；
   2. 然后将L的后半段结点原地逆置
   3. 从单链表前后两段中依次各取一个结点，按要求重排。

- ![20221102223343](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221102223343.png)
  - //头插法之前💚p->next=NULL
