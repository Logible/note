# 4.1 串的定义和实现

- [4.1 串的定义和实现](#41-串的定义和实现)
  - [4.1.1 串的定义](#411-串的定义)
  - [4.1.2 串的存储结构](#412-串的存储结构)
    - [1.定长顺序存储表示](#1定长顺序存储表示)
    - [2.堆分配存储表示(动态数组实现)](#2堆分配存储表示动态数组实现)
    - [3.块链存储表示](#3块链存储表示)
  - [4.1.3 串的基本操作](#413-串的基本操作)
  - [4.2 串的模式匹配](#42-串的模式匹配)
    - [4.2.1 简单匹配算法](#421-简单匹配算法)
    - [4.2.2 串的模式匹配算法——KMP算法](#422-串的模式匹配算法kmp算法)
  - [习题](#习题)

## 4.1.1 串的定义

- 串(string)是由零个或多个字符组成的有限序列。一般记为

$S='a_1a_2\dots a_n'$(n>=0)

- 术语

1. 子串
   1. 串中任意多个**连续的字符**组成的**子序列**;
2. 主串
   1. **包含**子串的串;
3. 空格串
   1. 由一个或多个空格(空格是特殊字符)组成的串;
4. 位置
   1. 子串在主串中的位置以子串的第一个字符在主串中的位置来表示;
5. 串相等
   1. 当两个串的**长度相等**且**每个对应位置**的字符都相等时，称这两个串是相等的;

## 4.1.2 串的存储结构

### 1.定长顺序存储表示

1. 类似于线性表的顺序存储结构，用一组**地址连续的存储单元**存储串值的字符序列
2. 在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组

```c
#define MAXLEN 255 //预定义最大串长
typedef struct test
{
    char ch[MAXLEN]; //每个分量存储一个字符
    int length;      //串的实际长度
} SString;
```

### 2.堆分配存储表示(动态数组实现)

1. 堆分配存储表示仍然以一组**地址连续的存储单元**存放串值的字符序列
2. 但它们的存储空间是在程序执行过程中**动态分配**得到的

```c
typedef struct
{
    char *ch;   //按串长分配存储区, ch指向串的基地址
    int length; //串的长度
} HString;
```

在C语言中, 存在一个称之为"堆"的自由存储区，并用malloc() 和free() 函数来完成
动态存储管理。

1. 利用malloc()为每个新产生的串分配一块**实际串长所需的存储空间**;
   1. 若分配成功，则返回一个指向起始地址的指针，作为串的基地址，这个串由ch指针来指示;
   2. 若分配失败,则返回NULL. 已分配的空间可用free();释放掉

### 3.块链存储表示

1. 类似于线性表的**链式存储结构**，也可采用链表方式存储串值。

2. 由于串的特殊性(每个元素只有一个字符)
   1. 在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。
   2. 每个结点称为**块**，整个链表称为**块链结构**

## 4.1.3 串的基本操作

前**5**为最小操作子集

1. **StrAssign**(&T, chars): 赋值操作, 把串T赋值为chars;
2. StrCopy(&T, S): 复制操作, 由串S复制得到串T;
3. StrEmpty(S): 判空操作
   1. 若S为空串，则返回TRUE;
   2. 否则返回FALSE;
4. **strCompare**(S，T): 比较操作
   1. 若S > T, 则返回值>0; 若S=T，则返回值=0;
   2. 若S < T, 则返回值<0。
5. **StrLength**(S)∶求串长, 返回串S的元素个数
6. **Concat**(&T, S1, S2): 串联接。用T返回由 S1和 S2联接而成的新串。
7. **SubString**(&Sub, S, pos, len):求子串. 用Sub 返回串S的第pos个字符起长度为len的子串
8. Index(S, T): 定位操作
   1. 若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置
   2. 否则函数值为0。
9. **ClearString**(&S): 清空操作。将S清为空串
10. **DestroyString**(&S):销毁串. 将串S销毁

## 4.2 串的模式匹配

### 4.2.1 简单匹配算法

```c
// S是主串, T是模式串
int Index(SString S, SString T)
{
    int i = 1;
    j = 1;
    while (i <= S.length && j <= T.length)
    {
        if (S.ch[i] == T.ch[j]) //继续比较后继字符
        {
            ++i;
            ++j;
        }
        else
        {
            i = i - j + 2; //指针后退重新开始匹配 i-j让指针回到开始的前一个位置, 加2即到后一个位置
            j = 1;
        }
    }
    if (j > T.length)      //匹配成功,j=length+1;
        return i - T.length;
    else
        return 0;
}
```

最坏时间复杂度O(mn)

### 4.2.2 串的模式匹配算法——KMP算法

1. 术语, 字符串的-
   1. 前缀: 指**除最后一个字符**以外，字符串的所有头部子串;
   2. 后缀: 指除**第一个字符**外，字符串的所有尾部子串
   3. 部分匹配值: 字符串的前缀和后缀的**最长相等前后缀长度**;

2. KMP算法
   1. 根据模式串T, 求出next数组
   2. 利用next数组进行匹配(主串指针不回溯)

   ```c
   // S是主串, T是模式串
   int Index(SString S, SString T, int next[])
   {
      int i = 1;
      j = 1;
      while (i <= S.length && j <= T.length)
      {
         if (j == 0 || S.ch[i] == T.ch[j]) //继续比较后继字符
         {
               ++i;
               ++j;
         }
         else
         {
               j = next[j];
         }
      }
      if (j > T.length) //匹配成功,j=length+1;
         return i - T.length;
      else
         return 0;
   }
   ```

   最坏时间复杂度是O(m+n);

   其中, 求next数组时间复杂度是O(m), 模式匹配最坏时间复杂度是0(n)

3. 部分匹配值Partial Match (next[]求法)
   1. next[1] = 0;
   2. next[2] = 1;
   3. 其它next: 在不匹配的位置前, 划上分界线:
      1. 模式串一步步往后退
         1. 直到分界线之前**能对上**;
         2. 或模式串完全**跨过分界线**为止;
      2. 此时j指向哪儿, next数组值就是多少
   4. 例子
      1. ababaa
         1. 011234
      2. google
         1. 011121

## 习题

⭐⭐

06

-1开头就整体加1, -1时是考虑串的位序是从0开始的
