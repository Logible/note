# 2.图的存储和基本操作

考试常见要点:

![20220819011132](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220819011132.png)

- [2.图的存储和基本操作](#2图的存储和基本操作)
  - [6.2.1 邻接矩阵法](#621-邻接矩阵法)

## 6.2.1 邻接矩阵法

1. 定义
   1. 邻接矩阵存储，是指
      1. 用一个一维数组存储图中**顶点的信息**
      2. 用一个二维数组存储图中**边的信息**(即各顶点之间的邻接关系
      3. 存储顶点之间邻接关系的二维数组称为**邻接矩阵**

- 结点数为n的图$G=(V, E)$的邻接矩阵A是$n × n$的。将G的顶点编号为$v_1,v_2,...,v_n$. 若$(v_i,v_j) \in E$, 则$A[i][j]=1$, 否则$A[i][j]=0$

$$A[i][j]\begin{cases}
1 & 若(v_i,v_j)或<v_i,v_j>是E(G)中的边 \\
0 & 若(v_i,v_j)或<v_i,v_j>不是E(G)中的边
\end{cases}$$

- 对于带权图而言,若顶点$v_i$和$v_j$之间有边相连,则邻接矩阵中对应项存放着该边对应的权值，若顶点$v_i$和$v_j$不相连，则用$\infty$来代表这两个顶点之间不存在边:

$$A[i][j]\begin{cases}
w_{ij} & 若(v_i,v_j)或<v_i,v_j>是E(G)中的边 \\
0 or \infty & 若(v_i,v_j)或<v_i,v_j>不是E(G)中的边
\end{cases}$$

- 图的存储结构定义如下

```c
#define MaxVertexNum 100 //顶点数目的最大值
typedef char VertexType; //顶点的数据类型
//带权图中边上权值的数据类型
typedef int EdgeType;
typedef struct
{
   VertexType Vex[MaxVertexNum];              //顶点表
   EdgeType Edge[MaxVertexNum][MaxVertexNum]; //邻接矩阵，边表
   int vexnum, arcnum;                        //图的当前顶点数和弧数
} MGraph;
```

Tips:

1. 在简单应用中，可直接用**二维数组**作为图的邻接矩阵(顶点信息等均可省略
2. 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可采用值为**0和1**的枚举类型
3. 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用**压缩存储**
4. 邻接矩阵表示法的空间复杂度为$O(n^2)$,其中n为图的顶点数$|V|$

图的邻接矩阵存储表示法具有以下特点∶

1. 无向图的邻接矩阵一定是一个**对称矩阵**(并且唯一)。因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。
2. 对于无向图
   1. 邻接矩阵的第i行(或第i列)非零元素(或非oo元素)的个数正好是顶点i的度TD(v)。
3. 对于有向图
   1. 邻接矩阵的第i行非零元素(或非o元素)的个数正好是顶点i的出度OD(v);
   2. 第i列非零元素(或非o元素)的个数正好是顶点i的入度ID(v);
4. 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的**时间代价很大**。
5. **稠密图**适合使用邻接矩阵的存储表示
6. 设图G的邻接矩阵为A, $A^n$的元素$A^n[i][j]$等于由顶点i到顶点j的长度为n的路径的数目。
