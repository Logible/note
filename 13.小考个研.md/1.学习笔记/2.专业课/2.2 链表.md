# 链表

- [链表](#链表)
  - [单链表的定义](#单链表的定义)
  - [单链表上基本操作的实现](#单链表上基本操作的实现)
  - [双链表](#双链表)
  - [循环链表](#循环链表)
  - [静态链表](#静态链表)
  - [顺序表和链表的比较](#顺序表和链表的比较)

## 单链表的定义

⭐=⭐

//要表示一个单链表时, 只需声明一个头指针L, 指向单链表的第一个结点
?why it is not *ListList

```c
typedef struct LNode{   //定义单链表节点类型
    ELemType data;      //数据域
    struct LNode *next; //指针域
}LNode, *LinkList;

typedef int *pointer;
pointer b;

typedef struct LNode{} *LinkList;
ListList L;

```

1. 定义
   1. 线性表的**链式存储**又称**单链表**，它是指通过一组任意的存储单元来存储线性中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针

2. 结点结构
   1. data
   2. next

3. 节点描述

    ```c
    typedef struct LNode{   //定义单链表节点类型
        ELemType data;      //数据域
        struct LNode *next; //指针域
    }LNode, *LinkList;

    //等同于

    typedef struct LNode{   //定义单链表节点类型
        ELemType data;      //数据域
        struct LNode *next; //指针域
    };
    typedef struct LNode LNode;
    typedef struct LNode *LinkList;

    //强调这是一个单链表 使用LinkList
    //强调这是一个节点 使用LNode *

    ```

4. 存储结构
   1. 单链表是**非随机存取**的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，**依次查找**;

5. 头节点
   1. 为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等信息

6. 引入头节点优点
   1. 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。
   2. 无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空), 因此空表和非空表的处理也就得到了统一。

7. 初始化单链表

    ```c
    typedef struct LNode{   //定义单链表节点类型
        ELemType data;      //数据域
        struct LNode *next; //指针域
    }LNode, *LinkList;

    //不带头节点单链表
    bool InitList(LinkList &L){
        L = NULL;   //防止脏数据
        return true;
    }

    //带头节点单链表
    bool InitList(LinkList &L){
        L = (LNode *) malloc(sizeof(LNode)); //分配一个头节点
        if(L == NULL)   //内存不足 分配失败
            return false;
        L->next = NULL; //头节点之后暂时还没有节点
        return true;
    }
    

    void test(){
        LinkList L; //声明一个指向单链表的指针
        InitList(L);
        //...
    }
    ```

## 单链表上基本操作的实现

1. 按位序插入 ListInsert(LinkList &L, int i, ElemType e)

    带头节点

    ```c
    bool ListInsert(LinkList &L, int i, ElemType e){
        if(i < 1)
            return false;
        LNode *p = GetElem(L,i-1);
        return InsertNextNode(p,e);
    }
    ```

    不带头节点

    ```c
    bool ListInsert(LinkList &L, int i, ElemType e){
        if(i < 1)
            return false;

        //新加代码
        if(i==1){
            LNode *s = (LNode *)malloc(sizeof(LNode));
            s->data = e;
            s->next = L;
            L = s;  //头指针指向头结点
            return true;
        }

        LNode *p = GetElem(L,i-1);
        return InsertNextNode(p,e);
    }
    ```

2. 后插操作 bool InsertNextNode(L Node *p, ElemType e)

    在p结点后插入元素e

    ```c
    bool InsertNextNode(L Node *p, ElemType e){
        if(p==NULL)
            return false;
        LNode *s = (LNode *)malloc(sizeof(LNode));

        if(s==NULL) //内存分配失败
            return false;
        
        s->data = e;
        s->next = p->next;
        p->next = s;    //将结点s连接p之后
        return ture;    //插入成功}
    ```

3. 前插操作 bool InsertPriorNode(LNode *p, ElemType e)

    在p结点之前插入元素e

    ```c
    bool InsertPriorNode(LNode *p, ElemType e){
        if(p==NULL)
            return false;
        LNode *s = (LNode *)malloc(sizeof(LNode));
        if(s==NULL){
            return false;
        }

        s->next = p->next;  //将新结点s 连到 p 之后
        p->next = s;
        s->data = p->data;  //将p中的元素覆盖为e
        p->data = e;
        return true;
    }
    ```

4. 删除结点操作 bool ListDelete(LinkList &L, int i, ElemType &e)

    删除第i个结点

    ```c
    bool ListDelete(LinkList &L, int i, ElemType &e){
        if(i<1)
            return false;
        p = GetElem(L,i-1); //查找删除位置结点的前驱结点
        
        if(p->next == NULL)
            return false;
        
        //Key Code
        LNode* q = p ->next;       //令q指向被删除结点
        e =  q->data;              //返回删除元素的值
        p->next = q->next; //将*q结点从链中断开
        free(q);      

        return true;    //删除成功
    }
    ```

5. 按位查找 LNode *GetElem(LinkList L, int i)

    ```c
    LNode *GetElem(LinkList L, int i)
    {
        //计数，初始为1 int j=1;
        LNode *p = L->next; //第1个结点指针赋给p
        if (i == 0)
            return L; //若i等于0，则返回头结点
        if (i < 1)
            return NULL; //若i无效，则返回NULL return NUL;
        while (p && j < i)
        { //从第1个结点开始找，查找第i个结点
            p = p->next;
            3 ++;
            return p; //返回第i个结点的指针，若i大于表长，则返回NULL
        }
    }
    ```

    按序号查找操作的时间复杂度为O(n);

6. 按值查找 LNode *LocateElem(LinkList L, ElemType e)

    ```c
    LNode *LocateElem(LinkList L, ElemType e)
    {
        LNode *p = L->next;
        while (p != NULL && p->data != e) //从第1个结点开始查找data域为e的结点
            p = p->next;
        //找到后返回该结点指针，否则返回NULL
        return p;
    }
    ```

    O(n)

7. 求表的长度 int length(LinkList L)

    ```c
    int length(LinkList L)
    {
        int len = 0;
        LNode *p = L;
        while(p->next !=NULL){
            p = p->next;
            len++;
        }    
        return len;
    }
    ```

    O(n)

8. 单链表的建立
   1. 头插法 LinkList List_HeadInsert(LinkList &L)

        ```c
        LinkList List_HeadInsert(LinkList &L) //逆向建立单链表
        {
            LNode *s;
            int x;
            L = (LinkList)malloc(sizeof(LNode)); //创建头结点
            L->next = NULL;                      //初始为空链表
            scanf("%d", &x);                     //输入结点的值
            while (x != 9999)                    //输入 9999 表示结束
            {
                s = (LNode *)malloc(sizeof(LNode)); //创建新结点
                s->data = x;
                s->next = L->next;
                L->next = s; //将新结点插入表中，L为头指针
                scanf("%d", &x);
            }
            return L;
        }
        ```

   2. 尾插法 List_TailInsert(LinkList &L)

        ```c
        LinkList List_TailInsert(LinkList &L)
        {                                        //正向建立单链表
            int x;                               //设元素类型为整型
            L = (LinkList)malloc(sizeof(LNode)); //建立头结点
            LNode *s, *r = L;                    // r为表尾指针
            scanf("d", 5x);
            while (x != 9999) // 输入结点的值 
            { //输入9999表示结束
                s = (LNode *)malloc(sizeof(LNode));
                s->data = x;
                r->next = s;
                r = s; // r 指向新的表尾结点
                scanf("%d", &x);
            }
            r->next = NULL; //尾结点指针置空
            return L;
        }
        ```

## 双链表

## 循环链表

## 静态链表

## 顺序表和链表的比较
