# 链表

- [链表](#链表)
  - [单链表的定义](#单链表的定义)
  - [单链表上基本操作的实现](#单链表上基本操作的实现)
  - [双链表](#双链表)
  - [循环链表](#循环链表)
  - [静态链表](#静态链表)
  - [顺序表和链表的比较](#顺序表和链表的比较)

## 单链表的定义

1. 定义
   1. 线性表的**链式存储**又称**单链表**，它是指通过一组任意的存储单元来存储线性中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针

2. 结点结构
   1. data
   2. next

3. 节点描述

    ```c
    typedef struct LNode{   //定义单链表节点类型
        ELemType data;      //数据域
        struct LNode *next; //指针域
    }LNode, *LinkList;

    //等同于

    typedef struct LNode{   //定义单链表节点类型
        ELemType data;      //数据域
        struct LNode *next; //指针域
    };
    typedef struct LNode LNode;
    typedef struct LNode *LinkList;

    //强调这是一个单链表 使用LinkList
    //强调这是一个节点 使用LNode *

    //要表示一个单链表时, 只需声明一个头指针L, 指向单链表的第一个结点
    LNode *L;
    ListList L;
    ```

4. 存储结构
   1. 单链表是**非随机存取**的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，**依次查找**;

5. 头节点
   1. 为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等信息

6. 引入头节点优点
   1. 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。
   2. 无论链表是否为空，其头指针都指向头结点的非空指针(空表中头结点的指针域为空), 因此空表和非空表的处理也就得到了统一。

7. 初始化单链表

    ```c
    typedef struct LNode{   //定义单链表节点类型
        ELemType data;      //数据域
        struct LNode *next; //指针域
    }LNode, *LinkList;

    //不带头节点单链表
    bool InitList(LinkList &L){
        L = NULL;   //防止脏数据
        return true;
    }

    //带头节点单链表
    bool InitList(LinkList &L){
        L = (Lnode *) malloc(sizeof(LNode)); //分配一个头节点
        if(L == NULL)   //内存不足 分配失败
            return false;
        L->next = NULL; //头节点之后暂时还没有节点
        return true;
    }
    

    void test(){
        LinkList L; //声明一个指向单链表的指针
        InitList(L);
        //...
    }
    ```

## 单链表上基本操作的实现

1. 按位序插入

    带头节点

    ```c
    bool ListInsert(LinkList &L, int i, ElemType e){
        if(i < 1)
            return false;
        LNode *p;   //指针p指向当前扫描到的结点
        int j = 0;  //当前p指向的是第几个结点
        p = L;      //L指向头结点
        while(p!=NULL && j < i-1){ //循环找到第 i-1个结点
            p = p->next;
            j++;
        }
        return InsertNextNode(p,e);

    }
    ```

    不带头节点

    ```c
    bool ListInsert(LinkList &L, int i, ElemType e){
        if(i < 1)
            return false;

        //新加代码
        if(i==1){
            LNode *s = (LNode *)malloc(sizeof(LNode);
            s->data = e;
            s->next = L;
            L = s;  //头指针指向头结点
            return true;
        }

        LNode *p;   //指针p指向当前扫描到的结点
        int j = 1;  //当前p指向的是第几个结点
        p = L;      //L指向头结点
        while(p!=NULL && j < i-1){ //循环找到第 i-1个结点
            p = p->next;
            j++;
        }
        
        return InsertNextNode(p,e);
    }
    ```

2. 后插操作

    在p结点后插入元素e

    ```c
    bool InsertNextNode(L Node *p, ElemType e){
        if(p==NULL)
            return false;
        LNode *s = (LNode *)malloc(sizeof(LNode));

        if(s==NULL) //内存分配失败
            return false;
        
        s->data = e;
        s->next = p->next;
        p->next = s;    //将结点s连接p之后
        return ture;    //插入成功}
    ```

3. 前插操作

    在p结点之前插入元素e

    ```c
    bool InsertPriorNode(LNode *p, ElemType e){
        if(p==NULL)
            return false;
        LNode *s = (LNode *)malloc(sizeof(LNode));
        if(s==NULL){
            return false;
        }

        s->next = p->next;  //将新结点s 连到 p 之后
        p->next = s;
        s->data = p->data;  //将p中的元素覆盖为e
        p->data = e;
        return true;
    }
    ```

4. 删除结点操作

删除第i个结点

```c
bool ListDelete(LinkList &L, int i, ElemType &e){
    if(i<1)
        return false;
    p = GetElem(L,i-1); //查找删除位置结点的前驱结点
    if(p->next == NULL)
        return false;
    
    //Key Code
    LNode* q = p ->next;       //令q指向被删除结点
    e =  q->data;              //返回删除元素的值
    p->next = q->next; //将*q结点从链中断开
    free(q);      

    return true;    //删除成功
}
```

## 双链表

## 循环链表

## 静态链表

## 顺序表和链表的比较
