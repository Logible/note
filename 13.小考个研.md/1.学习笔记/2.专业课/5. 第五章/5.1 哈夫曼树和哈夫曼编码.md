# 5.1 哈夫曼树和哈夫曼编码

## 哈夫曼树和哈夫曼编码

- [5.1 哈夫曼树和哈夫曼编码](#51-哈夫曼树和哈夫曼编码)
  - [哈夫曼树和哈夫曼编码](#哈夫曼树和哈夫曼编码)
    - [1.哈夫曼树的定义](#1哈夫曼树的定义)
    - [2.哈夫曼树的构造](#2哈夫曼树的构造)
    - [3.哈夫曼编码](#3哈夫曼编码)
  - [习题](#习题)

### 1.哈夫曼树的定义

![20220816231130](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220816231130.png)

1. 定义
   1. 带权路径长度(WPL)最小的二叉树称为哈夫曼树, 也称**最优二叉树**

2. 权: 树中结点常常被赋予一个**表示某种意义的数值**

3. 带权路径长度
   1. 从树的根到任意结点的**路径长度**(经过的边数)与该结点上**权值**的**乘积**

4. 带权路径长度:
    1. 树中所有叶结点的**带权路径长度之和**, 记为
       1. $WPL = \sum_{i = 1}^{n} w_il_i$

### 2.哈夫曼树的构造

- 给定n个权值分别为$w_i, w_2,…,w_n$的结点，构造哈夫曼树的算法描述如下:

1. 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F;
2. 构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和;
3. 从F中删除刚才选出的两棵树，同时将新得到的树加入F中;
4. 重复步骤2和3, 直至F中只剩下一棵树为止;

- 从上述构造过程中可以看岀哈夫曼树具有如下特点：

1. 每个初始结点最终都成为叶结点，且**权值越小**的结点到根结点的路径长度**越大**
2. 构造过程中共**新建了n-1个结点**(双分支结点)
   1. 因此哈夫曼树的结点总数为**2n-1**
   2. 叶子结点(哈夫曼编码)为n
3. 每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中**不存在度为1的结点**

### 3.哈夫曼编码

1. 由哈夫曼树得到哈夫曼编码:
   1. 首先，将每个出现的字符当作一个独立的结点,其权值为它出现的频度(或次数)，构造出对应的哈夫曼树
   2. 将字符的编码解释为从根至该字符的路径上边标记的序列
      1. 边标记为0表示"转向左孩子"
      2. 边标记为1表示"转向右孩子"

2. 固定长度编码
   1. 在数据通信中，对每个字符用**相等长度**的二进制位表示
3. 可变长度编码
   1. 允许对不同字符用**不等长**的二进制位表示
4. 前级编码
   1. 没有一个编码是**另一个**编码的**前缀**

5. Tip:
   1. 0和1究竟是表示左子树还是右子树没有明确规定;
   2. 左、右孩子结点的顺序是任意的， 所以构造出的**哈夫曼树并不唯一**，但各哈夫曼树的带权路径长度**WPL相同且为最优**;
   3. 此外，如有若干**权值相同**的结点，则构造出的哈夫曼树**更可能不同**，但WPL必然相同且是**最优**的;

## 习题

1. 哈夫曼编码长度不超过n, 则树高为n+1

⭐⭐⭐

真题未做

⭐

05 知道总结点, 求叶子结点![20220817002937](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220817002937.png)

04 已知前面编码, 求后序编码![20220817003026](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220817003026.png)
