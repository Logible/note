# 树

- [树](#树)
  - [5.4.1 树的存储结构](#541-树的存储结构)
    - [1.双亲表示法](#1双亲表示法)
    - [2.孩子表示法](#2孩子表示法)
    - [3.孩子兄弟表示法](#3孩子兄弟表示法)
  - [5.4.2 树、森林与二叉树的转换](#542-树森林与二叉树的转换)
    - [1.树转换成二叉树的画法](#1树转换成二叉树的画法)
    - [2. 森林转为二叉树](#2-森林转为二叉树)
    - [3. 二叉树转换为森林](#3-二叉树转换为森林)
  - [5.4.3树和森林的遍历](#543树和森林的遍历)
    - [1.树的遍历](#1树的遍历)
    - [2.森林的遍历](#2森林的遍历)
  - [习题](#习题)
  - [应用题](#应用题)

## 5.4.1 树的存储结构

### 1.双亲表示法

![双亲表示法](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220816113313.png)

1. 定义
   1. 这种存储方式采用**一组连续空间**来存储每个结点，同时在每个结点中增设一个**伪指针**，指示其双亲结点在数组中的位置

2. 存储结构描述

    ```c
    #define MAX_TREE_SIZE 100 //树中最多结点树

    typedef struct
    {
        ElemType data; //数据元素
        int parent;    //双亲位置域
    } PTNode;

   //树的类型定义
    typedef struct 
    {
        PTNode nodes[MAX_TREE_SIZE]; //双亲表示
        int n;                       //结点数
    } PTree;
    ```

3. 树的顺序存储结构与二叉树的顺序存储结构区别
   1. 在树的顺序存储结构中
      1. 数组下标代表结点的编号
      2. 下标中**所存的内容**指示了结点之间的关系
   2. 而在二叉树的顺序存储结构中，数组下标既代表了
      1. 结点的编号
      2. 又**指示了**二叉树中各结点之间的关系
   3. 当然，二叉树属于树
      1. 因此二叉树都可以用树的存储结构来存储
      2. 但树却不都能用二叉树的存储结构来存储

### 2.孩子表示法

![孩子表示法](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815220651.png)

1. 定义
   1. 孩子表示法是将每个结点的孩子结点都用**单链表链接**起来形成一个**线性结构**，此时 n个结点就有n个孩子链表(叶子结点的孩子链表为空表).

2. 特点
   1. 这种存储方式**寻找子女**的操作非常**直接**
   2. 而**寻找双亲**的操作需要**遍历n个结点**中孩子链表指针域所指向的n个孩子链表。

### 3.孩子兄弟表示法

![孩子兄弟表示法](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220816113653.png)

1. 定义
   1. 孩子兄弟表示法又称**二叉树表示法**，即以**二叉链表**作为树的存储结构。
   2. 孩子兄弟表示法使每个结点包括三部分内容:
      1. 结点值(中间结点)
      2. ()指向结点**第一个孩子结点的指针**
      3. 及指向结点**下一个兄弟结点的指针**(沿此域可以找到结点的所有兄弟结点

```c
typedef struct CSNode
{
   ElemType data;
   struct CSNode *firstchild, *nextsibling;
} CSNode, *CSTree;
```

## 5.4.2 树、森林与二叉树的转换

由于二叉树和树都可以用二叉链表作为存储结构

因此以二叉链表作为媒介可以导出树与二叉树的一个对应关系

**即给定一棵树**，可以找到唯一的一棵**二叉树**与之对应。从物理结构上看， 它们的二叉链表是相同的，只是解释不同而

![20220815233039](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815233039.png)

### 1.树转换成二叉树的画法

1. 在兄弟结点之间加一连线;
2. 对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉;
3. 以树根为轴心，顺时针旋转45°

Example:![20220815223630](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815223630.png)

### 2. 森林转为二叉树

将森林转换为二叉树的规则与树类似

1. 将森林中的每棵树转换成相应的二叉树;
2. 每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线
3. 以第一棵树的根为轴心顺时针旋转45°

### 3. 二叉树转换为森林

二叉树转换为森林的规则

1. 若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开
2. 二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树,应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止
3. 最后再将每棵二叉树依次转换成树，就得到了原森林

## 5.4.3树和森林的遍历

### 1.树的遍历

- 深度优先遍历

1. 先根遍历
   1. 若树非空, 先访问**根结点**，再依次遍历根结点的**每棵子树**，遍历子树时遵循先根后子树的规则
   2. 其遍历序列与这棵树**相应二叉树**的先序序列相同

2. 后根遍历
   1. 若树非空, 先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。
   2. 其遍历序列与这棵树**相应二叉树**的中序序列相同

- Example![Example](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815235717.png)

  - 先根: $ABEKFCGDHIJ$
  - 后根: $KEFBGCHIJDA$

- 广度优先遍历

1. 层次遍历
   1. 与二叉树的层次遍历思想基本相同，即按层序依次访问各结点

### 2.森林的遍历

1. 先序遍历森林, 若森林为非空，则按如下规则进行遍历:
   1. 访问森林中第一棵树的根结点
   2. 先序遍历第一棵树中根结点的子树森林
   3. 先序遍历除去第一棵树之后剩余的树构成的森林

2. 中序遍历森林。森林为非空时，按如下规则进行遍历:
   1. 中序遍历森林中第一棵树的根结点的子树森林
   2. 访问第一棵树的根结点
   3. 中序遍历除去第一棵树之后剩余的树构成的森林

3. 先序遍历森林等同于依次对各个树进行**先根遍历**
4. 中序遍历森林等同于依次对各个树进行**后根遍历**

5. 若考到代码题, 容易解法为
   1. 先将森林化为二叉树
   2. 再用二叉树进行遍历

- Example![Example](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220816000602.png)
  - 先序遍历: $BEKLFCGDHMIJ$
  - 中序遍历: $KLEFBGCMHIJD$

树|森林|二叉树|
--|--|--|
先根遍历|先序遍历(先根遍历)|先序遍历|
后根遍历|中序遍历(中根遍历)|中序遍历|

## 习题

⭐

06 非终端结点在转换后, 最后一个孩子的右指针也为空![20220818225248](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220818225248.png)

01 满二叉树才具有性质3![20220818223430](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220818223430.png)

## 应用题

⭐⭐⭐

- 01树的先根遍历和后根遍历对应![20221209215404](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221209215404.png)
- 04求森林叶子结点![20221209221927](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221209221927.png)
- 05递归算法求孩子兄弟表示法的森林的高度![20221209222640](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221209222640.png)

⭐

- 2016[真题]![20220828231000](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220828231000.png)
  - 💚k个啊

利用性质 结点数的边数加1

![20221104221235](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221104221235.png)
