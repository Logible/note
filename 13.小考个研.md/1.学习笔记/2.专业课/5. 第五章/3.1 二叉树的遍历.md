# 二叉树的遍历

- [二叉树的遍历](#二叉树的遍历)
  - [1.先序遍历](#1先序遍历)
  - [2.中序遍历](#2中序遍历)
  - [3.后序遍历](#3后序遍历)
  - [5.层次遍历](#5层次遍历)
  - [6.由遍历序列构造二叉树](#6由遍历序列构造二叉树)
    - [6.1 先序遍历和中序遍历确定一颗二叉树](#61-先序遍历和中序遍历确定一颗二叉树)
    - [6.2 后序遍历和中序遍历确定一颗二叉树](#62-后序遍历和中序遍历确定一颗二叉树)
    - [6.3 层次遍历和中序遍历确定一颗二叉树](#63-层次遍历和中序遍历确定一颗二叉树)

二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次

## 1.先序遍历

先序遍历(PreOrder)的操作过程如下。

1. 若二叉树为空，则什么也不做;
   1. 否则
      1. 访问根结点;
      2. 先序遍历左子树;
      3. 先序遍历右子树;

```c
void PreOrder(BiTree T)
{
    if (T != NULL)
    {
        visit(T);            //访问根节点
        PreOrder(T->lchild); //递归遍历左子树
        PreOrder(T->rchild); //递归遍历右子树
    }
}
```

## 2.中序遍历

先序遍历(PreOrder)的操作过程如下。

1. 若二叉树为空，则什么也不做;
   1. 否则
      1. 先序遍历左子树;
      2. 访问根结点;
      3. 先序遍历右子树;

```c
void InOrder(BiTree T)
{
    if (T != NULL)
    {
        InOrder(T->lchild); //递归遍历左子树
        visit(T);           //访问根节点
        InOrder(T->rchild); //递归遍历右子树
    }
}
```

## 3.后序遍历

1. 若二叉树为空，则什么也不做;
   1. 否则
      1. 先序遍历左子树;
      2. 先序遍历右子树;
      3. 访问根结点;

```c
void PostOrder(BiTree T)
{
    if (T != NULL)
    {
        PostOrder(T->lchild); //递归遍历左子树
        PostOrder(T->rchild); //递归遍历右子树
        visit(T);             //访问根节点
    }
}
```

## 5.层次遍历

次遍历二叉树的过程的简单描述如下

1. 根结点入队;
2. 若队空（所有结点都已处理完毕），则结束遍历, 否则重复3操作。
3. 队列中第一个结点出队，并访问之。若其有左孩子,则将左孩子入队；若其有右孩子，则将右孩子入队，返回2。

```c
void LevelOrder(BiTree T)
{
    InitQueue(Q); //初始化辅助队列
    BiTree p;
    EnQueue(Q, T); //将根结点入队
    while (!isEmpty(Q))
    {
        DeQueue(Q, p); //队头结点出队
        visit(p);
        if (p->lchild != NULL)
            EnQueue(Q, p->lchild); //左子树不空,则左子树根结点入队
        if (p->rchild != NULL)
            EnQueue(Q, r->lchild); //右子树不空,则右子树根结点入队
    }
}
```

- Example:

![20220812205628](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220812205628.png)

## 6.由遍历序列构造二叉树

思路:

1. 非中序提供根节点位置
2. 中序提供结点的相对位置

### 6.1 先序遍历和中序遍历确定一颗二叉树

1. 在先序遍历序列中，第一个结点一定是二叉树的根结点;
2. 而在中序遍历中，根结点必然将中序序列分割成两个子序列
   1. 前一个子序列是根结点的左子树的中序序列
   2. 后一个子序列是根结点的右子树的中序序列。

3. 根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。
   1. 在先序序列中
      1. 左子序列的第一个结点是左子树的根结点
      2. 右子序列的第一个结点是右子树的根结点

4. 如此递归地进行下去，便能唯一地确定这棵二叉树

Example:

1. 先序序列 ABCDEFGHI
2. 中序序列 BCAEDGHFI

![先序加中序](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220812004008.png)

### 6.2 后序遍历和中序遍历确定一颗二叉树

1. 在后序遍历序列中，**最后一个结点**一定是二叉树的根结点;
2. 而在中序遍历中，根结点必然将中序序列分割成两个子序列
   1. 前一个子序列是根结点的左子树的中序序列
   2. 后一个子序列是根结点的右子树的中序序列。

3. 根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。
   1. 在先序序列中
      1. 左子序列的**最后一个结点**是左子树的根结点
      2. 右子序列的**最后一个结点**是右子树的根结点

4. 如此递归地进行下去，便能唯一地确定这棵二叉树

Example:

1. 后序序列 EFAHCIGBD
2. 中序序列 EAFDHCBGI

![后序+中序](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220813120041.png)

### 6.3 层次遍历和中序遍历确定一颗二叉树

1. 在层次遍历序列中，遍历序列是 根节点, 左子树, 右子树
2. 而在中序遍历中，根结点必然将中序序列分割成两个子序列
   1. 前一个子序列是根结点的左子树的中序序列
   2. 后一个子序列是根结点的右子树的中序序列。

3. 如此递归地进行下去，便能唯一地确定这棵二叉树

Example:

1. 层次遍历 DABEFCGHI
2. 中序序列 EAFDHCBGI

![20220812214758](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220812214758.png)
