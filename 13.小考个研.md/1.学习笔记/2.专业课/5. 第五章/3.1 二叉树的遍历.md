# 二叉树的遍历

- [二叉树的遍历](#二叉树的遍历)
  - [1.先序遍历](#1先序遍历)
  - [2.中序遍历](#2中序遍历)
  - [3.后序遍历](#3后序遍历)
  - [二叉树算数表达式的遍历](#二叉树算数表达式的遍历)
  - [5.层次遍历](#5层次遍历)
  - [6.由遍历序列构造二叉树](#6由遍历序列构造二叉树)
    - [6.1 先序遍历和中序遍历确定一颗二叉树](#61-先序遍历和中序遍历确定一颗二叉树)
    - [6.2 后序遍历和中序遍历确定一颗二叉树](#62-后序遍历和中序遍历确定一颗二叉树)
    - [6.3 层次遍历和中序遍历确定一颗二叉树](#63-层次遍历和中序遍历确定一颗二叉树)
  - [选择题done](#选择题done)

二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次

## 1.先序遍历

先序遍历(PreOrder)的操作过程如下。

1. 若二叉树为空，则什么也不做;
   1. 否则
      1. 访问根结点;
      2. 先序遍历左子树;
      3. 先序遍历右子树;

```c
void PreOrder(BiTree T)
{
    if (T != NULL)
    {
        visit(T);            //访问根节点
        PreOrder(T->lchild); //递归遍历左子树
        PreOrder(T->rchild); //递归遍历右子树
    }
}
```

## 2.中序遍历

先序遍历(PreOrder)的操作过程如下。

1. 若二叉树为空，则什么也不做;
   1. 否则
      1. 先序遍历左子树;
      2. 访问根结点;
      3. 先序遍历右子树;

```c
void InOrder(BiTree T)
{
    if (T != NULL)
    {
        InOrder(T->lchild); //递归遍历左子树
        visit(T);           //访问根节点
        InOrder(T->rchild); //递归遍历右子树
    }
}
```

## 3.后序遍历

1. 若二叉树为空，则什么也不做;
   1. 否则
      1. 先序遍历左子树;
      2. 先序遍历右子树;
      3. 访问根结点;

```c
void PostOrder(BiTree T)
{
    if (T != NULL)
    {
        PostOrder(T->lchild); //递归遍历左子树
        PostOrder(T->rchild); //递归遍历右子树
        visit(T);             //访问根节点
    }
}
```

## 二叉树算数表达式的遍历

![20220814224630](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220814224630.png)

## 5.层次遍历

次遍历二叉树的过程的简单描述如下

1. 根结点入队;
2. 若队空（所有结点都已处理完毕），则结束遍历, 否则重复3操作。
3. 队列中第一个结点出队，并访问之。若其有左孩子,则将左孩子入队；若其有右孩子，则将右孩子入队，返回2。

```c
void LevelOrder(BiTree T)
{
    InitQueue(Q); //初始化辅助队列
    BiTree p;
    EnQueue(Q, T); //将根结点入队
    while (!isEmpty(Q))
    {
        DeQueue(Q, p); //队头结点出队
        visit(p);
        if (p->lchild != NULL)
            EnQueue(Q, p->lchild); //左子树不空,则左子树根结点入队
        if (p->rchild != NULL)
            EnQueue(Q, r->lchild); //右子树不空,则右子树根结点入队
    }
}
```

- Example:

![20220812205628](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220812205628.png)

## 6.由遍历序列构造二叉树

思路:

1. 非中序提供**根节点位置**
2. 中序提供**结点的相对位置**

### 6.1 先序遍历和中序遍历确定一颗二叉树

1. 在先序遍历序列中，**第一个结点**一定是二叉树的**根结点**;
2. 而在中序遍历中，根结点必然将中序序列分割成两个子序列
   1. 前一个子序列是根结点的左子树的中序序列
   2. 后一个子序列是根结点的右子树的中序序列。

3. 根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。
   1. 在先序序列中
      1. 左子序列的第一个结点是左子树的根结点
      2. 右子序列的第一个结点是右子树的根结点

4. 如此递归地进行下去，便能唯一地确定这棵二叉树

Example:

1. 先序序列 ABCDEFGHI
2. 中序序列 BCAEDGHFI

![先序加中序](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220812004008.png)

### 6.2 后序遍历和中序遍历确定一颗二叉树

1. 在后序遍历序列中，**最后一个结点**一定是二叉树的根结点;
2. 而在中序遍历中，根结点必然将中序序列分割成两个子序列
   1. 前一个子序列是根结点的左子树的中序序列
   2. 后一个子序列是根结点的右子树的中序序列。

3. 根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。
   1. 在先序序列中
      1. 左子序列的**最后一个结点**是左子树的根结点
      2. 右子序列的**最后一个结点**是右子树的根结点

4. 如此递归地进行下去，便能唯一地确定这棵二叉树

Example:

1. 后序序列 EFAHCIGBD
2. 中序序列 EAFDHCBGI

![后序+中序](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220813120041.png)

### 6.3 层次遍历和中序遍历确定一颗二叉树

1. 在层次遍历序列中，遍历序列是 **根节点, 左子树, 右子树**
2. 而在中序遍历中，根结点必然将中序序列分割成两个子序列
   1. 前一个子序列是根结点的左子树的中序序列
   2. 后一个子序列是根结点的右子树的中序序列。

3. 如此递归地进行下去，便能唯一地确定这棵二叉树

Example:

1. 层次遍历 DABEFCGHI
2. 中序序列 EAFDHCBGI

![20220812214758](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220812214758.png)

## 选择题done

- 遍历顺序规律

1. 前序左快
2. 后序子孙快
3. 前序祖先快

- 前后序判断结点的祖先关系

1. 前序序列和后序序列不能唯一确定一棵二叉树，但可以确定二叉树中结点的祖先关系
2. 当两个结点的前序序列为XY、后序序列为YX, 则X为y的祖先

- 前序序列和中序序列的关系⭐⭐⭐⭐

1. 相当于以前序序列为入栈次序，以中序序列为出栈次序。

⭐⭐⭐⭐

05 遍历中找路径![20220814230247](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220814230247.png)

12 有前序, 求可能中序![20220815001622](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815001622.png)

12利用栈做前序遍历??

33 前序![20220815215040](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815215040.png)

30 前后序可判定结点祖先关系, 之后关系仍可确定?![20220815214656](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815214656.png)

⭐

01 前中序遍历的联系![20220814231045](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220814231045.png)

03 穷举法![20220814001302](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220814001302.png)

- 规律

1. 前序左快
2. 后序子孙快
3. 前序祖先快

06 遍历的左右顺序![20220814231000](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220814231000.png)

09 先序后续相反![20220814231518](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220814231518.png)

18 线索二叉树的结构![20220815001736](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815001736.png)

24 线索二叉树的前驱![20220815002142](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815002142.png)

25 二叉线索树遍历借助栈![20220815205930](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815205930.png)

29 先后序相反, 则只有![20220815213526](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220815213526.png)
