# 线索二叉树

- [线索二叉树](#线索二叉树)
  - [1. 线索二叉树的基本概念](#1-线索二叉树的基本概念)
  - [2.中序线索二叉树的构造](#2中序线索二叉树的构造)
  - [3.中序线索二叉树的遍历](#3中序线索二叉树的遍历)
  - [4.先序线索二叉树和后序线索二叉树](#4先序线索二叉树和后序线索二叉树)

## 1. 线索二叉树的基本概念

1. 由来
   1. 在含n个结点的二叉树中，有n+1个空指针, 利用这些空指针来存放指向其前驱或后继的指针, 这样就可以像遍历单链表那样方便地遍历二叉树

2. 规定
   1. 若无左子树，令lchild指向其前驱结点;
   2. 若无右子树，令rchild指向其后继结点;
   3. 此外
      1. 还需增加两个标志域标识指针域是:
         1. 指向左(右)孩子
         2. 还是指向前驱(后继)

3. 结点结构

    |lchild|ltag|data|rtag|rchild|
    |--|--|--|--|--|
    |

    $$ltag\begin{cases}
    0 & lchild域指示结点的左孩子\\
    1 & lchild域指示结点的前驱
    \end{cases}$$

    $$rtag\begin{cases}
    0 & rchild域指示结点的右孩子\\
    1 & rchild域指示结点的后继
    \end{cases}$$

4. 定义
   1. 线索链表
      1. 以这种结点结构构成的**二叉链表**作为二叉树的存储结构;
   2. 线索
      1. 指向结点前驱和后继的指针;
   3. 线索二叉树
      1. 加上线索的二叉树;

5. 手动线索
   1. 标出结点访问顺序
   2. 按照空左结点指向结点的前驱
   3. 空左结点指向结点的后继构造线索二叉树

## 2.中序线索二叉树的构造

⭐⭐⭐

构造过程

1. 线索化的实质
   1. 将二叉链表中的**空指针**改为指向**前驱或后继的线索**。而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是**遍历一次二叉树**;

2. 算法思想
   1. 附设指针**pre**指向刚刚访问过的结点
   2. 指针p指向正在访问的结点，即pre指向p的前驱
   3. 在中序遍历的过程中
      1. 检查p的左指针是否为空
         1. 若为空就将它指向pre
      2. 检查pre的右指针是否为空
         1. 若为空就将它指向p

```c
void InThread(ThreadTree &p, ThreadTree &pre)
{
    if (p != NULL)
    {
        //递归 线索化左子树
        InThread(p->lchild, pre);

        //处理根节点
        visit(p, pre);

        //递归 线索化左子树
        InThread(p->rchild, pre);
    }
}

//处理根节点
void visit(ThreadTree &p, ThreadTree &pre)
{

    if (p->lchild == NULL)
    {
        p->lchild = pre;
        p->ltag = 1;
    }

    if (pre != NULL && pre->rchild == NULL)
    {
        pre->rchild = p;
        pre->tag = 1;
    }
    pre = p;
}

void CreateInThread(ThreadTree T)
{
    ThreadTree pre = NULL;
    if (T != NULL) //非空二叉树, 线索化
    {
        InThread(T, pre);   //线索化二叉树
        pre->rchild = NULL; //处理遍历的最后一个结点
        pre->tag = 1;
    }
}

```

## 3.中序线索二叉树的遍历

## 4.先序线索二叉树和后序线索二叉树

- 先序线索二叉树

```c
void PreThread(ThreadTree &p, ThreadTree &pre)
{
    if (p != NULL)
    {
        //处理根节点
        visit(p, pre);

        //递归 线索化左子树
        if (T->ltag == 0)
            PreThread(p->lchild, pre);

        //递归 线索化左子树
        PreThread(p->rchild, pre);
    }
}

//处理根节点
void visit(ThreadTree &p, ThreadTree &pre)
{

    if (p->lchild == NULL)
    {
        p->lchild = pre;
        p->ltag = 1;
    }

    if (pre != NULL && pre->rchild == NULL)
    {
        pre->rchild = p;
        pre->tag = 1;
    }
    pre = p;
}

void CreatePreThread(ThreadTree T)
{
    ThreadTree pre = NULL;
    if (T != NULL) //非空二叉树, 线索化
    {
        PreThread(T, pre);  //线索化二叉树
        pre->rchild = NULL; //处理遍历的最后一个结点
        pre->tag = 1;
    }
}
```

- 后序线索二叉树

```c
void PostThread(ThreadTree &p, ThreadTree &pre)
{
    if (p != NULL)
    {
        //处理根节点
        visit(p, pre);

        //递归 线索化左子树
        PostThread(p->lchild, pre);

        //递归 线索化左子树
        PostThread(p->rchild, pre);
    }
}

//处理根节点
void visit(ThreadTree &p, ThreadTree &pre)
{

    if (p->lchild == NULL)
    {
        p->lchild = pre;
        p->ltag = 1;
    }

    if (pre != NULL && pre->rchild == NULL)
    {
        pre->rchild = p;
        pre->tag = 1;
    }
    pre = p;
}

void CreatePostThread(ThreadTree T)
{
    ThreadTree pre = NULL;
    if (T != NULL) //非空二叉树, 线索化
    {
        PostThread(T, pre); //线索化二叉树
        pre->rchild = NULL; //处理遍历的最后一个结点
        pre->tag = 1;
    }
}
```
