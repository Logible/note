# 交换排序

- [交换排序](#交换排序)
  - [8.3.1 冒泡排序](#831-冒泡排序)
  - [8.3.2 快速排序](#832-快速排序)
  - [选择题 done](#选择题-done)
  - [应用题 undone](#应用题-undone)

1. 交换
   1. 是指根据序列中**两个元素关键字的比较结果**来**对换**这两个记录在序列中的位置

## 8.3.1 冒泡排序

![20221114215410](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221114215410.png)

1. 基本思想
   1. 从后往前（或从前往后）两两比较相邻元素的值
      1. 若为逆序（即$A[i-1]>A[i]$）,则交换它们，直到序列比较完
   2. 我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置）
   3. 下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的**最终位置**
   4. 最多$n-1$趟冒泡就能把所有元素排好序

2. 复杂度
   1. 时间复杂度
      1. 最坏情况下的时间复杂度为$O(n^2)$,其平均时间复杂度也为$O(n^2)$
         1. 当初始序列有序时，显然第一趟冒泡后$flag$依然为$false$ （本趟冒泡没有元素交换），从而直接跳出循环，比较次数为$n-1$,移动次数为$0$,从而最好情况下的时间复杂度为$O(n)$
         2. 当初始序列为逆序时，需要进行$n-1$趟排序，第$i$趟排序要进行$n-i$次关键字的比较，而且每次比较后都必须移动元素$3$次来交换元素位置
            1. 比较次数$\displaystyle \sum_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2}$
            2. 移动次数$\displaystyle \sum_{i=1}^{n-1}(n-i)=3\frac{n(n-1)}{2}$
   2. 空间复杂度
      1. 仅使用了常数个辅助单元，因而空间复杂度为$O(1)$

3. 稳定性
   1. 稳定性：由于$i>j$且$A[i]=A[j]$时，不会发生交换，因此冒泡排序是一种稳定的排序方法

```c
void BubbleSort(ElemType A[], int n)
{
   for (i = 0; i < n - 1; i++)
   {
      flag = false;               //表示本躺冒泡是否发生交换的标志
      for (j = n - 1; j > i; j--) //一趟冒泡
         if (A[j - 1] > A[j])
         {                        //若为逆序
            swap(A[j - 1], A[j]); //交换
            flag = true;
         }

      if (flag == false) //本趟遍历后没有发生交换,说明表已经有序
         return;
   }
}
```

## 8.3.2 快速排序

1. 基本思想
   1. 在待排序表L[1...n]中任取一个元素pivot作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分L[1...k-1]和L[k+1...n],使得
      1. L[l...k-1]中的所有元素小于pivot
      2. L[k+1...n]中的所有元素大于等于pivot,则pivot放在了其最终位置L（k）上
   2. 这个过程称为一趟快速排序（或一次划分）。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止

2. 复杂度
   1. 递归层数
      1. 把$n$个元素组织成二叉树, 二叉树的层数就是递归调用的层数
         1. 最小高度$=\lfloor log_2n\rfloor+1$
            1. ![最小高度](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220915223453.png)
         2. 最大高度$=n$
   2. 时间复杂度$=O(n*$递归层数$)$
      1. 每一层的QuickSort只需要处理剩余的待排序元素，时间复杂度不超过$O(n)$
         1. 最好时间复杂度$O(nlog_2n)$
         2. 最坏时间复杂度$O(n^2)$
            1. 此时树高为$O(n)$
         3. 平均情况下时间复杂度接近$O(nlog_2n)$
   3. 空间复杂度$=O($递归层数$)$
      1. 由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量应与递归调用的最大深度一致。
         1. 最好情况下为$O(log_2n)$
         2. 最坏情况下，因为要进行$n-1$次递归调用，所以栈的深度为$O(n)$
         3. 平均情况下,栈的深度为$O(log_2n)$

3. 稳定性
   1. 快速排序是一种**不稳定**的排序方法
      1. 在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化
      2. 如${3,2_1,2_2}$,经过一趟排序后${2_2,2_1,3}$,最终排序序列也是${2_2,2_1,3}$

- code

1. low < high![20221114222639](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221114222639.png)
2. low = high![20221114222716](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221114222716.png)

```c
//一趟划分
int Partition(ElemType A[], int low, int high)
{
   ElemType pivot = A[low]; //将当前表中第一个元素设为枢纽对表进行划分
   while (low < high)
   {
      while (low < high && A[high] >= pivot) --high;
      A[low] = A[high]; //将比枢纽小的元素移动到左端
      while (low < high && A[low] <= pivot) ++low;
      A[high] = A[low]; //将比枢纽大的元素移动到右端
   }
   A[low] = pivot; //枢纽元素存放在最终位置
   return low;
}

void QuickSort(ElemType A[], int low, int high)
{
   if (low < high)
   {                                           //递归跳出的条件
      int pivotpos = Partition(A, low, high); //划分
      QuickSort(A, low, pivotpos - 1);
      QuickSort(A, pivotpos + 1, high);
   }
}
```

## 选择题 done

⭐

- 07小坑 不能仅从开头算起![20220909191758](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220909191758.png)
- 13希尔显然不符合?![20220909192418](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220909192418.png)
  - 88改变位置, 移动两格, 从而10应该移动2n格 题目未实现
- 10 C=4?![20220909192106](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220909192106.png)
- 11方法的运用![20220909192606](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220909192606.png)
- 11一趟快排 new method:看有无最后位置 考虑逆序![20220909192247](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220909192247.png)
- 2019(了解即可)![20220909193647](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220909193647.png)
- 学完
  - 14![20220909191540](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220909191540.png)

## 应用题 undone
