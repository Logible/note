# 8.2 插入排序

- [8.2 插入排序](#82-插入排序)
  - [8.2.1 直接插入排序](#821-直接插入排序)

- 基本思想是每次将一个待排序的记录按其关键字大小**插入前面已排好序的子序列**，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法

1. 直接插入排序
2. 折半插入排序和
3. 希尔排序

## 8.2.1 直接插入排序

1. 算法思想
   1. 要将元素L(i)插入已有序的子序列L[1...i-1]，需要执行以下操作(用L[]表示一个表，而用L()表示一个元素)
      1. 查找出L(i)在L[1...i-1]中的插入位置k
      2. 将L[k...i-l]中的所有元素依次后移一个位置。
      3. 将L(i)复制到L(k)

2. 复杂度
   1. 插入排序在实现上通常采用就地排序,空间复杂度为$O(1)$
   2. 直接插入排序算法的时间复杂度为$O(n^2)$。
      1. 在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素， 因而时间复杂度为$O(n)$
      2. 在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反(逆序)
         1. 总的比较次数达到最大, 为$\sum_{i=2}^{n}i$
         2. 总的移动次数也达到最大，为$\sum_{i=2}^{n}(i+1)$

3. 稳定性
   1. 由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个**稳定**的排序方法

4. 适用性
   1. 直接插入排序算法适用于**顺序存储和链式存储**的线性表
   2. 为链式存储时，可以从前往后查找指定元素的位置

- 哨兵版Code

```c
void InsertSort(int A[], int n)
{
   int i, j;
   for (i = 0; i <= n; i++)
   {
      if (A[i] < A[i - 1])
      {
         A[0] = A[i];
         for (j = i - 1; A[j] > A[0]; --j) //检查所有前面已排好序的元素
            A[j + 1] = A[j];               //往后挪位
         A[j + 1] = temp;                  //复制到插入位置, 退出循环时j=0;
      }
   }
}
```
