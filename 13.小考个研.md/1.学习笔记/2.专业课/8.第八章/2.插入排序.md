# 8.2 插入排序

- [8.2 插入排序](#82-插入排序)
  - [8.2.1 直接插入排序](#821-直接插入排序)
  - [8.2.2 折半插入排序](#822-折半插入排序)
  - [8.2.3 希尔排序](#823-希尔排序)
  - [习题 选择题done](#习题-选择题done)
  - [应用题 undone](#应用题-undone)

- 基本思想是每次将一个待排序的记录按其关键字大小**插入前面已排好序的子序列**，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法

## 8.2.1 直接插入排序

1. 算法思想
   1. 要将元素L(i)插入已有序的子序列L[1...i-1]，需要执行以下操作(用L[]表示一个表，而用L()表示一个元素)
      1. 查找出L(i)在L[1...i-1]中的插入位置k
      2. 将L[k...i-1]中的所有元素依次后移一个位置。
      3. 将L(i)复制到L(k)

2. 复杂度
   1. 插入排序在实现上通常采用就地排序,空间复杂度为$O(1)$
   2. 直接插入排序算法的时间复杂度为$O(n^2)$。
      1. 在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素， 因而时间复杂度为$O(n)$
      2. 在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反(逆序)
         1. 总的比较次数达到最大, 为$\sum_{i=2}^{n}i$
         2. 总的移动次数也达到最大，为$\sum_{i=2}^{n}(i+1)$

3. 稳定性
   1. 由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个**稳定**的排序方法

4. 适用性
   1. 直接插入排序算法适用于**顺序存储和链式存储**的线性表
   2. 为链式存储时，可以从前往后查找指定元素的位置

- 哨兵版Code

```c
void InsertSort(int A[], int n)
{
   int i, j;
   for (i = 2; i <= n; i++) //依次将A[2]~A[n]插入到已排序序列
   {
      if (A[i] < A[i - 1]) //若A[i]关键码小于其前驱, 将A[j]插入有序表
      {
         A[0] = A[i];                      //复制为哨兵,A[0]不存放元素
         for (j = i - 1; A[j] > A[0]; --j) //从后往前找待代插入位置
            A[j + 1] = A[j];               //往后挪位
         A[j + 1] = A[0];                  //复制到插入位置, 退出循环时j=0;
      }
   }
}
```

## 8.2.2 折半插入排序

1. 前情提要
   1. 从直接插入排序算法中，每趟插入的过程中都进行了两项工作
      1. 从前面的有序子表中**查找出**待插入元素应该被插入的**位置**;
      2. 给插入位置**腾出空间**，将待**插入元素**复制到表中插入位置;
   2. 注意到在该算法中，总是边比较边移动元素。下面将**比较和移动操作**分离
      1. 即先**折半查找出**元素的待插入位置
      2. 然后统一地移动待插入位置之后的所有元素

2. 时间复杂度
   1. 折半插入排序仅减少了比较元素的次数，约为$O(nlog_2n)$，该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数$n$
   2. 而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为$O(n^2)$

3. 稳定性
   1. 折半插入排序是一种**稳定**的排序方法
   2. 折半查找时一直到$low > high$时才停止折半查找
      1. 当mid所指元素等于当前元素时，$令low=mid+1$，以保证“稳定性”
      2. 最终应将当前元素插入到$low$所指位置,即$high+1$

- code

```c
void InsertSort(int A[], int n)
{
   int i, j, low, high, mid;
   for (i = 2; i <= n; i++) //依次将A[2]~A[n]插入到已排序序列
   {
      A[0] = A[i]; //复制为哨兵,A[0]不存放元素
      low = 1;
      high = i - 1;

      while (low <= high) //折半查找寻找插入位
      {
         mid = (low + high) / 2; //取中间点
         if (A[mid] > A[0])
            high = mid - 1; //查找左子表
         else
            low = mid + 1; //查找右子表
      }

      for (j = i - 1; j >= high + 1; --j) //统一后移元素, 空出查找位置
         A[j + 1] = A[j];
      A[high + 1] = A[0]; //复制到插入位置
   }
}
```

1. 保证稳定性做法
   1. ![20220915215910](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220915215910.png)
   2. ![20220915215844](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220915215844.png)
   3. ![20220915215949](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220915215949.png)
   4. ![20220915220015](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220915220015.png)

## 8.2.3 希尔排序

1. 前情提要
   1. 直接插入排序算法的时间复杂度为$O(n^2)$
      1. 但若待排序列为“正序”时,其时间复杂度可提高至$O(n)$，由此可见它更适用于**基本有序**的排序表和**数据量不大**的排序表
   2. 希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。

2. 算法思想
   1. 先取一个小于$n$的步长$d_1$，把表中的全部记录分成$d_1$组，所有距离为$d_1$的倍数的记录放在同一组，在各组内进行直接插入排序
   2. 然后取第二个步长$d_2<d_1$,重复上述过程
   3. 直到所取到的$d_t=1$，即所有记录已放在同一组中，再进行直接插入排序

3. 时间空间复杂度
   1. 仅使用了常数个辅助单元，因而空间复杂度为$O(1)$
   2. 当n在某个特定范围时，希尔排序的时间复杂度约为$O(n^{1.3})$。 在最坏情况下希尔排序的时间复杂度为$O(n^2)$。

4. 稳定性
   1. 当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序
   2. 因此希尔排序是一种**不稳定**的排序方法

- code

```c
void ShellSort(ElemType A[], int n)
{
   // A[0]只是是暂存单元，不是哨兵，当j<=0时，插入位置已到
   for (dk = n / 2; dk >= 1; dk = dk / 2)
      for (i = dk + 1; i <= n; ++i)
      {
         if (A[i] < A[i - dk]) //需将A[i]插入有序增量子表
         {
            A[0] = A[i];                                    //暂存在A[0]
            for (j = i - dk; j > 0 && A[0] < A[j]; j -= dk) //记录后移，查找插入的位置
               A[j + dk] = A[j];                            
            A[j + dk] = A[0];                               //插入
         }
      }
}
```

## 习题 选择题done

⭐⭐

- 14待本章学完![20220907233532](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220907233532.png)

⭐

- 01 不考虑哨兵比较![20220907233026](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220907233026.png)
- 02 基本有序效率最高![20220907233152](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220907233152.png)
- 03 同01![20220907233105](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220907233105.png)
- 10 希尔,考虑后序![20220907233426](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220907233426.png)

## 应用题 undone
