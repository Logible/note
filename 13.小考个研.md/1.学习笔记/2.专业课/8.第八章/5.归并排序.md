# 8.5 归并排序和基数排序

## 8.5.1归并排序

1. 定义
   1. “归并”的含义是将两个或两个以上的有序表组**合成**一个新的有序表。假定待排序表含有n个记录，则可将其视为n个有序的子表
   2. 每个子表的长度为1,然后两两归并，得到$\lceil n/2 \rceil$个长度为2或1的有序表⭐；继续两两归并……如此重复，直到合并成一个长度为n的有序表为止

2. Merge()函数
   1. Merge()的功能是将前后相邻的两个有序表归并为一个有序表。
   2. 函数设计
      1. 设两段有序表A [low...mid]、A [mid+1...high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。
      2. 每次从对应B中的两个段取出一个记录进行关键字的比较，将较小者放入A中
      3. 当数组B中有一段的下标超出其对应的表长(即该段的所有元素都已复制到A中)时，将另一段中的剩余部分直接复制到A

3. 分治
   1. 递归形式的2路归并排序算法是基于分治的，其过程如下
      1. 分解：将含有n个元素的待排序表分成各含$n/2$个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。
      2. 合并：合并两个已排序的子表得到排序结果

4. 复杂度
   1. 空间效率
      1. Merge()操作中，辅助空间刚好为n个单元，所以算法的空间复杂度为$O(n)$
         1. 递归时深度不超过$O(log_2n)$,故无需考虑递归
   2. 时间效率
      1. 每趟归并的时间复杂度为$O(n)$，共需进行$\lceil log_2n \rceil$趟归并，所以算法的时间复杂度为$O(nlog_2n)$

5. 稳定性
   1. 由于Merge()操作不会改变相同关键字记录的相对次序，所以2路归并排序算法是一种**稳定**的排序方法。

6. 时间复杂度深度分析(非重点)
   1. 2路归并排序的"归并树",形态上就是倒立的二叉树, 树的高度$h-1$为排序的趟数
   2. 二叉树的第h层最多有$2^{h-1}$个结点若树高为$h$,则应满足$n \le 2^{h-1}$,即$h-1=\lceil log_2n \rceil$
   3. 结论: n个元素进行2路归并排序，归并趟数$\lceil log_2n \rceil$
   4. 每趟归并时间复杂度为$O(n)$
      1. 第一趟$≈n/2$
      2. 最后一趟最多$n-1$

- code

```c
ElemType *B = (ElemType *)malloc((n + 1) * sizeof(ElemType)); //辅助数组B

void Merge(ElemType A[], int low, int mid, int high)
{
   //表A的两段A[low...mid]和A[mid+1...high]各自有序, 将它们合并成一个有序表
   for (int k = low, k <= high; k++)
      B[k] = A[k]; //将A的所有元素复制到B
   for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++)
   {
      if (B[i] <= B[j]) //将较小值复制到A中
         A[k] = B[i++];
      else
         A[k] = B[j++];
   }
   while (i <= mid)
      A[k++] = B[i++]; //若第一个表未检测完,复制
   while (j <= high)
      A[k++] = B[i++]; //若第一个表未检测完,复制
}

void MergeSort(ElemType A[], int low, int high)
{
   if (low < high)
   {
      int mid = (low + high) / 2;  //从中间划分成两个子序列
      MergeSort(A, low, mid);      //对左侧子序列进行递归排序
      MergeSort(A, mid + 1, high); //对右侧子序列进行递归排序
      Merge(A, low, mid, high);    //归并
   }
}
```
