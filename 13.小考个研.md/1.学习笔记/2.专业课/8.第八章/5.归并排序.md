# 8.5 归并排序和基数排序

- [8.5 归并排序和基数排序](#85-归并排序和基数排序)
  - [8.5.1 归并排序](#851-归并排序)
  - [8.5.2 基数排序](#852-基数排序)
  - [选择题 done](#选择题-done)
  - [应用题 done](#应用题-done)

## 8.5.1 归并排序

- 归并排序![20221111215444](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221111215444.png)
- ![20221111221847](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221111221847.png)

1. 定义
   1. “归并”的含义是将两个或两个以上的有序表组**合成**一个新的有序表。假定待排序表含有n个记录，则可将其视为n个有序的子表
   2. 每个子表的长度为1,然后两两归并，得到$\lceil n/2 \rceil$个长度为2或1的有序表；继续两两归并……如此重复，直到合并成一个长度为n的有序表为止

2. Merge()函数
   1. Merge()的功能是将前后相邻的两个有序表归并为一个有序表。
   2. 函数设计
      1. 设两段有序表A [low...mid]、A [mid+1...high]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。
      2. 每次从对应B中的两个段取出一个记录进行关键字的比较，将较小者放入A中
      3. 当数组B中有一段的下标超出其对应的表长(即该段的所有元素都已复制到A中)时，将另一段中的剩余部分直接复制到A

3. 分治
   1. 递归形式的2路归并排序算法是基于分治的，其过程如下
      1. 分解：将含有n个元素的待排序表分成各含$\displaystyle \frac{n}{2}$个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。
      2. 合并：合并两个已排序的子表得到排序结果

4. 复杂度
   1. 空间效率
      1. Merge()操作中，辅助空间刚好为n个单元，所以算法的空间复杂度为$O(n)$
         1. 递归时深度不超过$O(log_2n)$,故无需考虑递归
   2. 时间效率
      1. 每趟归并的时间复杂度为$O(n)$，共需进行$\lceil log_2n \rceil$趟归并，所以算法的时间复杂度为$O(nlog_2n)$

5. 稳定性
   1. 由于Merge()操作不会改变相同关键字记录的相对次序，所以2路归并排序算法是一种**稳定**的排序方法。

6. 时间复杂度深度分析(非重点)
   1. 2路归并排序的"归并树",形态上就是倒立的二叉树, 树的高度$h-1$为排序的趟数
   2. 二叉树的第h层最多有$2^{h-1}$个结点若树高为$h$,则应满足$n \le 2^{h-1}$,即$h-1=\lceil log_2n \rceil$
   3. 结论: n个元素进行2路归并排序，归并趟数$\lceil log_2n \rceil$
   4. 每趟归并时间复杂度为$O(n)$
      1. 第一趟$≈n/2$
      2. 最后一趟最多$n-1$

- code

```c
ElemType *B = new B[n]; //辅助数组B

void Merge(ElemType A[], int low, int mid, int high)
{
//表A的两段A[low...mid]和A[mid+1...high]各自有序, 将它们合并成一个有序表
   for (int k = low, k <= high; k++)
      B[k] = A[k]; //将A的所有元素复制到B
   for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++)
   {
      if (B[i] <= B[j]) //将较小值复制到A中
         A[k] = B[i++];
      else
         A[k] = B[j++];
   }
   while (i <= mid)
      A[k++] = B[i++]; //若第一个表未检测完,复制
   while (j <= high)
      A[k++] = B[i++]; //若第一个表未检测完,复制
}

void MergeSort(ElemType A[], int low, int high)
{
   if (low < high)
   {
      int mid = (low + high) / 2;  //从中间划分成两个子序列
      MergeSort(A, low, mid);      //对左侧子序列进行递归排序
      MergeSort(A, mid + 1, high); //对右侧子序列进行递归排序
      Merge(A, low, mid, high);    //归并
   }
}
```

## 8.5.2 基数排序

- 基数排序1![20221111215132](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221111215132.png)
- 基数排序2![20221111215355](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221111215355.png)
- 基数排序3![20221111215150](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221111215150.png)

1. 特点  
   1. 它不基于比较和移动进行排序
   2. 而基于关键字各位的大小进行排序
   3. 基数排序是一种借助**多关键字排序**的思想对单逻辑关键字进行排序的方法

2. 排序线性表
   1. 长度为n线性表中每个结点$a_j$的关键字由$d$元组组成
      $$\displaystyle k_j^{d-1},k_j^{d-2},\dots,k_j^{1},k_j^{0}$$

      $$0 \le k_j^i \le r-1 (0 \le j <n,0 \le i \le d-1)$$
      1. 其中$k_j^{d-1}$为最主位关键字
      2. $k_j^0$为最次位关键字。

3. 基数排序得到递减序列的过程
   1. 初始化
      1. 设置$r$个空队列，$Q_{r-1},Q_{r-2},...,Q_0$
      2. 按照各个关键字位权重递增的次序(个、十、百)，对$d$个关键字位分别做“分配”和"收集"
   2. 分配
      1. 顺序扫描各个元素，若当前处理的关键字位$=x$，则将元素插入$Q_x$队尾
   3. 收集
      1. 把$Q_{r-1},Q_{r-2},...,Q_0$各个队列中的结点依次出队并链接

4. 复杂度
   1. 空间效率：
      1. 基数排序的空间复杂度为$O(r)$
      2. 一趟排序需要的辅助存储空间为$r$($r$个队列：$r$个队头指针和$r$个队尾指针), 但以后的排序中会重复使用这些队列
   2. 时间效率
      1. 基数排序的时间复杂度为$O(d(n+r))$它与序列的初始状态无关
      2. 基数排序需要进行$d$趟分配和收集，一趟分配需要$O(n)$, 一趟收集需要$O(r)$

5. 稳定性
   1. 对于基数排序算法而言，很重要一点就是按位排序时必须是稳定的。因此，这也保证了基数排序的**稳定**性。

## 选择题 done

⭐

- 01![20220913234704](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220913234704.png)
- 06 归并排序的数量级![20220913235402](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220913235402.png)
- 03各算法时间空间复杂度整理![20220913234951](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220913234951.png)

## 应用题 done
