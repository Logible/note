# 8.4 简单选择排序

- [8.4 简单选择排序](#84-简单选择排序)
  - [8.4.1简单选择排序](#841简单选择排序)
  - [8.4.2 堆排序](#842-堆排序)

1. 基本思想是：每一趟(如第$i$趟)在后面$n-i+1 (i=1,2,...,n-1)$个待排序元素中选取关键字最小的元素，作为有序子序列的第$i$个元素，直到第$n-1$趟做完，待排序元素只
剩下$1$个，就不用再选了。

## 8.4.1简单选择排序

1. 简单选择排序算法的思想：
   1. 假设排序表为L[1...n],第i趟排序即从L[i...n]中选择关键字最小的元素与$L(i)$交换
   2. 每一趟排序可以确定**一个**元素的**最终位置**，这样经过1趟排序就可使得整个排序表有序

2. 复杂度
   1. 空间效率：
      1. 仅使用常数个辅助单元，故空间效率为$O(1)$
   2. 时间效率：
      1. 元素移动的操作次数很少
          1. 不会超过$3(n-1)$次
          2. 最好的情况是移动$0$次，此时对应的表已序；
      2. 但元素间比较的次数与序列的初始状态无关，是$n(n-1)/2$次，因此时间复杂度始终是$O(n^2)$

3. 稳定性：
   1. 在第$i$趟找到最小元素后，和第$i$个元素交换，可能会导致第$i$个元素与其含有相同关键字元素的相对位置发生改变。
   2. 因此，简单选择排序是一种**不稳定**的排序方法。
   3. 例如
      1. 表$£={2,2_s,1}$,经过一趟排序后$£={1,2_s,2}$,最终排序序列也是$£={1,2_s,2}$

- code⭐代码待补充

## 8.4.2 堆排序

- 堆排序练习![堆排序练习](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220910230433.png)

1. 定义
   1. n个关键字序列L[1...n]称为堆, 当且仅当该序列满足
    - $(1\le i\le \lfloor n/2\rfloor)$
      1. $L(i)>=L(2i)$且$L(i)>=L(2i+l)$: 称为大根堆(大顶堆)
      2. $L(i)<=L(2i)$且$L(i)<=L(2i+1)$: 称为小根堆(小顶堆)

2. 基本思想
   1. 建堆
      1. 首先将存放在L[1...n]中的n个元素建成初始堆，由于堆本身的特点(以大顶堆为例)，堆顶元素就是最大值。
   2. 输出
      1. 输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏
   3. 调整
      1. 将堆顶元素**向下调整**使其继续保持大顶堆的性质
   4. 重复23，直到堆中仅剩一个元素为止

3. 构造初始堆
   1. n个结点的完全二叉树，最后一个结点是第$\lfloor n/2\rfloor$个结点的孩子
      1. 对第$\lfloor n/2\rfloor$个结点为根的子树筛选，使该子树成为堆。
         1. 对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换
   2. 之后向前依次对各结点$\lfloor n/2\rfloor \to 1$为根的子树进行筛选,看该结点值是否大于其左右子结点的值
      1. 若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆
      2. 于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。
   3. 反复利用上述调整堆的方法建堆，直到根结点

4. 插入操作
   1. 对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作
   2. example
      1. ![insert](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911010638.png)

5. 删除操作
   1. 被删除的元素用堆底元素替代，然后让该元素不断“下坠""，直到无法下坠为止
   2. example
      1. ![20220911011042](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911011042.png)
      2. ![20220911011056](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911011056.png)
      3. ![20220911011101](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911011101.png)
      4. ![20220911011107](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911011107.png)

6. 复杂度⭐待补充原因
   1. 空间效率
      1. 仅使用了常数个辅助单元，所以空间复杂度为$O(1)$。
   2. 时间效率
      1. 建堆时间为$O(n)$，之后有$n-1$次向下调整操作，每次调整的时间复杂度为$O(h)$
      2. 故在最好、最坏和平均情况下，堆排序的时间复杂度为$O(nlog_2n)$

7. 稳定性
   1. 稳定性：
      1. **不稳定**的排序方法。
   2. 例如，表$L={1,2_s,2}$,构造初始堆时可能将$2_s$交换到堆顶，此时$L={2_s,1,2}$,最终排序序列为$L={1,2,2_s}$

- code

```c
void BuildMaxHeap(ElemType A[], int len)
{
   for (int i = len / 2; i > 0; i--) //从i=[n/2]~1 反复调整堆
      HeadAdjust(A, i, len);
}

void HeadAdjust(ElemType A[], int k, int len)
{
   A[0] = A[k];                      // A[0]暂存子树的根节点
   for (i = 2 * k; i <= len; i *= 2) //沿key较大的子节点向下筛选
   {
      if (i > len && A[i] < A[i + 1])
         i++; //取key较大的子节点的下标
      if (A[0] >= A[i])
         break;
      else
      {
         A[k] = A[i]; //将A[i]调整到双亲结点上
         k = i;       //修改k值, 以便继续向下筛选
      }
   }
   A[k] = A[0]; //被筛选结点放入最终位置
}

void HeapSort(ElemType A[], int len)
{
   BuildMaxHeap(A, len); //初始建堆
   for (i = len; i > 1; i--)
   {                           // n-1趟的交换和建堆过程
      Swap(A[i], A[1]);        //输出栈顶元素(和栈底元素互换)
      HeadAdjust(A, 1, i - 1); //调整,把剩余的i-1个元素整理成堆
   }
}
```
