# 8.4 简单选择排序

- [8.4 简单选择排序](#84-简单选择排序)
  - [8.4.1 简单选择排序](#841-简单选择排序)
  - [8.4.2 堆排序](#842-堆排序)
  - [选择题 done](#选择题-done)

1. 基本思想是：每一趟(如第$i$趟)在后面$n-i+1 (i=1,2,...,n-1)$个待排序元素中选取关键字最小的元素，作为有序子序列的第$i$个元素，直到第$n-1$趟做完，待排序元素只剩下$1$个，就不用再选了。

## 8.4.1 简单选择排序

1. 简单选择排序算法的思想：
   1. 假设排序表为L[1...n],第i趟排序即从L[i...n]中选择关键字最小的元素与$L(i)$交换
   2. 每一趟排序可以确定**一个**元素的**最终位置**，这样经过$n-1$趟排序就可使得整个排序表有序

2. 复杂度
   1. 空间效率：
      1. 仅使用常数个辅助单元，故空间效率为$O(1)$
   2. 时间效率：
      1. 元素移动的操作次数很少
          1. 不会超过$3(n-1)$次
          2. 最好的情况是移动$0$次，此时对应的表已有序；
      2. 但元素间比较的次数与序列的初始状态无关，是$n(n-1)/2$次，因此时间复杂度始终是$O(n^2)$

3. 稳定性：
   1. 在第$i$趟找到最小元素后，和第$i$个元素交换，可能会导致第$i$个元素与其含有相同关键字元素的相对位置发生改变。
   2. 因此，简单选择排序是一种**不稳定**的排序方法。
   3. 例如
      1. 表$£={2,2_s,1}$,经过一趟排序后$£={1,2_s,2}$,最终排序序列也是$£={1,2_s,2}$

- code

```c
void SelectSort(ElemType A[], int n)
{
   for (i = 0; i < n - 1; i++)
   {                              //一共进行n-1趟
      min = i;                    //记录最小元素位置
      for (j = i + 1; j < n; j++) //在A[i...n-1]中选择最小的元素
      {
         if (A[j] < A[min])
            min = j; //更新最小元素位置
      }
      if (min != i) //封装的swap()函数共移动元素三次
         swap(A[i], A[min]);
   }
}
```

## 8.4.2 堆排序

- 堆排序练习![堆排序练习](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220910230433.png)

1. 定义
   1. n个关键字序列L[1...n]称为堆, 当且仅当该序列满足
    - $(1\le i\le \lfloor n/2\rfloor)$
      1. $L(i)>=L(2i)$且$L(i)>=L(2i+1)$: 称为大根堆(大顶堆)
      2. $L(i)<=L(2i)$且$L(i)<=L(2i+1)$: 称为小根堆(小顶堆)

2. 基本思想
   1. 建堆
      1. 首先将存放在L[1...n]中的n个元素建成初始堆，由于堆本身的特点(以大顶堆为例)，堆顶元素就是最大值。
   2. 输出
      1. 输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏
   3. 调整
      1. 将堆顶元素**向下调整**使其继续保持大顶堆的性质
   4. 重复23，直到堆中仅剩一个元素为止

3. 构造初始堆
   1. n个结点的完全二叉树，最后一个结点是第$\lfloor n/2\rfloor$个结点的孩子
      1. 对第$\lfloor n/2\rfloor$个结点为根的子树筛选，使该子树成为堆。
         1. 对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换
   2. 之后向前依次对各结点$\lfloor n/2\rfloor-1 \to 1$为根的子树进行筛选,看该结点值是否大于其左右子结点的值
      1. 若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆
      2. 于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。
   3. 反复利用上述调整堆的方法建堆，直到根结点

4. 插入操作
   1. 对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作
   2. example
      1. ![insert](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911010638.png)

5. 删除操作
   1. 被删除的元素用堆底元素替代，然后让该元素不断"下坠"，直到无法下坠为止
   2. example
      1. ![20220911011042](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911011042.png)
      2. ![20220911011056](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911011056.png)
      3. ![20220911011101](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911011101.png)
      4. ![20220911011107](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911011107.png)

6. 复杂度
   1. 空间效率
      1. 仅使用了常数个辅助单元，所以空间复杂度为$O(1)$。
   2. 时间效率
      1. 建堆时间为$O(n)$，之后有$n-1$次向下调整操作，每次调整的时间复杂度为$O(h)$
      2. 故在最好、最坏和平均情况下，堆排序的时间复杂度为$O(nlog_2n)$

7. 稳定性
   1. 稳定性：
      1. **不稳定**的排序方法。
   2. 例如，表$L={1,2_s,2}$,构造初始堆时可能将$2_s$交换到堆顶，此时$L={2_s,1,2}$,最终排序序列为$L={1,2,2_s}$

8. 时间复杂度深度分析(非重点)
   1. 建堆
      1. 一个结点，每"下坠"一层，最多只需对比关键字2次
      2. 若树高为h,某结点在第i层，则将这个结点向下调整最多只需要"下坠"$h-i$层，关键字对比次数不超过$2(h-i)$
      3. **n**个结点的完全二叉树树高$h= \lfloor log_2n\rfloor + 1$
      4. 第i层最多有$2^{i-1}$个结点，而只有第$1 \to (h-1)$层的结点才有可能需要“下坠”调整
      5. 将整棵树调整为大根堆，关键字对比次数不超过
      $$\sum_{i=h-1}^{1}2^{i-1}2(h-i)=\sum_{i=h-1}^{1}2^{i}(h-i)=... \le 4n$$
   2. 交换和建堆过程
      1. 根节点最多"下坠"$h-1$层,二叉树树高$h= \lfloor log_2n\rfloor + 1$
      2. 而每“下坠”一层，最多只需对比关键字2次,因此每一趟排序复杂度不超过$O(h)= O(log_2n)$
      3. 共$n-1$趟，总的时间复杂度$=O(nlog_2n)$
   3. 故堆排序时间复杂度
   $$O(n)+O(nlog_2n)=O(nlog_2n)$$

- code

```c
void BuildMaxHeap(ElemType A[], int len)
{
   for (int i = len / 2; i > 0; i--) //从i=[n/2]~1 反复调整堆
      HeadAdjust(A, i, len);
}

void HeadAdjust(ElemType A[], int k, int len)
{
   A[0] = A[k];                      // A[0]暂存子树的根节点
   for (i = 2 * k; i <= len; i *= 2) //沿key较大的子节点向下筛选
   {
      if (i < len && A[i] < A[i + 1])
         i++; //取key较大的子节点的下标
      if (A[0] >= A[i])
         break;
      else
      {
         A[k] = A[i]; //将A[i]调整到双亲结点上
         k = i;       //修改k值, 以便继续向下筛选
      }
   }
   A[k] = A[0]; //被筛选结点放入最终位置
}

void HeapSort(ElemType A[], int len)
{
   BuildMaxHeap(A, len); //初始建堆
   for (i = len; i > 1; i--)
   {                           // n-1趟的交换和建堆过程
      Swap(A[i], A[1]);        //输出栈顶元素(和栈底元素互换)
      HeadAdjust(A, 1, i - 1); //调整,把剩余的i-1个元素整理成堆
   }
}
```

## 选择题 done

⭐=⭐

- 04四种排序的特点![20220911231039](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911231039.png)

为什么只需调10次小根堆, 初始不用建堆吗, 就算考虑建堆, 时间复杂度也是$O(n/2)=O(n)+10*O(log_2n)=O(n)$

而冒泡排序是$10*O(n)$

⭐

- 03待学基数排序![20220911230746](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911230746.png)

- 10余堆输出两次, 慢慢算![20220911231317](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911231317.png)

- 07小根堆的最大关键字![20220911231207](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220911231207.png)

- 13删除后要从大根堆标记删除..![20220912013718](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220912013718.png)
