# B-Tree

- [B-Tree](#b-tree)
  - [7.4.1 B树及其基本操作](#741-b树及其基本操作)
  - [选择题done](#选择题done)
  - [应用题done](#应用题done)

## 7.4.1 B树及其基本操作

- ![B-tree instance](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220902004202.png)

1. 定义
   1. B树，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树
      1. 树中每个结点至多有m棵子树，即至多含有m-1个关键字。
      2. 若根结点不是终端结点，则至少有两棵子树
      3. 除根结点外的所有非叶结点至少有$\lceil \frac{m}{2} \rceil$棵子树，即至少含有$\lceil \frac{m}{2} \rceil - 1$个关键字
      4. 所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）
      5. 结点结构
         1. ![Nodes structure](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220902004120.png)

2. B树的高度
   1. 若$n \ge 1$,则对任意一棵包含$n$个关键字、阶数为$m$的B树：
      1. $h \ge log_m(n+1)$
         1. 因为B树中每个结点最多有$m$棵子树，$m-1$个关键字，所以上述B树应满足
         2. $n \le (m-1)(1+m+m^2+...+m^{h-1})=m^h-1$
      2. $\displaystyle h \le log_{\lceil \frac{m}{2} \rceil}\frac{n+1}{2}+1$
         1. $n$个关键字的B树必有$n+1$个叶子结点
            1. n个关键字将数域分为$n+1$个区间
         2. 最大高度——让各层的分叉尽可能的少，即根节点只有2个分叉，其他结点只有$\lceil \frac{m}{2} \rceil$个分叉
            1. 各层结点至少有:
               1. 第一层1,第二层2,第三层$2\lceil \frac{m}{2} \rceil$...第h层$2(\lceil \frac{m}{2} \rceil)^{h-2}$
               2. 第h+1层共有叶子结点(失败结点)$2(\lceil \frac{m}{2} \rceil)^{h-1}$个
            2. 故$n+1 \ge 2(\lceil \frac{m}{2} \rceil)^{h-1}$

3. B树的查找
   1. 在B树上进行查找与二叉查找树很相似，只是每个结点都是多个关键字的有序表
   2. 在每个结点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定

4. B树的插入
   1. 定位
      1. 利用前述的B树查找算法，找出插入该关键字的最低层中的某个非叶结点
         1. 在B树中查找key时，会找到表示查找失败的叶结点，这样就确定了最底层非叶结点的插入位置
      2. 注意
         1. 插入位置一定是最低层中的某个**非叶结点**
   2. 插入: 在B树中，每个非失败结点的关键字个数都在区间$[\lceil m/2 \rceil -1,m -1]$内
      1. 插入后的结点关键字个数小于m,可以直接插入
      2. 插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于$m-1$时，必须对结点进行分裂
      3. 分裂的方法
         1. 取一个新结点，在插入key后的原结点，从中间位置$(\lceil m/2 \rceil)$将其中的关键字分为两部分
            1. 左部分包含的关键字放在原结点中
            2. 右部分包含的关键字放到新结点中
            3. 中间位置$(\lceil m/2 \rceil)$的结点插入原结点的父结点(指向它的结点右边结点)
         2. 若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。
   3. 例子:
      1. 插入60
         1. ![insert instance](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903214610.png)
      2. 插入93
         1. ![20220903231553](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903231553.png)
         2. ![20220903231605](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903231605.png)
5. B树的删除
   1. 使得删除后的结点中的关键字个数$>=\lceil m/2 \rceil -1$
   2. 非叶节点
      1. 非终端结点处理
         1. 当被删关键字$k$不在终端结点（最低层非叶结点）中时，可以用$k$的前驱（或后继）$k'$来替代$k$, 然后在相应的结点中删除$k'$,关键字$k'$必定落在某个终端结点中
            1. 直接前驱︰当前关键字左侧指针所指子树中“最右下”的元素
      2. 例子: 删除80
         1. ![删除80](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903215029.png)
   3. 叶节点
      1. 当被删关键字在终端结点（最低层非叶结点）中时，有下列三种情况
      2. 直接删除关键字
         1. 若被删除关键字所在结点的关键字个数表明删除该关键字后仍满足B树的定义，则直接删去该关键字。
      3. 兄弟够借
         1. 若被删除关键字所在结点删除前的关键字个数$=\lceil m/2 \rceil -1$
         2. 且与此结点相邻的右（或左）兄弟结点的关键字个数$\ge \lceil m/2 \rceil$
         3. 则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡
            1. 父子换位法
               1. 当右兄弟很宽裕时，用当前结点的后继、后继的后继来填补空缺
               2. 当左兄弟很宽裕时，用当前结点的前驱、前驱的前驱来填补空缺
      4. 兄弟不够借
         1. 若被删除关键字所在结点删除前的关键字个数$=\lceil m/2 \rceil -1$
         2. 且此时与该结点相邻的左、右兄弟结点的关键字个数均$=\lceil m/2 \rceil -1$
         3. 则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并
         4. Tips:在合并过程中，双亲结点中的关键字个数会减1
            1. 若其双亲结点是根结点且关键字个数减少至0 （根结点关键字个数为1时，有2棵子树）
               1. 则直接将根结点删除，合并后的新结点成为根
            2. 若双亲结点不是根结点且关键字个数减少到$\lceil m/2 \rceil - 2$
               1. 则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止
      5. 例子
         1. 兄弟够用/不够用
            1. ![简单例](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903230704.png)
         2. 兄弟够用
            1. 删除38
               1. ![删除38](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903232131.png)
               2. ![删除38](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903232221.png)
            2. 删除90
               1. ![删除90](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903232402.png)
               2. ![删除90](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903232419.png)
         3. 兄弟不够用
            1. 删除49
               1. ![删除49](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903233012.png)
               2. ![处理步骤1](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903232824.png)
               3. ![处理步骤2](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220903232745.png)

## 选择题done

⭐⭐⭐⭐

10 B树不支持![20220904005322](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220904005322.png)

⭐

17高度确定 阶数确定 求最多关键字![20220904010306](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220904010306.png)

1 几阶B树![20220904003631](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220904003631.png)

6 结点最多最少计算![20220904004846](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220904004846.png)

7 最少关键字个数![20220904005023](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220904005023.png)

14 关键字确定 求最多结点![20220904005916](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220904005916.png)

19求最多结点![20220904010555](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220904010555.png)

## 应用题done

⭐

![20220926224424](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220926224424.png)
