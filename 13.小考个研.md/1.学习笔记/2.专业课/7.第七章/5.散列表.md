# 散列表

- [散列表](#散列表)
  - [7.5.1 散列表的基本概念](#751-散列表的基本概念)
  - [7.5.2 散列函数的构造方法](#752-散列函数的构造方法)
  - [7.5.3 处理冲突的方法](#753-处理冲突的方法)
  - [7.5.4 散列查找及性能分析](#754-散列查找及性能分析)
  - [习题 done选择题](#习题-done选择题)
  - [应用题 done](#应用题-done)
  - [真题](#真题)

## 7.5.1 散列表的基本概念

1. 散列函数
   1. 一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr (这里的地址可以是数组下标、索引或内存地址等)
2. 冲突
   1. 散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为**冲突**
3. 同义词
   1. 发生碰撞的不同关键字称为**同义词**
4. 散列表：根据关键字而直接进行访问的数据结构
   1. 散列表建立了**关键字**和**存储地址**之间的一种**直接映射关系**。

## 7.5.2 散列函数的构造方法

1. 直接定址法
   1. 直接取关键字的某个线性函数值为散列地址，散列函数为

        $H(key)=key$或$H(key)=a*key+b$

      1. a和b是常数
      2. 这种方法计算最简单，且**不会产生冲突**。它适合关键字的分布基本连续的情况，若**关键字分布不连续，空位较多**，则会造成存储空间的浪费

2. 除留余数法
   1. 假定散列表表长为m，取一个**不大于m但最接近或等于m的质数p**,利用以下公式把关键字转换成散列地址。散列函数为

         $H(key) = key \mod p$

3. 数字分析法
   1. 取数码**分布较为均匀**的若干位作为散列地址。
   2. 这种方法适合于**已知的关键字集合**，若更换了关键字，则需要重新构造新的散列函数
   3. 如phone number后四位

4. 平方取中法
   1. 取关键字的**平方值的中间几位**作为散列地址
      1. 具体取多少位要视实际情况而定。
   2. 这种方法得到的散列地址与关键字的**每位都有关系**，因此使得散列地址**分布比较均匀**
   3. 适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。

## 7.5.3 处理冲突的方法

1. 拉链法(链接法，chaining)
   1. ![20220927212945](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220927212945.png)
   2. 对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个**线性链表**中
   3. 这个线性链表由其**散列地址**唯一标识
   4. 拉链法适用于**经常进行插入和删除**的情况

2. 开放定址法
   1. 所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为

        $H_i = (H(key) + d_i) \mod m$

       1. $H(key)$为散列函数;
       2. $i=0,1,2,...,k(k \le m-1)$
       3. $m$表示散列表表长;
       4. $d_i$为增量序列

   2. 取定某一增量序列后，对应的处理方法就是确定的。通常有以下4种取法
       1. 线性探测法
          1. ![20220927213340](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220927213340.png)
          2. 当$d_i=0,1,2,...,m-1$时，称为线性探测法
          3. 特点
             1. 冲突发生时，顺序查看表中下一个单元(探测到表尾地址时，下一个探测地址是表首地址0),直到找出一个空闲单元(当表未填满时一定能找到一个空闲单元)或查遍全表
          4. 缺点
             1. 线性探测法可能使第i个散列地址的同义词存入第i+ 1个散列地址，这样本应存入第i + 1个散列地址的元素就争夺第i + 2个散列地址的元素的地址……从而造成大量元素在相邻的散列地址上"聚集"(或堆积)起来,**大大降低了查找效率**
       2. 平方探测法
          1. 当$d_i=0^2,1^2,{-1}^2,2^2,{-1}^2...k^2,-k^2$时，称为平方探测法
             1. 其中$k<m/2$,散列表长度m必须是一个可以表示成$4k+ 3$的素数，又称二次探测法
          2. 特点
             1. 平方探测法是一种处理冲突的较好方法，可以**避免出现“堆积”问题**
          3. 缺点
             1. 不能探测到散列表上的所有单元，但至少能探测到**一半单元**
       3. 再散列法（再哈希法)
          1. 除了原始的散列函数H(key)之外，多准备几个散列函数,当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止

                $H=RH(Key) i=1,2,3....,k$
       4. 伪随机序列法
          1. 当$d_i=$伪随机数序列
       5. Tips:
          1. 在开放定址的情形下，不能随便物理删除表中的已有元素，因为若删除元素，则会**截断其他具有相同散列地址的元素的查找地址**。因此，要删除一个元素时，可给它做一个删除标记,进行逻辑删除。
          2. 但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置未利用，因此需要定期维护散列表，要把删除标记的元素物理删除。

## 7.5.4 散列查找及性能分析

1. 查找: 初始化：Addr=Hash(key);
   1. 检测查找表中地址为Addr的位置上是否有记录
      1. 若无记录，返回查找失败
      2. 若有记录,比较它与key的值
         1. 若相等，则返回查找成功标志
         2. 否则执行步骤2
   2. 用给定的处理冲突方法计算“下一个散列地址”, 并把Addr置为此地址，转入步骤1

2. 散列表的查找效率取决于三个因素
   1. 散列函数
   2. 处理冲突的方法
   3. 装填因子
      1. 一般记为$\alpha$,定义为一个表的装满程度

        $\displaystyle \alpha = \frac{表中记录数n}{散列表长度m}$

        散列表的平均查找长度依赖于散列表的装填因子$\alpha$,而不直接依赖于$n$或$m$。

        直观地看,越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小

3. ASL
   1. 成功
      1. ![20220905004301](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905004301.png)
   2. 不成功
      1. ![20220905004237](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905004237.png)

## 习题 done选择题

⭐

- 06![20220905211835](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905211835.png)
- 01 支持顺序查找![20220905211202](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905211202.png)
- 03在开放定址时![20220905211306](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905211306.png)
- 05同义词相邻情况,链地址不聚集![20220905211528](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905211528.png)
- 09发生聚集的原因![20220905212030](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905212030.png)
- 12 0-16的原因![20220905212123](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905212123.png)
- 18 失败ASL的计算(探测个数=p)![20220905214548](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905214548.png)

## 应用题 done

⭐

- 04要求装填因子但不为整数![20220906213125](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220906213125.png)

- 05REX函数![20220906214313](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220906214313.png)
- 2-(2)能作为散列函数![20220905225329](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905225329.png)

- 3
  - (1)线性探测法ASL失败![20220905225627](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905225627.png)
  - (2)链接法ASL失败的两种计算![20220905230325](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905230325.png)

## 真题

- 6-(2)
  - old mistakes查找失败的坑
  - 线性探测再散列法- 其实就是线性探测法
  - ![20220905222903](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220905222903.png)
