# 7.3 树型查找

- [7.3 树型查找](#73-树型查找)
  - [7.3.1 二叉排序树Binary Search Tree](#731-二叉排序树binary-search-tree)
  - [7.3.2 平衡二叉树 Balanced Biary Tree || AVL树(Adelson-Velsky and Landis Tree)](#732-平衡二叉树-balanced-biary-tree--avl树adelson-velsky-and-landis-tree)
  - [习题](#习题)

## 7.3.1 二叉排序树Binary Search Tree

- 二叉排序树![20220831220139](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220831220139.png)

1. 二叉排序树的定义
   1. 二叉排序树(也称二叉查找树)或者是一棵空树
   2. 或者是具有下列特性的二叉树:
      1. 若左子树非空, 则左子树上所有结点的值均小于根结点的值
      2. 若右子树非空, 则右子树上所有结点的值均大于根结点的值
      3. 左、右子树也分别是一棵二叉排序树。

2. 查找
   1. 二叉排序树的查找, 从根结点开始, 沿某个分支逐层向下比较的过程:
      1. 若二叉排序树非空, 先将给定值与根结点的关键字比较
         1. 若相等, 则查找成功;
         2. 若不等
            1. 如果小于根结点的关键字, 则在根结点的左子树上查找
            2. 否则在根结点的右子树上查找。

3. 二叉排序树的插入
   1. 二叉排序树作为一种动态树表, 其特点是树的结构通常不是一次生成的, 而是在查找过程中,  当树中不存在关键字值等于给定值的结点时再进行插入的
   2. 插入结点的过程如下：
      1. 若原二叉排序树为空, 则直接插入结点
      2. 否则
         1. 若关键字k小于根结点值, 则插入到左子树
         2. 若关键字k大于根结点值, 则插入到右子树
         3. 插入的结点一定是一个新添加的叶结点, 且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子

4. 二叉排序树的构造
   1. 从一棵空树出发, 依次输入元素, 将它们插入二叉排序树中的合适位置

5. 二叉排序树的删除
   1. 在二叉排序树中删除一个结点时, 不能把以该结点为根的子树上的结点都删除, 必须先把被删除结点从存储二叉排序树的链表上摘下, 将因删除结点而断开的二叉链表重新链接起来, 同时**确保二叉排序树的性质不会丢失**。
   2. 删除操作的实现过程按3种情况来处理
      1. 若被删除结点$z$是叶结点, 则直接删除, 不会破坏二叉排序树的性质。
      2. 若结点$z$只有一棵左子树或右子树, 则让$z$的子树成为$z$父结点的子树, 替代$z$的位置
      3. 若结点$z$有左、右两棵子树, 则令$z$的直接后继(或直接前驱)替代$z$,然后从二叉排序树中删去这个直接后继(或直接前驱), 这样就转换成了第一或第二种情况
      - 二叉排序树的删除![二叉排序树的删除](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220831222202.png)

6. 二叉排序树的查找效率分析
   1. 二叉排序树的查找效率, 主要取决于**树的高度**
   2. 若二叉排序树的左、右子树的高度之差的绝对值不超过1,则这样的二叉排序树称为平衡二叉树, 它的平均查找长度为$O(log_2n)$
   3. 若二叉排序树是一个只有右(左)孩子的单支树(类似于有序的单链表), 则其平均查找长度为$O(n)$

7. 二叉排序树 VS 二分查找
   1. 二叉排序树无须移动结点, 只需修改指针即可完成插入和删除操作, 平均执行时间为$O(log_2n)$
   2. 二分查找的对象是有序顺序表, 若有插入和删除结点的操作, 所花的代价是$O(n)$
      1. 若有序表是静态查找表, 宜用顺序表作为其存储结构,而采用二分查找实现其查找操作
      2. 若有序表是动态查找表, 应采用二叉排序树作为其逻辑结构

- code

```c
BSTNode *BST_Search(BiTree T, ElemType key)
{
   while (T != NULL && key != T->data)
   {
      if (key < T->data)
         T = T->lchild; //小于,则在左子树上寻找
      else
         T = T->rchild; //大于,则在右子树上寻找
   }
   return T;
}

int BST_Insert(BiTree &T, KeyType k)
{
   if (T == NULL)
   {
      T = (BiTree)malloc(sizeof(BSTNode));
      T->data = k;
      T->lchild = T->rchild = NULL;
      return 1;
   }
   else if (K == T->data) //树中存在相同关键字的结点,插入失败
      return 0;
   else if (T < T->data)
      return BST_Insert(T->lchild, k); //插入到T的左子树
   else
      return BST_Insert(r->lchild, k); //插入到T的右子树
}

void Create_BST(BiTree &T, KeyType str[], int n)
{
   T = NULL; //初始时T为空树

   int i = 0;
   while (i < n)
   { //依次将每个关键字插入到二叉排序树中
      BST_Insert(T, str[i]);
      i++;
   }
}
```

## 7.3.2 平衡二叉树 Balanced Biary Tree || AVL树(Adelson-Velsky and Landis Tree)

- RR型![RR型](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901004853.png)
- RL型
  - RL1![RL1](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901005303.png)
  - RL2![RL2](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901005325.png)
- LR型![LR型](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901010447.png)

1. 定义
   1. 要保证任意结点的左、右子树高度差的**绝对值不超过1**,将这样的二叉树称为平衡二叉树

2. 平衡二叉树的插入
   1. 精简版: 左旋失去左分支, 右旋失去右分支
      1. LL转右
         1. 不平衡结点右结点
      2. RR转左
         1. 不平衡结点左结点
      3. LR左右
         1. 不平衡结点左孩子的右孩子
      4. RL右左
         1. 不平衡结点右孩子的左孩子
   2. LL平衡旋转(右单旋转
      1. 由于在结点的左孩子(L)的左子树(L)上插入了新结点,A的平衡因子由1增至2,导致以A为根的子树失去平衡，需要一次向右的旋转操作
         1. **将A的左孩子B**向右上旋转代替A成为根结点
         2. 将A结点向右下旋转成为B的右子树的根结点
         3. 而B的原右子树则作为A结点的左子树
      2. ![LL平衡旋转](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901011441.png)
   3. RR平衡旋转(左单旋转)
      1. 由于在结点A的右孩子(R)的右子树(R)上插入了新结点,A的平衡因子由-1减至-2,导致以A为根的子树失去平衡，需要一次向左的旋转操作
         1. **将A的右孩子B**向左上旋转代替A成为根结点
         2. 将A结点向左下旋转成为B的左子树的根结点
         3. 而B的原左子树则作为/结点的右子树
      2. ![RR平衡旋转](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901011708.png)
   4. LR平衡旋转(先左后右双旋转)
      1. 由于在A的左孩子(L)的右子树(R)上插入新结点，A的平衡因子由1增至2,导致以A为根的子树失去平衡，需要进行两次旋转操作
         1. 先左旋转后右旋转
         2. 先将**A结点的左孩子B的右子树的根结点C**向左上旋转提升到B结点的位置
         3. 然后把该C结点向右上旋转提升到A结点的位置
      2. ![LR平衡旋转](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901012034.png)
   5. RL平衡旋转(先右后左双旋转
      1. 由于在A的右孩子(R)的左子树(L)上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作
         1. 先右旋转后左旋转
         2. 先**将A结点的右孩子B的左子树的根结点C**向右上旋转提升到B结点的位置
         3. 然后把该C结点向左上旋转提升到A结点的位置
      2. ![RL平衡旋转](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901012147.png)
   6. Tips:
      1. 每次调整的对象都是**最小不平衡子树**，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树
      2. LR和RL旋转时，新结点究竟是插入C的左子树还是插入C的右子树**不影响旋转过程**，而图7.13和图7.14中以插入C的左子树中为例。

3. 平衡二叉树的查找
   1. 在平衡二叉树上进行查找的过程与二叉排序树的相同, 因此，在查找过程中，与给定值进行比较的关键字个数不超过**树的深度**
   2. 假设$n_h$表示深度为$h$的平衡树中含有的最少结点数,有
      1. $n_h=n_{h-1}+n_{h-2}+1$
   3. 含有$n$个结点的平衡二叉树的最大深度为$O(log_2n)$,因此平衡二叉树的平均查找长度为$O(log_2n)$

4. 平衡二叉树的删除
   1. 用二叉排序树的方法对结点$w$执行删除操作
   2. 检查树中有无不平衡结点, 对即最小不平衡子树进行调整
   3. 例子
      1. ![20220901232728](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901232728.png)

## 习题

⭐

- 11含有n个结点的平衡二叉树最大高度![20220901214202](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901214202.png)

- 23 插入结点算平衡因子, 嗯算![20220901230218](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901230218.png)
- 26 注意平衡二叉树和平衡排序树的区别![20220901231128](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901231128.png)
  - A![20220924230654](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220924230654.png)

- 05 不可能的二叉排序树序列![20220901214331](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901214331.png)
- 21 非叶子结点不平衡因子皆为1, 说明满足平衡树中含有最少结点数情况![20220901225918](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901225918.png)
- 24 最后插入的节点不一定是叶子结点![20220901230418](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220901230418.png)
