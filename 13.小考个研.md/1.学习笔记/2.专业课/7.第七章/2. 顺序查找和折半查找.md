# 7.2 顺序查找和折半查找

- [7.2 顺序查找和折半查找](#72-顺序查找和折半查找)
  - [7.2.1 顺序查找](#721-顺序查找)
    - [1. 一般线性表的顺序查找](#1-一般线性表的顺序查找)
    - [2. 有序表的顺序查找](#2-有序表的顺序查找)
  - [7.2.2 折半查找](#722-折半查找)
  - [7.2.3分块查找](#723分块查找)
  - [习题选择题](#习题选择题)

## 7.2.1 顺序查找

1. 顺序查找又称线性查找，它对**顺序表和链表**都是适用的。
   1. 对于顺序表，可通过数组下标递增来顺序扫描每个元素;
   2. 对于链表，可通过指针next来依次扫描每个元素。
2. 顺序查找通常分为对
   1. 一般的**无序**线性表的顺序查找
   2. 对**按关键字有序**的线性表的顺序查找。

### 1. 一般线性表的顺序查找

- code

```c
typedef struct
{
   ElemType *elem; //元素的存储空间基址, 建表时按实际长度分配
   int TableLen;   //表的长度
} SStable;

int Search_Seq(SStable ST, ElemType key)
{
   ST.elem[0] = key; //光明哨兵
   for (int i = ST.TableLen; ST.elem[i] != key; --i); //从后往前找
   return i;//若表中不存在关键字为key的元素,将查找到i为0时退出for循环
}
```

1. 定义
   1. 从线性表的一端开始，逐个检查关键字是否满足给定的条件。
      1. 若查找到某个元素的关键字满足给定条件
         1. 则查找成功，返回该元素在线性表中的位置
      2. 若已经查找到表的另一端，但还没有查找到符合给定条件的元素
         1. 则返回查找失败的信息

2. ASL
   1. 对于有$n$个元素的表，给定值key与表中第$i$个元素相等，即定位第$i$个元素时，需进行$n-i+1$次关键字的比较，即$C=n-i+1$
   2. 查找成功时，顺序查找的平均长度为

        $\displaystyle ASL_{success}\sum_{i=1}^{n}P_i(n-i-1)=\frac{n+1}{2}$

   3. 查找不成功时

        $ASL_{fail}=n+1$

3. Tips:
   1. 对线性的链表只能进行顺序查找

### 2. 有序表的顺序查找

1. 基本思想
   1. 假设表L是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key
      1. 当查找到第i个元素时，发现第i个元素对应的关键字小于key
      2. 但第i + 1个元素对应的关键字大于key
   2. 这时就可返回查找失败的信息

2. 判定树
   1. 可以用如图7.1所示的判定树来描述有序线性表的查找过程。
      1. 树中的圆形结点表示有序线性表中存在的元素
      2. 树中的矩形结点称为失败结点(若有$N$个结点，则相应地有$N+1$个查找失败结点)，它描述的是那些不在表中的数据值的集合。
   2. 若查找到失败结点，则说明查找不成功。

    ![图7.1](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220829173726.png)

3. ASL
   1. 查找不成功的平均查找长度在相等查找概率的情形下为

        $\displaystyle ASL_{fail}\sum_{j=1}^{n}q_j(l_j-1)=\frac{1+2+...+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$

        1. $q_j$是到达第$j$个失败结点的概率，在相等查找概率的情形下，它为$\displaystyle \frac{1}{n+1}$
        2. $l_j$是第$j$个失败结点所在的层数

   2. 查找成功与一般线性表的顺序查找一样

## 7.2.2 折半查找

- code

```c
int Binary_Search(SeqList L, ElemType key)
{
   int low = 0, high = L.TableLen - 1;
   mid;
   while (low <= high)
   {
      mid = (low + high) / 2; //取中间位置
      if (L.elem[mid] == key)
         return mid;
      else if (L.elem[i] > key)
         high = mid - 1; //从前半部分查找
      else
         low = mid + 1; //从后半部分查找
   }
   return -1; //查找失败
}
```

1. 折半查找又称二分查找，它仅适用于有序的顺序表

2. 基本思想
   1. 首先将给定值key 与表中中间位置的元素比较
      1. 若相等，则查找成功，返回该元素的存储位置;
      2. 若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分
   2. 然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息

3. 判定树
   1. 折半查找的过程可用图7.2所示的二叉树来描述，称为判定树。
      1. 树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；
      2. 树中最下面的叶结点都是方形的，它表示查找不成功的情况。
   2. 从判定树可以看出
      1. 查找成功时的查找长度
         1. 从根结点到目的结点的路径上的**结点数**
      2. 而查找不成功时的查找长度为
         1. 从根结点到对应失败结点的父结点的路径上的结点数；
      3. 每个结点值均大于其左子结点值，且均小于于其右子结点值。
      4. 若有序序列有n个元素
         1. 则对应的判定树有n个圆形的**非叶结点**
         2. 和n+1个方形的**叶结点**。
      5. 判定树是一棵**平衡二叉树**。

   ![20220830204715](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220830204715.png)

4. 时间复杂度⭐⭐⭐平均查找长度等于$\lceil log_2(n+1)\rceil$?
   1. 判定树高度为$\lceil log_2(n+1)\rceil$(等同于完全二叉树的高度)
   2. 查找成功的$ASL \le h$
   3. 查找失败的$ASL \le h$
   4. 故折半查找的时间复杂度=$O(log_2n)$

## 7.2.3分块查找

1. 分块查找
   1. 又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。

2. 基本思想:
   1. 将查找表分为若干子块
      1. **块内**的元素可以**无序**，但**块之间是有序的**
      2. 即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推
   2. 再建立一个索引表
      1. 索引表中的每个元素含有
         1. 各块的最大关键字
         2. 各块中的第一个元素的地址
      2. 索引表按关键字有序排列

3. 时间复杂度
   1. 分块查找的平均查找长度为索引查找和块内查找的平均长度之和。
      1. 设索引查找和块内查找的平均查找长度分别为$L_1,L_s$，则分块查找的平均查找长度为
         $\displaystyle ASL=L_1+L_S$
   2. 将长度为n的查找表均匀地分为b块，每块有s个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度

      $\displaystyle ASL=L_1+L_S=\frac{b+1}{2}+\frac{s+1}{2} = \frac{s^2+2s+n}{2s}$

      此时,若$s=\sqrt{n}$,则平均查找长度为$\sqrt{n}+1$

   3. 若对索引表采用折半查找时，则平均查找长度为

      $\displaystyle ASL = L_1+L_s = \lceil log_2(n+1)\rceil +\frac{s+1}{2}$

## 习题选择题

⭐⭐⭐⭐

08 二叉排序树,未学![20220830233917](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220830233917.png)

19 二叉排序树![20220831002048](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220831002048.png)

⭐⭐

17查找效率最高![20220831000731](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220831000731.png)

⭐

09 基本折半查找![20220830234036](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220830234036.png)

16 顺序法存储元素![20220831000600](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220831000600.png)
