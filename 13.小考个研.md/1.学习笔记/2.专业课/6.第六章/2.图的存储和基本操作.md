# 2.图的存储和基本操作

考试常见要点:

![20220819011132](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220819011132.png)

- [2.图的存储和基本操作](#2图的存储和基本操作)
  - [6.2.1 邻接矩阵法](#621-邻接矩阵法)
  - [6.2.2 邻接表法](#622-邻接表法)
  - [6.2.3 十字链表(大纲不要求)](#623-十字链表大纲不要求)
  - [6.2.4 邻接多重表(大纲不要求)](#624-邻接多重表大纲不要求)
  - [6.2.5 图的基本操作](#625-图的基本操作)
  - [习题(done)](#习题done)

## 6.2.1 邻接矩阵法

- 有向图, 无向图 及网的邻接矩阵
  - ![有向图, 无向图 及网的邻接矩阵](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220930215506.png)

1. 定义
   1. 邻接矩阵存储，是指
      1. 用一个一维数组存储图中**顶点的信息**
      2. 用一个二维数组存储图中**边的信息**(即各顶点之间的邻接关系
      3. 存储顶点之间邻接关系的二维数组称为**邻接矩阵**

- 结点数为n的图$G=(V, E)$的邻接矩阵A是$n × n$的。将G的顶点编号为$v_1,v_2,...,v_n$. 若$(v_i,v_j) \in E$, 则$A[i] [j]=1$, 否则$A[i] [j]=0$

$$A[i] [j]\begin{cases}
1 & 若(v_i,v_j)或<v_i,v_j>是E(G)中的边 \\
0 & 若(v_i,v_j)或<v_i,v_j>不是E(G)中的边
\end{cases}$$

- 对于带权图而言,若顶点$v_i$和$v_j$之间有边相连,则邻接矩阵中对应项存放着该边对应的权值，若顶点$v_i$和$v_j$不相连，则用$\infty$来代表这两个顶点之间不存在边:

$$A[i] [j]\begin{cases}
w_{ij} & 若(v_i,v_j)或<v_i,v_j>是E(G)中的边 \\
0 or \infty & 若(v_i,v_j)或<v_i,v_j>不是E(G)中的边
\end{cases}$$

- 图的存储结构定义如下

```c
#define MaxVertexNum 100 //顶点数目的最大值
typedef char VertexType; //顶点的数据类型
typedef int EdgeType;    //带权图中边上权值的数据类型
typedef struct
{
   VertexType Vex[MaxVertexNum];              //顶点表
   EdgeType Edge[MaxVertexNum][MaxVertexNum]; //邻接矩阵，边表
   int vexnum, arcnum;                        //图的当前顶点数和弧数
} MGraph;
```

Tips:

1. 在简单应用中，可直接用**二维数组**作为图的邻接矩阵(顶点信息等均可省略
2. 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可采用值为**0和1**的枚举类型
3. 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用**压缩存储**
4. 邻接矩阵表示法的空间复杂度为$O(n^2)$,其中n为图的顶点数$|V|$

图的邻接矩阵存储表示法具有以下特点∶

1. 无向图的邻接矩阵一定是一个**对称矩阵**(并且唯一)。因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。
2. 对于无向图
   1. 邻接矩阵的第$i$行(或第$i$列)非零元素(或非$\infty$元素)的个数正好是顶点$i$的度$TD(v)$。
3. 对于有向图
   1. (行行出状元)邻接矩阵的第$i$行非零元素(或非$\infty$元素)的个数正好是顶点$i$的出度$OD(v)$;
   2. 第$i$列非零元素(或非$\infty$元素)的个数正好是顶点$i$的入度$ID(v)$;
4. 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的**时间代价很大**。
5. **稠密图**适合使用邻接矩阵的存储表示
6. 设图$G$的邻接矩阵为$A$, $A^n$的元素$A^n[i] [j]$等于由顶点i到顶点j的长度为n的路径的数目。
   1. example![example](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220819212321.png)

## 6.2.2 邻接表法

- ![邻接表](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220820212955.png)

1. 为何定义邻接表
   1. 当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大**减少**了这种不必要的**浪费**。

2. 定义
   1. 指对图G中的每个顶点h建立一个单链表
      1. 第i个单链表中的结点表示
         1. 依附于顶点H的**边**
      2. 对于有向图则是
         1. 以顶点i**为尾的弧**
   2. 这个单链表就称为顶点H的**边表**
      1. 对于有向图则称为出边表

3. 结点定义
   1. 顶点表结点
      1. [data] [firstarc]
      2. 顶点域 边表头指针
   2. 边表结点
      1. [adjvex] [nextarx]
      2. 领接点域 指针域

4. 存储结构定义

   ```c
   #define MaxVertexNum 100 //图中顶点数目的最大值

   //边表结点
   typedef struct ArcNode
   {
      int adjvex;           //该弧所指向的顶点的位置
      struct ArcNode *next; //指向下一条弧的指针
      //InfoType info;      //网的边权值
   } ArcNode;

   //顶点表结点
   typedef struct VNode
   {
      VertexType data; //顶点信息
      ArcNode *first;  // 指向第一条依附该顶点的弧的指针
   } VNode, AdjList[MaxVertexNum];

   typedef struct
   {
      AdjList vertices;   //邻接表
      int vexnum, arcnum; //图的顶点数和弧数
   } ALGraph;             // ALGraph 是以邻接表存储的图类型
   ```

5. 特点
   1. 存储空间
      1. 无向图$O(\vert V \vert+ 2 \vert E \vert)$;
      2. 有向图$O(\vert V\vert+\vert E\vert)$
   2. 对于稀疏图
      1. 采用邻接表表示将极大地**节省存储空间**。
   3. 在邻接表中(无向图)
      1. 对于邻边
         1. 给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表
         2. 在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为$O(n)$
      2. 两顶点是否存在边
         1. 邻接表中则需要在相应结点**对应的边表中查找另一结点，效率较低**
         2. 则在邻接矩阵中可以**立刻查到**
   4. 在有向图的邻接表表示中
      1. 求一个给定顶点的**出度**只需计算其邻接表中的结点个数;
      2. 但求其顶点的**入度**则需要遍历全部的邻接表。
   5. 图的邻接表表示并**不唯一**，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。

- 邻接表及领接矩阵的对比

--|邻接表|邻接矩阵
--|--|--|
计算度/出度/入度|除计算有向图的入度不方便|必须遍历对应行或列|
找相邻的边|除找有向图的入边不方便|必须遍历对应行或列

## 6.2.3 十字链表(大纲不要求)

![十字链表](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220820222604.png)

1. 存在原因
   1. 解决领接矩阵空间复杂度高问题
   2. 解决领接表法找入边难问题

2. 定义
   1. 十字链表是有向图的一种链式存储结构。
      1. 在十字链表中
         1. 对应于有向图中的每条弧有一个结点
         2. 对应于每个顶点也有一个结点

3. 结点结构
   1. 弧结点: [tailvex] [headvex] [hlink] [tlink] [info]
      1. 尾域tailvex: 指示弧尾;
      2. 头域headvex: 指示弧头;
      3. 链域hlink: 指向弧头相同的下一条弧;
      4. 链域tlink: 指向弧尾相同的下一条弧;
      5. info域: 指向该弧的相关信息
   2. 顶点结点: [data] [firstin] [firstout]
      1. data域: 存放顶点相关的数据信息，如顶点名称;
      2. firstin:  以该顶点为弧头的第一个狐结点
      3. firstout: 以该顶点为弧尾的第一个弧结点

4. 空间复杂度
   1. $O(|V|+|E|)$

## 6.2.4 邻接多重表(大纲不要求)

![20220820223020](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220820223020.png)

1. 存在原因
   1. 领接矩阵空间复杂度高
   2. 邻接表每条边对应两份冗余信息
      1. 删除顶点
      2. 删除边
      3. 求两个顶点之间是否存在边等操作的时间复杂度高

2. 定义
   1. 邻接多重表是无向图的另一种链式存储结构
      1. 邻接多重表中
         1. 对应于无向中的每条边有一个结点
         2. 对应于每个顶点也有一个结点

3. 结点结构
   1. 边结点: [mark] [ivex] [ilink] [jvex] [jlink] [info]
      1. mark为标志域: 可用以标记该条边是否被搜索过
      2. ivex和jvex为该边依附的两个顶点在图中的位置
      3. ilink: 指向下一条依附于顶点ivex的边
      4. jlink: 指向下一条依附于顶点jvex的边
      5. info:  指向和边相关的各种信息的指针域
   2. 顶点域: [data] [firstedge]
      1. data域: 存储该顶点的相关信息
      2. firstedge: 域指示第一条依附于该顶点的边

4. 空间复杂度
   1. $O(|V|+|E|)$

## 6.2.5 图的基本操作

- 图的基本操作主要包括（仅抽象地考虑，故忽略掉各变量的类型)

1. Adjacent(G, x, y): 判断图G是否存在边<x, y>或(x, y)。
2. Neighbors(G, x): 列出图G中与结点x邻接的边
3. Insertvertex(G, x): 在图G中插入顶点x。
4. Deletevertex(G, x): 从图G中删除顶点x。
5. AddEdge(G,x,y): 若无向边(x, y)或有向边<x, y>不存在，则向图G中添加该边
6. RemoveEdge(G,x,y): 若无向边(x, y)或有向边<x, y>存在，则从图G中删除该边
7. FirstNeighbor(G,x): 求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
8. NextNeighbor(G,x, y): 假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。
9. Get_edge_value(G,x, y): 获取图G中边(x, y)或<x, y>对应的权值。
10. Set_edge_value(G,x,y,v): 设置图G中边(x, y)或<x, y>对应的权值为v。

## 习题选择题(done)

⭐⭐

01拓扑序列 依次递增![20220821215059](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220821215059.png)

13 有向图删除时间复杂度 ![20220821221217](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220821221217.png)

⭐

11 边表结点 data:弧所指向的顶点![20220821220949](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220821220949.png)

14 求有向图的度 ![20220821221335](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220821221335.png)

## 解答题

⭐⭐

06 1.正确表达2.无论如何要有返回的结果![20220821233247](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220821233247.png)

04 邻接表转邻接矩阵![20220821224808](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220821224808.png)

⭐

3 02 ij顶点有边相连![20220821224519](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220821224519.png)

05 ![20220821233005](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220821233005.png)