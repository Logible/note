# 6.4 图的应用

- [6.4 图的应用](#64-图的应用)
  - [6.4.1 最小生成树](#641-最小生成树)
  - [6.4.2 最短路径](#642-最短路径)
    - [Breadth-First-Search求解单源最短路径问題](#breadth-first-search求解单源最短路径问題)
    - [Dijkstra 算法求单源最短路径问题](#dijkstra-算法求单源最短路径问题)

## 6.4.1 最小生成树

1. 定义
   1. 对于一个带权连通无向图G=(V,E), 生成树不同, 每棵树的权(即树中所有边上的权值之和)也可能不同。
   2. 设R为G的所有生成树的集合, 若T为R中边的权值之和最小的那棵生成树, 则T称为G的**最小生成树**(Minimum-Spanning-Tree, MST)。

2. 性质
   1. 最小生成树不是唯一的，即最小生成树的树形**不唯一**
   2. 最小生成树的边的权值之和总是唯一的，虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是**最小的**
   3. 最小生成树的边数为**顶点数减1**

- Prim算法(普里姆)︰

1. 步骤
   1. 从某一个顶点开始构建生成树;
   2. 每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。

2. 时间复杂度:$O(|V|^2)$
   1. 从$V_0$开始, 总共需要n-1轮处理
   2. 每一轮需要循环遍历更新还没加入的各个顶点的lowcast值
   3. $O(n)*O(n-1)=O(n^2)$

3. 适用图
   1. 适合用于**边稠密图**

- Kruskal算法(克鲁斯卡尔):

1. 步骤
   1. 每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)
   2. 直到所有结点都连通

2. 时间复杂度:$O(|E|log_2|E|)$
   1. 将各条边按照权值排序, 共执行e轮
   2. 每轮判断两个顶点是否属于同一集合,需要$O(log_2e)$

3. 适用图
   1. 适合用于**边稀疏**而**顶点较多**的图

## 6.4.2 最短路径

1. 无向图定义
   1. 若图$G =(V,E)$为非带权图，定义从顶点u到顶点v的最短路径$d(u, v)$为从$u$到$v$的任何路径中最少的边数;
   2. 若从$u$到$v$没有通路, 则$d(u,v)=\infty$。

2. 有向图定义
   1. 带权路径长度
      1. 当图是带权图时，把从一个顶点巾到图中其余任意一个顶点$V_i$的一条路径(可能不止一条)所经过边上的权值之定义为该路径的带权路径长度
   2. 把**带权路径长度最短**的那条路径称为**最短路径**。

3. 带权有向图G的最短路径问题一般可分为两类：
   1. 一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra （迪杰斯特拉）算法求解
   2. 二是求每对顶点间的最短路径，可通过Floyd （弗洛伊德）算法来求解

### Breadth-First-Search求解单源最短路径问題

- example![20220825020816](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020816.png)

- example answer![20220825020900](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020900.png)

1. 使用BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题
2. 这是由广度优先搜索总是按照距离**由近到远**来遍历图中每个顶点的性质决定的。
3. 只适合**无权图**

BFS算法求解单源最短路径问题的算法如下:

```C
void BFS_MIN_Distance(Graph G, int v)
{
    //d[i]表示从u到i结点的最短路径
   for (i = 0; i < G.vexnum; i++)
   {
      d[i] = "∞";
   }

   d[v] = 0;
   visited[v] = true; //对v做已访问标记
   EnQueue(Q, v);     //顶点V入队列

   while (!isEmpty(Q))
   {
      Dequeue(Q, v);                                                   //顶点v出队列
      for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) //检测v所有邻点
      {
         if (!visited[w]) // w为v的尚未访问的邻接顶点
         {
            d[w] = d[u] + 1;
            visited[w] = true;
            EnQueue(Q, W); //顶点w入队列
         }
      }
   }
}
```

### Dijkstra 算法求单源最短路径问题

- example![example](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020221.png)

- exampleAnswer![exampleAnswer](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020251.png)

1. 辅助数组
   1. dist[ ]
      1. 记录从源点$v_0$到其他各顶点当前的最短路径长度
      2. 它的初态为
         1. 若从$v_0$到$v_i$有弧，则dist[i]为弧上的权值
         2. 否则置dist[i]为$\infty$.
   2. path[ ]
      1. 表示从源点到顶点$i$之间的最短路径的前驱结点
      2. 在算法结束时，可根据其值追溯得到源点$v_0$到顶点$v_i$的最短路径

2. 邻接矩阵arcs表示带权有向图
   1. $arcs[i][j]$表示有向边$<i,j>$的权值
   2. 若不存在有向边则$arcs[i][j]$为$\infty$

3. 时间复杂度
   1. $O(|V|^2)$
   2. 步骤2找到dist最小顶点$v_j$花费$O(n)$,步骤3更新dist数组需扫描全部顶点$O(n)$,共$O(2n)$
   3. 步骤4,操作共$n-1$次,花费$O(n-1)$
   4. 共花费$O(2n) * O(n-1) = O(n^2)$

4. Tips:
   1. 边上带有**负权值**时, Dijkstra算法并不适用
   2. example
      1. ![20220825020053](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020053.png)

- 算法步骤(不考虑对path[]的操作)

假设从顶点0出发，即$V_0=0$, 集合S最初只包含顶点0

1. 初始化：集合S初始为{0}, dist[] 的初始值$\displaystyle dist[i]=arcs[0] [i], i=1, 2, ..., n-1$
2. 从顶点集合$V-S$中选出$v_j$, 满足
   1. $\displaystyle dist[i]=Min\{dist[i] \vert v_i \in V-S\}$
   2. $v_j$就是当前求得的一条从$v_0$出发的最短路径的终点,令$S=S\cup{j}$
3. 修改从$v_0$出发到集合任一顶点$v_k$可达的最短路径长度
   1. 若$\displaystyle dist[j] + arcs[j][k] < dist[k]$
      1. 则更新$\displaystyle dist[k]=dist[j] + arcs[j][k]$
      2. $path[k] = j$
4. 重复2-3,操作共$n-1$次,. 直到所有的顶点都包含在$S$中
