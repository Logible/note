# 6.4 图的应用

- [6.4 图的应用](#64-图的应用)
  - [6.4.1 最小生成树](#641-最小生成树)
    - [1.Prim算法(普里姆)](#1prim算法普里姆)
    - [2.Kruskal算法(克鲁斯卡尔)](#2kruskal算法克鲁斯卡尔)
  - [6.4.2 最短路径](#642-最短路径)
    - [0.Breadth-First-Search求解单源最短路径问題](#0breadth-first-search求解单源最短路径问題)
    - [1.Dijkstra 算法求单源最短路径问题](#1dijkstra-算法求单源最短路径问题)
    - [2.Floyd算法求各顶点之间最短路径问题](#2floyd算法求各顶点之间最短路径问题)
  - [6.4.3 有向无环图描述表达式 Direction Acyclic Graph](#643-有向无环图描述表达式-direction-acyclic-graph)
  - [习题选择题](#习题选择题)
  - [真题](#真题)

## 6.4.1 最小生成树

1. 定义
   1. 对于一个带权连通无向图$G=(V,E)$, 生成树不同, 每棵树的权(即树中所有边上的权值之和)也可能不同。
   2. 设R为G的所有生成树的集合, 若T为R中**边的权值之和最小**的那棵生成树, 则T称为G的**最小生成树**(Minimum-Spanning-Tree, MST)。

2. 性质
   1. 最小生成树不是唯一的，即最小生成树的树形**不唯一**
   2. 最小生成树的边的权值之和总是唯一的，虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是**最小的**
   3. 最小生成树的边数为**顶点数减1**

### 1.Prim算法(普里姆)

- 普里姆算法示例![普里姆](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825215319.png)

- 算法机器实现![算法机器实现](https://raw.githubusercontent.com/Logible/Image/main/note_image/算法机器实现.png)

1. 步骤
   1. 初始时从图中任取一顶点开始构建生成树T;
   2. 每次将代价最小的新顶点**纳入生成树T**，直到所有顶点都纳入为止。

2. 时间复杂度:$O(|V|^2)$
   1. 从$V_0$开始, 总共需要n-1轮处理
   2. 每一轮处理:$O(2n)$
      1. 循环遍历所有结点，找到lowCost最低的，且还没加入树的顶点: $O(n)$
      2. 再次循环遍历，更新还没加入的各个顶点的lowCost值: $O(n)$
   3. $O(2n)*O(n-1)=O(n^2)$

3. 适用图
   1. 适合用于**边稠密图**
   2. Prim算法的时间复杂度为$O(|V|^2)$, 不依赖于$E$，因此它适用于求解边稠密的图的最小生成树。

### 2.Kruskal算法(克鲁斯卡尔)

![Kruskal算法示例](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825215635.png)

1. 步骤
   1. 每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)
   2. 直到所有结点都连通

2. 时间复杂度:$O(|E|log_2|E|)$
   1. 将各条边按照权值排序, 共执行e轮
   2. 每轮判断两个顶点是否属于同一集合,需要$O(log_2|E|)$

3. 适用图
   1. 适合用于**边稀疏**而**顶点较多**的图

## 6.4.2 最短路径

1. 无权图定义
   1. 若图$G =(V,E)$为非带权图，定义从顶点u到顶点v的最短路径$d(u, v)$为从$u$到$v$的任何路径中最少的边数;
   2. 若从$u$到$v$没有通路, 则$d(u,v)=\infty$。

2. 带权图定义
   1. 带权路径长度
      1. 当图是带权图时，把从一个顶点$v_0$到图中其余任意一个顶点$v_i$的一条路径(可能不止一条)所经过边上的权值之定义为该路径的**带权路径长度**
   2. 把**带权路径长度最短**的那条路径称为**最短路径**。

3. 带权有向图G的最短路径问题一般可分为两类：
   1. 一是单源最短路径
      1. 即求图中某一顶点到其他各顶点的最短路径，可通过经典的Dijkstra （迪杰斯特拉）算法求解
   2. 二是求每对顶点间的最短路径
      1. 可通过Floyd （弗洛伊德）算法来求解

### 0.Breadth-First-Search求解单源最短路径问題

- example![20220825020816](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020816.png)

- example answer![20220825020900](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020900.png)

1. 使用BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题
2. 这是由广度优先搜索总是按照距离**由近到远**来遍历图中每个顶点的性质决定的。
3. 只适合**无权图**

- BFS算法求解单源最短路径问题的算法如下:

1. 定义从顶点u到顶点v的最短路径d(u,v)为从u到v的任何路径中最少的边数;
2. 若从u到v没有通路，则$d(u,v)=\infty$

```C
void BFS_MIN_Distance(Graph G, int v)
{
    //d[i]表示从u到i结点的最短路径
   for (i = 0; i < G.vexnum; i++)
   {
      d[i] = "∞";
      path[i]=-1;
   }

   d[v] = 0;
   visited[v] = true; //对v做已访问标记
   EnQueue(Q, v);     //顶点V入队列

   while (!isEmpty(Q))
   {
      Dequeue(Q, v);                                                   //顶点v出队列
      for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) //检测v所有邻点
      {
         if (!visited[w]) // w为v的尚未访问的邻接顶点
         {
            d[w] = d[v] + 1;
            path[w]=[u];//最短路径应从u到w
            visited[w] = true;
            EnQueue(Q, W); //顶点w入队列
         }
      }
   }
}
```

### 1.Dijkstra 算法求单源最短路径问题

- example(注意区别权值)![example](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020221.png)

- exampleAnswer![exampleAnswer](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020251.png)

1. 辅助数组
   1. dist[ ]
      1. 记录从源点$v_0$到其他各顶点当前的最短路径长度
      2. 它的初态为
         1. 若从$v_0$到$v_i$有弧，则dist[i]为弧上的权值
         2. 否则置dist[i]为$\infty$.
   2. path[ ]
      1. 表示从源点到顶点$i$之间的最短路径的前驱结点
      2. 在算法结束时，可根据其值追溯得到源点$v_0$到顶点$v_i$的最短路径

2. 邻接矩阵arcs表示带权有向图
   1. $arcs[i] [j]$表示有向边$<i,j>$的权值
   2. 若不存在有向边则$arcs[i] [j]$为$\infty$

3. 时间复杂度
   1. $O(|V|^2)$
   2. 步骤2找到dist最小顶点$v_j$花费$O(n)$,步骤3更新dist数组需扫描全部顶点$O(n)$,共$O(2n)$
   3. 步骤4,操作共$n-1$次,花费$O(n-1)$
   4. 共花费$O(2n) * O(n-1) = O(n^2)$

- 算法步骤(不考虑对path[]的操作)

假设从顶点0出发，即$V_0=0$, 集合S最初只包含顶点0

1. 初始化：集合$S$初始为$0$, $dist[]$ 的初始值$\displaystyle dist[i]=arcs[0] [i], i=1, 2, ..., n-1$
2. 从顶点集合$V-S$中选出$v_j$, 满足
   1. $\displaystyle dist[i]=Min\{dist[i] \vert v_i \in V-S\}$
   2. $v_j$就是当前求得的一条从$v_0$出发的最短路径的终点,令$S=S\cup{j}$
3. 修改从$v_0$出发到集合任一顶点$v_k$可达的最短路径长度
   1. 若$\displaystyle dist[j] + arcs[j] [k] < dist[k]$
      1. 则更新$\displaystyle dist[k]=dist[j] + arcs[j] [k]$
      2. $path[k] = j$
4. 重复2-3,操作共$n-1$次,. 直到所有的顶点都包含在$S$中

- Tips:
   1. 边上带有**负权值**时, Dijkstra算法并不适用
   2. example
      1. ![20220825020053](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220825020053.png)

### 2.Floyd算法求各顶点之间最短路径问题

- example![20220826003443](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220826003443.png)

1. 求所有顶点之间的最短路径问题描述如下:
   1. 已知一个各边权值均大于0的带权有向图，对任意两个顶点$v_i \ne v_j$,要求求出$v_i$和$v_j$之间的**最短路径**和**最短路径长度**

2. 算法思想
   1. 初始时，对于任意两个顶点$v_i$和$v_j$(将矩阵A初始化为邻接矩阵数值)
      1. 若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度
      2. 若它们之间不存在有向边，则以$\infty$作为它们之间的最短路径长度。
   2. 之后逐步尝试在原路径中加入顶点$k(k=0,1,...,n-1)$作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径

   ```c
   //......准备工作，根据图的信息初始化矩阵A和path(如上图)

   for (int k = 0; k < n : k++) //考虑以 vk作为中转点
   {
      for (int i = 0; i < n; i++) //遍历整个矩阵，i为行号，j为列号
      {
         for (int j = 0; j < n; j++)
         {
            if (A[i][j] > A[i][k] + A[k][j]) //以vk为中转点的路径更短
            {
               A[i][j] = A[i][k] + A[k][j]; //更新最短路径长度
               path[i][j] = k;              //中转点
            }
         }
      }
   }
   ```

3. 适用范围
   1. Floyd算法允许图中有带负权值的边，但不允许有包含**带负权值的边组成的回路**。
   2. Floyd 算法同样适用于带权**无向图**
      1. 因为带权无向图可视为权值相同往返二重边的有向图。

4. 算法时间复杂度
   1. Floyd 算法的时间复杂度为$O(|V|^3)$。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。

5. 注
   1. 可用Dijkstra算法求所有顶点间的最短路径，重复$|V|$次即可，总的时间复杂度也是$O(V^3)$

## 6.4.3 有向无环图描述表达式 Direction Acyclic Graph

1. 定义
   1. 有向无环图：若一个有向图中**不存在环**，则称为有向无环图，简称DAG图

- 若利用有向无环图，则可实现对相同子式的共享，从而节省存储空间,方法如下

1. 把各个操作数不重复地排成一排
2. 标出各个运算符的生效顺序（先后顺序有点出入无所谓)
3. 按顺序加入运算符，注意"分层"
4. 从底向上逐层检查同层的运算符是否可以合体

- example1

![20220826005116](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220826005116.png)

![20220826005129](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220826005129.png)

- example2⭐⭐

![20220826005239](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220826005239.png)

![20220826005207](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220826005207.png)

## 习题选择题

⭐⭐⭐

- 03有权值相同的边, 树可能唯一![20221007165050](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221007165050.png)
- 04Floyd算法 $Path_k$和$path_{k-1}$的关系![20221007165611](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221007165611.png)
- 05最短路径的另一算法![20221007165741](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221007165741.png)
- 06DFS的作用![DFS的作用](https://raw.githubusercontent.com/Logible/Image/main/note_image/DFS的作用.png)
- 13权值最小n-1条边不一定![20221007170214](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221007170214.png)
- 19C N个结点构成环![N个结点构成环](https://raw.githubusercontent.com/Logible/Image/main/note_image/N个结点构成环.png)

## 真题

⭐⭐⭐

- 2017 满足条件, 生成树唯一![20221108222908](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221108222908.png)
  - 当带权连通图的任意一个环中所包含的边的权值均不相同时，其MST是唯一的。
  - 此题不要求回答充分必要条件，所以回答一个限制边权值的充分条件即可
- 2018![20221108223303](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221108223303.png)
  - ![20221108223238](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221108223238.png)

⭐

- 2011上三角矩阵![20221107221912](https://raw.githubusercontent.com/Logible/Image/main/note_image/20221107221912.png)
