# 图的遍历

- [图的遍历](#图的遍历)
  - [6.3.1 广度优先搜索 Breadth-First-Search](#631-广度优先搜索-breadth-first-search)
    - [广度优先生成树](#广度优先生成树)
  - [6.3.2 深度优先搜索 Depth-First-Search](#632-深度优先搜索-depth-first-search)
    - [深度优先的生成树和生成森林](#深度优先的生成树和生成森林)
  - [6.3.3 图的遍历与图的连通性](#633-图的遍历与图的连通性)

## 6.3.1 广度优先搜索 Breadth-First-Search

![20220824010510](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220824010510.png)

1. 广度优先搜索遍历
   1. 是以V为起始点，由近至远依次访问和V有路径相通且路径长度为$1,2,...$的顶点

2. 性能分析
   1. 无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q, n个顶点均需入队一次
      1. 在最坏的情况下，空间复杂度为$O(|V|)$
      2. ![最坏情况](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220823230308.png)
   2. 采用邻接表存储方式时
      1. 每个顶点均需搜索一次(或入队一次)，故时间复杂度为$O(|V|)$
      2. 在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为$O(|E|)$
      3. 算法总的时间复杂度为$O(|V|+|E|)$.
   3. 采用邻接矩阵存储方式时
      1. 每个顶点均需搜索一次(或入队一次)，故时间复杂度为$O(|V|)$
      2. 查找每个顶点的邻接点所需的时间为$O(V)$，故算法总的时间复杂度为$O(|V|^2)$

- 代码实现

```c
bool visited[MAX_VERTEX_NUM]; //访问标记数组

void BFSTraverse(Graph G)
{
   for (int i = 0; i < G.vexnum; i++)
      visited[i] = false;
   InitQueue(Q);
   for (int i = 0; i < G.vexnum; i++) //对每个连通分量调用一次BFS
      if (!visited[i])
         BFS(G, i);
}

//从顶点v出发, 广度优先遍历图G
void BFS(Graph G, int v)
{
   visit(v);          //访问初始顶点v
   visited[v] = true; //对v做已访问标记
   EnQueue(Q, v);     //顶点V入队列
   while (!isEmpty(Q))
   {
      Dequeue(Q, v);                                                   //顶点v出队列
      //⭐⭐⭐⭐NextNeighbor为什么可以遍历所有结点
      for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) //检测v所有邻点
      {
         if (!visited[w])// w为v的尚未访问的邻接顶点
         {            
            visit(w); //访问顶点w
            visited[w] = true;
            EnQueue(Q, W); //顶点w入队列
         }
      }
   }
}
```

### 广度优先生成树

![20220824204501](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220824204501.png)

1. 定义
   1. 广度遍历的过程中得到一棵遍历树，称为广度优先生成树
2. 如图所示。需要注意的是
   1. 一给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是**唯一的**
   2. 但由于邻接表存储表示不唯一，故其广度优先生成树也是**不唯一的**

## 6.3.2 深度优先搜索 Depth-First-Search

![20220824005859](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220824005859.png)

![20220824010300](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220824010300.png)

1. 定义
   1. 首先访问图中某一起始顶点$v$, 然后由$v$岀发, 访问与$v$邻接且未被访问的任一顶点$w_1$,再访问与$w_1$邻接且未被访问的任一顶点$w_2$...重复上述过程
   2. 当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。

2. 性能分析
   1. DFS算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为$O(|V|)$
      1. ![worst situation](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220824010327.png)
   2. 遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所用的存储结构(同BFS)

- 代码实现

```c
bool visited[MAX_VERTEX_NUM]; //访问标记数组

void BFSTraverse(Graph G)
{
   //初始化以访问标记数据
   for (int i = 0; i < G.vexnum; i++)
      visited[i] = false;

   for (int i = 0; i < G.vexnum; i++) //对每个连通分量调用一次BFS
      if (!visited[i])
         DFS(G, i);
}

//从顶点v出发, 深度优先遍历图G
void DFS(Graph G, int v)
{
   visit(v);                                                        //访问初始顶点v
   visited[v] = true;                                               //对v做已访问标记
   for (w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) //检测v所有邻点
   {
      // w为v的尚未访问的邻接顶点
      if (!visited[w])
      {
         DFS(G, v);
      }
   }
}
```

### 深度优先的生成树和生成森林

![20220823230528](https://raw.githubusercontent.com/Logible/Image/main/note_image/20220823230528.png)

1. 定义深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的， 即对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林
2. 如图6.13所示。与BFS类似，基于**邻接表**存储的深度优先生成树是不唯一的

## 6.3.3 图的遍历与图的连通性

1. 对无向图进行BFS/DFS遍历
   1. 调用BFS/DFS函数的次数=**连通分量数**
   2. 对于连通图，只需调用1次 BFS/DFS

2. 对有向图进行BFS/DFS遍历, 调用BFS/DFS函数的次数要具体问题具体分析
   1. 若起始顶点到其他各顶点**都有路径**，则只需调用1次BFS/DFS函数
   2. 对于**强连通图**，从任一结点出发都只需调用1次 BFS/DFS
